<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DoHungThinhTin</title>
  
  <subtitle>DoHungThinh</subtitle>
  <link href="https://dohungthinhsts.github.io/atom.xml" rel="self"/>
  
  <link href="https://dohungthinhsts.github.io/"/>
  <updated>2024-09-09T09:30:29.200Z</updated>
  <id>https://dohungthinhsts.github.io/</id>
  
  <author>
    <name>ThinhDo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>How a Single Example Can Illustrate Multiple SOLID Principles</title>
    <link href="https://dohungthinhsts.github.io/2024/09/09/understanding-solid-combined/"/>
    <id>https://dohungthinhsts.github.io/2024/09/09/understanding-solid-combined/</id>
    <published>2024-09-09T05:00:00.000Z</published>
    <updated>2024-09-09T09:30:29.200Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/09/09/understanding-solid-combined/solid-example.png" class="" title="solid-example"></center><br><h2 id="How-a-Single-Example-Can-Illustrate-Multiple-SOLID-Principles"><a href="#How-a-Single-Example-Can-Illustrate-Multiple-SOLID-Principles" class="headerlink" title="How a Single Example Can Illustrate Multiple SOLID Principles"></a>How a Single Example Can Illustrate Multiple SOLID Principles</h2><p>Hello, fellow software designers! Today, we’re going to explore an interesting insight: <strong>A single example can often illustrate multiple SOLID principles</strong>. These principles are deeply interrelated, and applying one principle often leads to compliance with others. Let’s see how!</p><h3 id="Understanding-How-SOLID-Principles-Interconnect"><a href="#Understanding-How-SOLID-Principles-Interconnect" class="headerlink" title="Understanding How SOLID Principles Interconnect"></a>Understanding How SOLID Principles Interconnect</h3><p>The SOLID principles aim to achieve the same overarching goals — <strong>maintainability, flexibility, and clarity</strong> in software design. Here’s how they connect:</p><ul><li><strong>Single Responsibility Principle (SRP)</strong>: Encourages separating responsibilities, inherently reducing coupling.</li><li><strong>Open&#x2F;Closed Principle (OCP)</strong>: Promotes extension over modification, often involving using abstractions, aligning with the <strong>Dependency Inversion Principle (DIP)</strong>.</li><li><strong>Liskov Substitution Principle (LSP)</strong>: Ensures that subclasses can stand in for their base classes, a natural outcome of following OCP and DIP.</li><li><strong>Interface Segregation Principle (ISP)</strong>: Splits large interfaces into smaller, specific ones, supporting SRP and enabling easier substitution (LSP).</li><li><strong>Dependency Inversion Principle (DIP)</strong>: Relies on abstractions rather than concrete implementations, which helps keep modules closed for modification but open for extension (OCP).</li></ul><h3 id="Example-Construction-Project-Management"><a href="#Example-Construction-Project-Management" class="headerlink" title="Example: Construction Project Management"></a>Example: Construction Project Management</h3><p>Let’s revisit our <strong>Construction Project Management</strong> example, which was initially used to illustrate the <strong>Dependency Inversion Principle (DIP)</strong>:</p><h4 id="The-Example-Construction-Project-Management"><a href="#The-Example-Construction-Project-Management" class="headerlink" title="The Example: Construction Project Management"></a>The Example: Construction Project Management</h4><ul><li><strong>Worker Interface</strong>: An interface defining a general <code>perform_work</code> method.</li><li><strong>Specific Workers</strong>: Classes like <code>Electrician</code>, <code>Plumber</code>, and <code>Carpenter</code> that implement the <code>Worker</code> interface.</li><li><strong>Project Manager</strong>: A class that depends on the <code>Worker</code> interface instead of specific worker classes.</li></ul><h4 id="How-This-Example-Illustrates-Multiple-Principles"><a href="#How-This-Example-Illustrates-Multiple-Principles" class="headerlink" title="How This Example Illustrates Multiple Principles"></a>How This Example Illustrates Multiple Principles</h4><ol><li><p><strong>Single Responsibility Principle (SRP)</strong></p><ul><li>Each worker class (<code>Electrician</code>, <code>Plumber</code>, <code>Carpenter</code>) has a single responsibility: performing its specific type of work.</li><li>The <code>ProjectManager</code> class is only responsible for managing work, not for knowing the details of each type of work.</li></ul></li><li><p><strong>Open&#x2F;Closed Principle (OCP)</strong></p><ul><li>The <code>ProjectManager</code> class is closed for modification but open for extension. You can add new worker types (like <code>Painter</code>) without modifying the <code>ProjectManager</code> class.</li></ul></li><li><p><strong>Liskov Substitution Principle (LSP)</strong></p><ul><li>Any worker class (<code>Electrician</code>, <code>Plumber</code>, <code>Carpenter</code>) can replace the <code>Worker</code> interface without affecting the <code>ProjectManager</code>‘s functionality. The <code>ProjectManager</code> is designed to work with any class that adheres to the <code>Worker</code> interface.</li></ul></li><li><p><strong>Interface Segregation Principle (ISP)</strong></p><ul><li>By having a specific interface (<code>Worker</code>), we avoid forcing the <code>Electrician</code> class to implement methods related to plumbing or carpentry, aligning with the idea of not forcing clients to depend on methods they do not use.</li></ul></li><li><p><strong>Dependency Inversion Principle (DIP)</strong></p><ul><li>The high-level <code>ProjectManager</code> class depends on an abstraction (<code>Worker</code>) rather than concrete classes (<code>Electrician</code>, <code>Plumber</code>). The details (how each worker does their job) depend on the abstraction.</li></ul></li></ol><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>A single, well-thought-out example can demonstrate how multiple SOLID principles work together to create a robust, maintainable, and flexible design. These principles complement each other, often leading to designs that naturally satisfy more than one principle.</p><p>By understanding how these principles interrelate, you can build systems that are both easier to develop and maintain over time. The key is to think holistically about your design, ensuring it is coherent and aligns with these principles to the greatest extent possible.</p><p>Stay tuned for more insights into software design principles and patterns!</p><p><em>Thôi Lo Code Đi Kẻo Sếp nạt!!</em></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/09/09/understanding-solid-combined/solid-example.png&quot; class=&quot;&quot; title=&quot;solid-example&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;How-</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software-Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Software-Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="SOLID-Principles" scheme="https://dohungthinhsts.github.io/tags/SOLID-Principles/"/>
    
  </entry>
  
  <entry>
    <title>Achieving Low Coupling and High Cohesion in Software Design</title>
    <link href="https://dohungthinhsts.github.io/2024/02/29/low_coupling_high_cohesion/"/>
    <id>https://dohungthinhsts.github.io/2024/02/29/low_coupling_high_cohesion/</id>
    <published>2024-02-29T05:00:00.000Z</published>
    <updated>2024-07-06T03:13:11.754Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/02/29/low_coupling_high_cohesion/entropy.svg" class="" title="entropy"></center><br><h2 id="Achieving-Low-Coupling-and-High-Cohesion-in-Software-Design"><a href="#Achieving-Low-Coupling-and-High-Cohesion-in-Software-Design" class="headerlink" title="Achieving Low Coupling and High Cohesion in Software Design."></a>Achieving Low Coupling and High Cohesion in Software Design.</h2><p>  Hello, fellow software designers! Today, we’re going to explore two fundamental principles in software design: <strong>low coupling</strong> and <strong>high cohesion</strong>. These principles are essential for creating maintainable, flexible, and scalable software systems. Let’s dive deep into what they mean, why they matter, and how to achieve them with practical examples and illustrations.</p><h3 id="What-is-Low-Coupling"><a href="#What-is-Low-Coupling" class="headerlink" title="What is Low Coupling?"></a>What is Low Coupling?</h3><p>Low coupling refers to reducing the interdependencies between software modules. When modules are loosely coupled, changes in one module have minimal impact on others. This leads to more flexible and maintainable systems.</p><p><strong>Example of Low Coupling</strong>:</p><center><img src="/2024/02/29/low_coupling_high_cohesion/entropy-and-coupling.svg" class="" title="entropy-and-coupling"></center><h3 id="Why-Low-Coupling-Matters"><a href="#Why-Low-Coupling-Matters" class="headerlink" title="Why Low Coupling Matters"></a>Why Low Coupling Matters</h3><ul><li><strong>Easier Maintenance</strong>: Changes in one module require fewer modifications in others.</li><li><strong>Improved Reusability</strong>: Modules can be reused across different projects with minimal adjustments.</li><li><strong>Enhanced Testability</strong>: Isolated modules are easier to test independently.</li></ul><h3 id="What-is-High-Cohesion"><a href="#What-is-High-Cohesion" class="headerlink" title="What is High Cohesion?"></a>What is High Cohesion?</h3><p>High cohesion refers to the degree to which the elements within a module belong together. A highly cohesive module performs a single task or a group of related tasks, leading to clearer and more understandable code.</p><p><strong>Example of High Cohesion</strong>:</p><center><img src="/2024/02/29/low_coupling_high_cohesion/entropy-and-cohesion.svg" class="" title="entropy-and-cohesion"></center><h3 id="Why-High-Cohesion-Matters"><a href="#Why-High-Cohesion-Matters" class="headerlink" title="Why High Cohesion Matters"></a>Why High Cohesion Matters</h3><ul><li><strong>Enhanced Readability</strong>: Modules with a clear purpose are easier to understand.</li><li><strong>Simplified Maintenance</strong>: Changes are easier to implement within a cohesive module.</li><li><strong>Better Reliability</strong>: Modules focused on a single task are less prone to errors.</li></ul><h3 id="Achieving-Low-Coupling-and-High-Cohesion"><a href="#Achieving-Low-Coupling-and-High-Cohesion" class="headerlink" title="Achieving Low Coupling and High Cohesion"></a>Achieving Low Coupling and High Cohesion</h3><p>Here are some strategies to achieve low coupling and high cohesion in your software design:</p><ol><li><strong>Encapsulation</strong>: Encapsulate related functions and data within a module to ensure high cohesion.</li><li><strong>Interface Segregation</strong>: Use interfaces to separate concerns and reduce coupling.</li><li><strong>Dependency Injection</strong>: Inject dependencies rather than hard-coding them, promoting loose coupling.</li><li><strong>Modular Design</strong>: Design your system in well-defined, self-contained modules.</li></ol><p><strong>Example of Good Design</strong>:</p><center></center><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re building an e-commerce platform. Here’s how low coupling and high cohesion can improve your design:</p><ul><li><strong>Payment Processing Module</strong>: Encapsulate all payment-related functions within a single module (high cohesion) and ensure it interacts with other modules through well-defined interfaces (low coupling).</li></ul><p><strong>Example of Payment Processing Module</strong>:</p><h3 id="Code-Examples"><a href="#Code-Examples" class="headerlink" title="Code Examples"></a>Code Examples</h3><h4 id="Without-Low-Coupling-and-High-Cohesion"><a href="#Without-Low-Coupling-and-High-Cohesion" class="headerlink" title="Without Low Coupling and High Cohesion"></a>Without Low Coupling and High Cohesion</h4><pre><code class="ruby">class Order  def process_order(payment_type)    if payment_type == &quot;credit_card&quot;      process_credit_card_payment    elsif payment_type == &quot;paypal&quot;      process_paypal_payment    else      raise &quot;Unsupported payment type&quot;    end  end  def process_credit_card_payment    # Credit card processing logic  end  def process_paypal_payment    # PayPal processing logic  endend</code></pre><p><em>Drawbacks</em>: The <code>Order</code> class is responsible for too many things, making it difficult to maintain and extend.</p><h4 id="With-Low-Coupling-and-High-Cohesion"><a href="#With-Low-Coupling-and-High-Cohesion" class="headerlink" title="With Low Coupling and High Cohesion"></a>With Low Coupling and High Cohesion</h4><pre><code class="ruby">class Order  def initialize(payment_processor)    @payment_processor = payment_processor  end  def process_order    @payment_processor.process_payment  endendclass CreditCardPaymentProcessor  def process_payment    # Credit card processing logic  endendclass PaypalPaymentProcessor  def process_payment    # PayPal processing logic  endend# Usagecredit_card_processor = CreditCardPaymentProcessor.neworder = Order.new(credit_card_processor)order.process_order</code></pre><p><em>Benefits</em>: The <code>Order</code> class is now only responsible for processing orders, and different payment processors can be easily swapped out or added without modifying the <code>Order</code> class.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>By focusing on low coupling and high cohesion, you can create software systems that are more maintainable, flexible, and scalable. These principles help ensure that your codebase remains robust and adaptable to changes over time. Incorporate these design strategies to build more reliable and efficient software.</p><p>Stay tuned for more insights into software design principles and patterns.</p><p><em>Thôi Lo Code Đi Kẻo Sếp nạt!!</em></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/02/29/low_coupling_high_cohesion/entropy.svg&quot; class=&quot;&quot; title=&quot;entropy&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;Achieving-Low-Coup</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software-Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Software-Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Low-Coupling" scheme="https://dohungthinhsts.github.io/tags/Low-Coupling/"/>
    
    <category term="High-Cohesion" scheme="https://dohungthinhsts.github.io/tags/High-Cohesion/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Behavioral Patterns - The Visitor Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/02/24/deep_dive_visitor_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/02/24/deep_dive_visitor_pattern/</id>
    <published>2024-02-24T05:00:00.000Z</published>
    <updated>2024-07-05T07:36:23.981Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/02/24/deep_dive_visitor_pattern/visitor_pattern.png" class="" title="visitor_pattern"></center><br><h2 id="Deep-Dive-into-Behavioral-Patterns-The-Visitor-Pattern"><a href="#Deep-Dive-into-Behavioral-Patterns-The-Visitor-Pattern" class="headerlink" title="Deep Dive into Behavioral Patterns - The Visitor Pattern."></a>Deep Dive into Behavioral Patterns - The Visitor Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Visitor pattern. This pattern is essential for separating algorithms from the objects on which they operate. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Visitor-Pattern"><a href="#What-is-the-Visitor-Pattern" class="headerlink" title="What is the Visitor Pattern?"></a>What is the Visitor Pattern?</h3><p>The Visitor pattern is a behavioral design pattern that allows you to separate algorithms from the objects on which they operate. By using this pattern, you can add new operations to existing object structures without modifying their classes.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a reporting system for a complex object structure in a company (e.g., employees, departments). Each element has specific attributes, but you need to generate various types of reports.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When you need to perform operations across a complex object structure, implementing the operations directly within the objects can lead to a tightly coupled and inflexible codebase. This approach makes it difficult to add new operations without modifying the existing code.</p><h4 id="Without-Visitor-Pattern"><a href="#Without-Visitor-Pattern" class="headerlink" title="Without Visitor Pattern"></a>Without Visitor Pattern</h4><pre><code class="ruby">class Employee  attr_accessor :name, :salary  def initialize(name, salary)    @name = name    @salary = salary  end  def report    &quot;Employee Report: #&#123;@name&#125; - #&#123;@salary&#125;&quot;  endendclass Department  attr_accessor :name, :employees  def initialize(name)    @name = name    @employees = []  end  def add_employee(employee)    @employees &lt;&lt; employee  end  def report    report = &quot;Department Report: #&#123;@name&#125;&quot;    @employees.each &#123; |e| report += e.report + &quot;&quot; &#125;    report  endendemployee = Employee.new(&#39;Alice&#39;, 50000)department = Department.new(&#39;HR&#39;)department.add_employee(employee)puts department.report</code></pre><p><em>Drawbacks</em>: The code is tightly coupled and difficult to extend to support new operations.</p><h3 id="The-Solution-Visitor-Pattern"><a href="#The-Solution-Visitor-Pattern" class="headerlink" title="The Solution: Visitor Pattern"></a>The Solution: Visitor Pattern</h3><p>Using the Visitor pattern, we can encapsulate the operations within separate visitor classes, promoting flexibility and scalability.</p><h4 id="With-Visitor-Pattern"><a href="#With-Visitor-Pattern" class="headerlink" title="With Visitor Pattern"></a>With Visitor Pattern</h4><p><strong>Step 1: Define the Element Interface</strong></p><pre><code class="ruby">class Element  def accept(visitor)    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 2: Create Concrete Elements</strong></p><pre><code class="ruby">class Employee &lt; Element  attr_accessor :name, :salary  def initialize(name, salary)    @name = name    @salary = salary  end  def accept(visitor)    visitor.visit_employee(self)  endendclass Department &lt; Element  attr_accessor :name, :employees  def initialize(name)    @name = name    @employees = []  end  def add_employee(employee)    @employees &lt;&lt; employee  end  def accept(visitor)    visitor.visit_department(self)  endend</code></pre><p><strong>Step 3: Define the Visitor Interface</strong></p><pre><code class="ruby">class Visitor  def visit_employee(employee)    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  end  def visit_department(department)    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 4: Create Concrete Visitors</strong></p><pre><code class="ruby">class ReportVisitor &lt; Visitor  def visit_employee(employee)    &quot;Employee Report: #&#123;employee.name&#125; - #&#123;employee.salary&#125;&quot;  end  def visit_department(department)    report = &quot;Department Report: #&#123;department.name&#125;&quot;    department.employees.each &#123; |e| report += visit_employee(e) + &quot;&quot; &#125;    report  endend</code></pre><p><strong>Step 5: Implement the Client Code</strong></p><pre><code class="ruby">employee = Employee.new(&#39;Alice&#39;, 50000)department = Department.new(&#39;HR&#39;)department.add_employee(employee)visitor = ReportVisitor.newputs department.accept(visitor)</code></pre><p><em>Benefits</em>: Encapsulates operations within separate visitor classes, promoting flexibility and scalability.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Adding New Operations</strong></p><p>Imagine you need to add a new operation (e.g., calculating total salaries). Using the Visitor pattern, you can easily introduce a new visitor class without modifying the existing code.</p><p><strong>Without Visitor Pattern:</strong></p><pre><code class="ruby">class Department  def total_salaries    @employees.sum(&amp;:salary)  endendputs department.total_salaries</code></pre><p><em>Drawbacks</em>: Tightly coupled code that is difficult to maintain and extend.</p><p><strong>With Visitor Pattern:</strong></p><pre><code class="ruby">class SalaryVisitor &lt; Visitor  def visit_employee(employee)    employee.salary  end  def visit_department(department)    department.employees.sum &#123; |e| visit_employee(e) &#125;  endendvisitor = SalaryVisitor.newputs department.accept(visitor)</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and extensibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Visitor pattern is a powerful tool for separating algorithms from the objects on which they operate. It promotes flexibility, scalability, and maintainability in your code. By using the Visitor pattern, you can easily add new operations to existing object structures without modifying their classes. Incorporate the Visitor pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns. </p><p>Thôi Lo Code Đi Kẻo Sếp nạt!!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/02/24/deep_dive_visitor_pattern/visitor_pattern.png&quot; class=&quot;&quot; title=&quot;visitor_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;Dee</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software-Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design-Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Software-Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Visitor-Pattern" scheme="https://dohungthinhsts.github.io/tags/Visitor-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Behavioral Patterns - The Template Method Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/02/21/deep_dive_template_method_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/02/21/deep_dive_template_method_pattern/</id>
    <published>2024-02-21T05:00:00.000Z</published>
    <updated>2024-07-05T07:36:23.867Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/02/21/deep_dive_template_method_pattern/template_method_pattern.png" class="" title="template_method_pattern"></center><br><h2 id="Deep-Dive-into-Behavioral-Patterns-The-Template-Method-Pattern"><a href="#Deep-Dive-into-Behavioral-Patterns-The-Template-Method-Pattern" class="headerlink" title="Deep Dive into Behavioral Patterns - The Template Method Pattern."></a>Deep Dive into Behavioral Patterns - The Template Method Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Template Method pattern. This pattern is essential for defining the skeleton of an algorithm in a base class but allowing subclasses to override specific steps without changing the algorithm’s structure. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Template-Method-Pattern"><a href="#What-is-the-Template-Method-Pattern" class="headerlink" title="What is the Template Method Pattern?"></a>What is the Template Method Pattern?</h3><p>The Template Method pattern is a behavioral design pattern that defines the skeleton of an algorithm in a base class but allows subclasses to override specific steps without changing the algorithm’s structure. This pattern is particularly useful for creating reusable and customizable algorithms.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a data processing application that needs to process different types of data (e.g., CSV, XML, JSON). Each data type has its specific processing steps, but the overall structure of the processing algorithm remains the same.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When different data types need to be processed using a similar algorithm, directly implementing the algorithm within each data type class can lead to duplicated and inflexible code. This approach makes it difficult to maintain and extend the algorithm.</p><h4 id="Without-Template-Method-Pattern"><a href="#Without-Template-Method-Pattern" class="headerlink" title="Without Template Method Pattern"></a>Without Template Method Pattern</h4><pre><code class="ruby">class CSVProcessor  def process    read_data    parse_data    format_data    save_data  end  def read_data    puts &#39;Reading CSV data&#39;  end  def parse_data    puts &#39;Parsing CSV data&#39;  end  def format_data    puts &#39;Formatting CSV data&#39;  end  def save_data    puts &#39;Saving CSV data&#39;  endendclass XMLProcessor  def process    read_data    parse_data    format_data    save_data  end  def read_data    puts &#39;Reading XML data&#39;  end  def parse_data    puts &#39;Parsing XML data&#39;  end  def format_data    puts &#39;Formatting XML data&#39;  end  def save_data    puts &#39;Saving XML data&#39;  endendcsv_processor = CSVProcessor.newcsv_processor.processxml_processor = XMLProcessor.newxml_processor.process</code></pre><p><em>Drawbacks</em>: The code is duplicated and difficult to maintain.</p><h3 id="The-Solution-Template-Method-Pattern"><a href="#The-Solution-Template-Method-Pattern" class="headerlink" title="The Solution: Template Method Pattern"></a>The Solution: Template Method Pattern</h3><p>Using the Template Method pattern, we can define the skeleton of the algorithm in a base class and allow subclasses to override specific steps, promoting code reuse and flexibility.</p><h4 id="With-Template-Method-Pattern"><a href="#With-Template-Method-Pattern" class="headerlink" title="With Template Method Pattern"></a>With Template Method Pattern</h4><p><strong>Step 1: Define the Base Class</strong></p><pre><code class="ruby">class DataProcessor  def process    read_data    parse_data    format_data    save_data  end  def read_data    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  end  def parse_data    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  end  def format_data    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  end  def save_data    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 2: Create Concrete Subclasses</strong></p><pre><code class="ruby">class CSVProcessor &lt; DataProcessor  def read_data    puts &#39;Reading CSV data&#39;  end  def parse_data    puts &#39;Parsing CSV data&#39;  end  def format_data    puts &#39;Formatting CSV data&#39;  end  def save_data    puts &#39;Saving CSV data&#39;  endendclass XMLProcessor &lt; DataProcessor  def read_data    puts &#39;Reading XML data&#39;  end  def parse_data    puts &#39;Parsing XML data&#39;  end  def format_data    puts &#39;Formatting XML data&#39;  end  def save_data    puts &#39;Saving XML data&#39;  endend</code></pre><p><strong>Step 3: Implement the Client Code</strong></p><pre><code class="ruby">csv_processor = CSVProcessor.newcsv_processor.processxml_processor = XMLProcessor.newxml_processor.process</code></pre><p><em>Benefits</em>: Defines the skeleton of the algorithm in a base class and allows subclasses to override specific steps, promoting code reuse and flexibility.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Adding New Data Types</strong></p><p>Imagine you need to add a new data type (e.g., JSON). Using the Template Method pattern, you can easily introduce a new subclass without modifying the existing code.</p><p><strong>Without Template Method Pattern:</strong></p><pre><code class="ruby">class JSONProcessor  def process    read_data    parse_data    format_data    save_data  end  def read_data    puts &#39;Reading JSON data&#39;  end  def parse_data    puts &#39;Parsing JSON data&#39;  end  def format_data    puts &#39;Formatting JSON data&#39;  end  def save_data    puts &#39;Saving JSON data&#39;  endendjson_processor = JSONProcessor.newjson_processor.process</code></pre><p><em>Drawbacks</em>: Duplicated code that is difficult to maintain and extend.</p><p><strong>With Template Method Pattern:</strong></p><pre><code class="ruby">class JSONProcessor &lt; DataProcessor  def read_data    puts &#39;Reading JSON data&#39;  end  def parse_data    puts &#39;Parsing JSON data&#39;  end  def format_data    puts &#39;Formatting JSON data&#39;  end  def save_data    puts &#39;Saving JSON data&#39;  endendjson_processor = JSONProcessor.newjson_processor.process</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and extensibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Template Method pattern is a powerful tool for defining the skeleton of an algorithm in a base class but allowing subclasses to override specific steps. It promotes flexibility, scalability, and maintainability in your code. By using the Template Method pattern, you can easily manage similar algorithms within your applications without duplicating code. Incorporate the Template Method pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns. </p><p>Thôi Lo Code Đi Kẻo Sếp nạt!!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/02/21/deep_dive_template_method_pattern/template_method_pattern.png&quot; class=&quot;&quot; title=&quot;template_method_pattern&quot;&gt;
&lt;/ce</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software-Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design-Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Software-Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Template-Method-Pattern" scheme="https://dohungthinhsts.github.io/tags/Template-Method-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Behavioral Patterns - The Strategy Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/02/19/deep_dive_strategy_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/02/19/deep_dive_strategy_pattern/</id>
    <published>2024-02-19T05:00:00.000Z</published>
    <updated>2024-07-05T07:36:23.868Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/02/19/deep_dive_strategy_pattern/strategy_pattern.png" class="" title="strategy_pattern"></center><br><h2 id="Deep-Dive-into-Behavioral-Patterns-The-Strategy-Pattern"><a href="#Deep-Dive-into-Behavioral-Patterns-The-Strategy-Pattern" class="headerlink" title="Deep Dive into Behavioral Patterns - The Strategy Pattern."></a>Deep Dive into Behavioral Patterns - The Strategy Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Strategy pattern. This pattern is essential for defining a family of algorithms, encapsulating each one, and making them interchangeable. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Strategy-Pattern"><a href="#What-is-the-Strategy-Pattern" class="headerlink" title="What is the Strategy Pattern?"></a>What is the Strategy Pattern?</h3><p>The Strategy pattern is a behavioral design pattern that defines a family of algorithms, encapsulates each one, and makes them interchangeable. This pattern allows the algorithm to vary independently from clients that use it.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a payment processing system that needs to support multiple payment methods like credit card, PayPal, and Bitcoin. Each payment method has a distinct processing algorithm.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When multiple algorithms need to be used interchangeably, directly implementing them within the context class can lead to a tightly coupled and inflexible codebase. This approach makes it difficult to add or modify algorithms without changing the existing code.</p><h4 id="Without-Strategy-Pattern"><a href="#Without-Strategy-Pattern" class="headerlink" title="Without Strategy Pattern"></a>Without Strategy Pattern</h4><pre><code class="ruby">class PaymentProcessor  def process(payment_method, amount)    if payment_method == &#39;credit_card&#39;      puts &quot;Processing credit card payment of #&#123;amount&#125;&quot;    elsif payment_method == &#39;paypal&#39;      puts &quot;Processing PayPal payment of #&#123;amount&#125;&quot;    elsif payment_method == &#39;bitcoin&#39;      puts &quot;Processing Bitcoin payment of #&#123;amount&#125;&quot;    end  endendprocessor = PaymentProcessor.newprocessor.process(&#39;credit_card&#39;, 100)processor.process(&#39;paypal&#39;, 200)processor.process(&#39;bitcoin&#39;, 300)</code></pre><p><em>Drawbacks</em>: The code is tightly coupled to specific algorithms and hard to extend to support new algorithms.</p><h3 id="The-Solution-Strategy-Pattern"><a href="#The-Solution-Strategy-Pattern" class="headerlink" title="The Solution: Strategy Pattern"></a>The Solution: Strategy Pattern</h3><p>Using the Strategy pattern, we can encapsulate each algorithm within a separate strategy class, promoting flexibility and scalability.</p><h4 id="With-Strategy-Pattern"><a href="#With-Strategy-Pattern" class="headerlink" title="With Strategy Pattern"></a>With Strategy Pattern</h4><p><strong>Step 1: Define the Strategy Interface</strong></p><pre><code class="ruby">class PaymentStrategy  def pay(amount)    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 2: Create Concrete Strategies</strong></p><pre><code class="ruby">class CreditCardStrategy &lt; PaymentStrategy  def pay(amount)    puts &quot;Processing credit card payment of #&#123;amount&#125;&quot;  endendclass PayPalStrategy &lt; PaymentStrategy  def pay(amount)    puts &quot;Processing PayPal payment of #&#123;amount&#125;&quot;  endendclass BitcoinStrategy &lt; PaymentStrategy  def pay(amount)    puts &quot;Processing Bitcoin payment of #&#123;amount&#125;&quot;  endend</code></pre><p><strong>Step 3: Implement the Context</strong></p><pre><code class="ruby">class PaymentProcessor  attr_accessor :strategy  def initialize(strategy)    @strategy = strategy  end  def process(amount)    @strategy.pay(amount)  endendprocessor = PaymentProcessor.new(CreditCardStrategy.new)processor.process(100)processor.strategy = PayPalStrategy.newprocessor.process(200)processor.strategy = BitcoinStrategy.newprocessor.process(300)</code></pre><p><em>Benefits</em>: Encapsulates each algorithm within a separate strategy class, promoting flexibility and scalability.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Adding New Payment Methods</strong></p><p>Imagine you need to add a new payment method (e.g., Apple Pay). Using the Strategy pattern, you can easily introduce a new strategy without modifying the existing code.</p><p><strong>Without Strategy Pattern:</strong></p><pre><code class="ruby">class PaymentProcessor  def process(payment_method, amount)    if payment_method == &#39;credit_card&#39;      puts &quot;Processing credit card payment of #&#123;amount&#125;&quot;    elsif payment_method == &#39;paypal&#39;      puts &quot;Processing PayPal payment of #&#123;amount&#125;&quot;    elsif payment_method == &#39;bitcoin&#39;      puts &quot;Processing Bitcoin payment of #&#123;amount&#125;&quot;    elsif payment_method == &#39;apple_pay&#39;      puts &quot;Processing Apple Pay payment of #&#123;amount&#125;&quot;    end  endendprocessor = PaymentProcessor.newprocessor.process(&#39;apple_pay&#39;, 400)</code></pre><p><em>Drawbacks</em>: Tightly coupled code that is difficult to maintain and extend.</p><p><strong>With Strategy Pattern:</strong></p><pre><code class="ruby">class ApplePayStrategy &lt; PaymentStrategy  def pay(amount)    puts &quot;Processing Apple Pay payment of #&#123;amount&#125;&quot;  endendprocessor = PaymentProcessor.new(ApplePayStrategy.new)processor.process(400)</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and extensibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Strategy pattern is a powerful tool for defining a family of algorithms, encapsulating each one, and making them interchangeable. It promotes flexibility, scalability, and maintainability in your code. By using the Strategy pattern, you can easily manage multiple algorithms within your applications without tightly coupling the code. Incorporate the Strategy pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns. </p><p>Thôi Lo Code Đi Kẻo Sếp nạt!!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/02/19/deep_dive_strategy_pattern/strategy_pattern.png&quot; class=&quot;&quot; title=&quot;strategy_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software-Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design-Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Software-Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Strategy-Pattern" scheme="https://dohungthinhsts.github.io/tags/Strategy-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Behavioral Patterns - The State Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/02/17/deep_dive_state_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/02/17/deep_dive_state_pattern/</id>
    <published>2024-02-17T05:00:00.000Z</published>
    <updated>2024-07-05T07:36:23.867Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/02/17/deep_dive_state_pattern/state_pattern.png" class="" title="state_pattern"></center><br><h2 id="Deep-Dive-into-Behavioral-Patterns-The-State-Pattern"><a href="#Deep-Dive-into-Behavioral-Patterns-The-State-Pattern" class="headerlink" title="Deep Dive into Behavioral Patterns - The State Pattern."></a>Deep Dive into Behavioral Patterns - The State Pattern.</h2><p>  Hey software designers! Today, we’re diving into the State pattern. This pattern is essential for allowing an object to alter its behavior when its internal state changes. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-State-Pattern"><a href="#What-is-the-State-Pattern" class="headerlink" title="What is the State Pattern?"></a>What is the State Pattern?</h3><p>The State pattern is a behavioral design pattern that allows an object to alter its behavior when its internal state changes. The object will appear to change its class. This pattern is particularly useful for implementing state machines and managing states within an application.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a video player application. The player can be in different states like playing, paused, or stopped. Each state has specific behaviors and transitions.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When an object needs to change its behavior based on its state, directly implementing state-specific logic within the object can lead to a tightly coupled and inflexible codebase. This approach makes it difficult to add or modify states without changing the existing code.</p><h4 id="Without-State-Pattern"><a href="#Without-State-Pattern" class="headerlink" title="Without State Pattern"></a>Without State Pattern</h4><pre><code class="ruby">class VideoPlayer  attr_accessor :state  def initialize    @state = &#39;stopped&#39;  end  def play    if @state == &#39;stopped&#39;      puts &#39;Starting playback&#39;      @state = &#39;playing&#39;    elsif @state == &#39;paused&#39;      puts &#39;Resuming playback&#39;      @state = &#39;playing&#39;    end  end  def pause    if @state == &#39;playing&#39;      puts &#39;Pausing playback&#39;      @state = &#39;paused&#39;    end  end  def stop    if @state == &#39;playing&#39; || @state == &#39;paused&#39;      puts &#39;Stopping playback&#39;      @state = &#39;stopped&#39;    end  endendplayer = VideoPlayer.newplayer.play # Output: Starting playbackplayer.pause # Output: Pausing playbackplayer.stop # Output: Stopping playback</code></pre><p><em>Drawbacks</em>: The code is tightly coupled and difficult to extend to support new states.</p><h3 id="The-Solution-State-Pattern"><a href="#The-Solution-State-Pattern" class="headerlink" title="The Solution: State Pattern"></a>The Solution: State Pattern</h3><p>Using the State pattern, we can encapsulate state-specific behavior within separate state classes, promoting flexibility and scalability.</p><h4 id="With-State-Pattern"><a href="#With-State-Pattern" class="headerlink" title="With State Pattern"></a>With State Pattern</h4><p><strong>Step 1: Define the State Interface</strong></p><pre><code class="ruby">class State  def play(player)    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  end  def pause(player)    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  end  def stop(player)    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 2: Create Concrete States</strong></p><pre><code class="ruby">class PlayingState &lt; State  def play(player)    puts &#39;Already playing&#39;  end  def pause(player)    puts &#39;Pausing playback&#39;    player.state = PausedState.new  end  def stop(player)    puts &#39;Stopping playback&#39;    player.state = StoppedState.new  endendclass PausedState &lt; State  def play(player)    puts &#39;Resuming playback&#39;    player.state = PlayingState.new  end  def pause(player)    puts &#39;Already paused&#39;  end  def stop(player)    puts &#39;Stopping playback&#39;    player.state = StoppedState.new  endendclass StoppedState &lt; State  def play(player)    puts &#39;Starting playback&#39;    player.state = PlayingState.new  end  def pause(player)    puts &#39;Cannot pause. Player is stopped&#39;  end  def stop(player)    puts &#39;Already stopped&#39;  endend</code></pre><p><strong>Step 3: Implement the Context</strong></p><pre><code class="ruby">class VideoPlayer  attr_accessor :state  def initialize    @state = StoppedState.new  end  def play    @state.play(self)  end  def pause    @state.pause(self)  end  def stop    @state.stop(self)  endendplayer = VideoPlayer.newplayer.play # Output: Starting playbackplayer.pause # Output: Pausing playbackplayer.stop # Output: Stopping playback</code></pre><p><em>Benefits</em>: Encapsulates state-specific behavior within separate state classes, promoting flexibility and scalability.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Adding New States</strong></p><p>Imagine you need to add a new state (e.g., fast-forwarding). Using the State pattern, you can easily introduce a new state without modifying the existing code.</p><p><strong>Without State Pattern:</strong></p><pre><code class="ruby">class VideoPlayer  attr_accessor :state  def initialize    @state = &#39;stopped&#39;  end  def fast_forward    if @state == &#39;playing&#39;      puts &#39;Fast forwarding&#39;      @state = &#39;fast_forwarding&#39;    end  endendplayer = VideoPlayer.newplayer.playplayer.fast_forward # Output: Fast forwarding</code></pre><p><em>Drawbacks</em>: Tightly coupled code that is difficult to maintain and extend.</p><p><strong>With State Pattern:</strong></p><pre><code class="ruby">class FastForwardingState &lt; State  def play(player)    puts &#39;Cannot play. Player is fast-forwarding&#39;  end  def pause(player)    puts &#39;Pausing playback&#39;    player.state = PausedState.new  end  def stop(player)    puts &#39;Stopping playback&#39;    player.state = StoppedState.new  endendclass PlayingState &lt; State  def fast_forward(player)    puts &#39;Fast forwarding&#39;    player.state = FastForwardingState.new  endendplayer = VideoPlayer.newplayer.playplayer.fast_forward # Output: Fast forwarding</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and extensibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The State pattern is a powerful tool for allowing an object to alter its behavior when its internal state changes. It promotes flexibility, scalability, and maintainability in your code. By using the State pattern, you can easily manage state-specific behavior within your applications without tightly coupling the code. Incorporate the State pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns. </p><p>Thôi Lo Code Đi Kẻo Sếp nạt!!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/02/17/deep_dive_state_pattern/state_pattern.png&quot; class=&quot;&quot; title=&quot;state_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;Deep-Dive</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software-Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design-Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Software-Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="State-Pattern" scheme="https://dohungthinhsts.github.io/tags/State-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Behavioral Patterns - The Observer Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/02/14/deep_dive_observer_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/02/14/deep_dive_observer_pattern/</id>
    <published>2024-02-14T05:00:00.000Z</published>
    <updated>2024-07-05T07:36:23.867Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/02/14/deep_dive_observer_pattern/observer_pattern.png" class="" title="observer_pattern"></center><br><h2 id="Deep-Dive-into-Behavioral-Patterns-The-Observer-Pattern"><a href="#Deep-Dive-into-Behavioral-Patterns-The-Observer-Pattern" class="headerlink" title="Deep Dive into Behavioral Patterns - The Observer Pattern."></a>Deep Dive into Behavioral Patterns - The Observer Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Observer pattern. This pattern is essential for establishing a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Observer-Pattern"><a href="#What-is-the-Observer-Pattern" class="headerlink" title="What is the Observer Pattern?"></a>What is the Observer Pattern?</h3><p>The Observer pattern is a behavioral design pattern that establishes a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. It is useful for implementing distributed event-handling systems.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a weather monitoring system where multiple display units need to show the latest weather updates. When the weather changes, all display units should be notified and updated automatically.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When multiple objects depend on the state of another object, directly updating the dependents can lead to a tightly coupled and inflexible codebase. This approach makes it difficult to add or remove dependents without modifying the existing code.</p><h4 id="Without-Observer-Pattern"><a href="#Without-Observer-Pattern" class="headerlink" title="Without Observer Pattern"></a>Without Observer Pattern</h4><pre><code class="ruby">class WeatherStation  attr_accessor :temperature  def initialize    @temperature = 0  end  def set_temperature(temp)    @temperature = temp    update_displays  end  def update_displays    # Update all displays  endendclass Display  def update(temp)    puts &quot;Current temperature: #&#123;temp&#125;°C&quot;  endendstation = WeatherStation.newdisplay1 = Display.newdisplay2 = Display.newstation.set_temperature(25)</code></pre><p><em>Drawbacks</em>: The code is tightly coupled to specific implementations and hard to extend to support new displays.</p><h3 id="The-Solution-Observer-Pattern"><a href="#The-Solution-Observer-Pattern" class="headerlink" title="The Solution: Observer Pattern"></a>The Solution: Observer Pattern</h3><p>Using the Observer pattern, we can decouple the subject from its observers, promoting flexibility and scalability.</p><h4 id="With-Observer-Pattern"><a href="#With-Observer-Pattern" class="headerlink" title="With Observer Pattern"></a>With Observer Pattern</h4><p><strong>Step 1: Define the Observer Interface</strong></p><pre><code class="ruby">class Observer  def update(state)    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 2: Create Concrete Observers</strong></p><pre><code class="ruby">class Display &lt; Observer  def update(state)    puts &quot;Current temperature: #&#123;state&#125;°C&quot;  endend</code></pre><p><strong>Step 3: Define the Subject Interface</strong></p><pre><code class="ruby">class Subject  def initialize    @observers = []  end  def add_observer(observer)    @observers &lt;&lt; observer  end  def remove_observer(observer)    @observers.delete(observer)  end  def notify_observers    @observers.each &#123; |observer| observer.update(@state) &#125;  endend</code></pre><p><strong>Step 4: Create Concrete Subjects</strong></p><pre><code class="ruby">class WeatherStation &lt; Subject  attr_accessor :temperature  def set_temperature(temp)    @temperature = temp    @state = temp    notify_observers  endend</code></pre><p><strong>Step 5: Implement Client Code</strong></p><pre><code class="ruby">station = WeatherStation.newdisplay1 = Display.newdisplay2 = Display.newstation.add_observer(display1)station.add_observer(display2)station.set_temperature(25)</code></pre><p><em>Benefits</em>: Decouples the subject from its observers, promoting flexibility and scalability.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Adding New Observers</strong></p><p>Imagine you need to add new observers (e.g., mobile app display). Using the Observer pattern, you can easily add new observers without modifying the existing code.</p><p><strong>Without Observer Pattern:</strong></p><pre><code class="ruby">class WeatherStation  def update_displays    display1.update(@temperature)    display2.update(@temperature)    mobile_app.update(@temperature)  endendclass MobileApp  def update(temp)    puts &quot;Mobile app display: #&#123;temp&#125;°C&quot;  endendmobile_app = MobileApp.newstation.update_displays</code></pre><p><em>Drawbacks</em>: Tightly coupled code that is difficult to maintain and extend.</p><p><strong>With Observer Pattern:</strong></p><pre><code class="ruby">class MobileApp &lt; Observer  def update(state)    puts &quot;Mobile app display: #&#123;state&#125;°C&quot;  endendmobile_app = MobileApp.newstation.add_observer(mobile_app)station.set_temperature(25)</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and extensibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Observer pattern is a powerful tool for establishing a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. It promotes flexibility, scalability, and maintainability in your code. By using the Observer pattern, you can easily manage and extend the relationships between objects without tightly coupling the code. Incorporate the Observer pattern into your design strategies to build more robust and adaptable software sys…</p><p>Stay tuned for more insights into software design principles and patterns. </p><p>Thôi Lo Code Đi Kẻo Sếp nạt!!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/02/14/deep_dive_observer_pattern/observer_pattern.png&quot; class=&quot;&quot; title=&quot;observer_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software-Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design-Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Software-Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Observer-Pattern" scheme="https://dohungthinhsts.github.io/tags/Observer-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Behavioral Patterns - The Memento Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/02/12/deep_dive_memento_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/02/12/deep_dive_memento_pattern/</id>
    <published>2024-02-12T05:00:00.000Z</published>
    <updated>2024-07-05T07:36:23.867Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/02/12/deep_dive_memento_pattern/memento_pattern.png" class="" title="memento_pattern"></center><br><h2 id="Deep-Dive-into-Behavioral-Patterns-The-Memento-Pattern"><a href="#Deep-Dive-into-Behavioral-Patterns-The-Memento-Pattern" class="headerlink" title="Deep Dive into Behavioral Patterns - The Memento Pattern."></a>Deep Dive into Behavioral Patterns - The Memento Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Memento pattern. This pattern is essential for capturing and restoring an object’s internal state without violating encapsulation. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Memento-Pattern"><a href="#What-is-the-Memento-Pattern" class="headerlink" title="What is the Memento Pattern?"></a>What is the Memento Pattern?</h3><p>The Memento pattern is a behavioral design pattern that allows you to capture and restore an object’s internal state without violating encapsulation. It is useful for implementing undo and redo operations in applications.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a text editor that supports undo and redo functionality. Each change to the document should be reversible, allowing the user to undo or redo changes.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When capturing and restoring an object’s state, directly accessing its internals can lead to a tightly coupled and inflexible codebase. This approach makes it difficult to implement undo and redo functionality without exposing the internal state of the object.</p><h4 id="Without-Memento-Pattern"><a href="#Without-Memento-Pattern" class="headerlink" title="Without Memento Pattern"></a>Without Memento Pattern</h4><pre><code class="ruby">class TextEditor  attr_accessor :text  def initialize    @text = &#39;&#39;    @history = []  end  def write(text)    @history &lt;&lt; @text    @text += text  end  def undo    @text = @history.pop  endendeditor = TextEditor.neweditor.write(&#39;Hello&#39;)editor.write(&#39; World&#39;)puts editor.text # Output: Hello Worldeditor.undoputs editor.text # Output: Hello</code></pre><p><em>Drawbacks</em>: The history is stored within the object, leading to a tightly coupled design.</p><h3 id="The-Solution-Memento-Pattern"><a href="#The-Solution-Memento-Pattern" class="headerlink" title="The Solution: Memento Pattern"></a>The Solution: Memento Pattern</h3><p>Using the Memento pattern, we can capture and restore an object’s state without exposing its internals, promoting flexibility and scalability.</p><h4 id="With-Memento-Pattern"><a href="#With-Memento-Pattern" class="headerlink" title="With Memento Pattern"></a>With Memento Pattern</h4><p><strong>Step 1: Define the Memento</strong></p><pre><code class="ruby">class Memento  attr_reader :state  def initialize(state)    @state = state  endend</code></pre><p><strong>Step 2: Create the Originator</strong></p><pre><code class="ruby">class TextEditor  attr_accessor :text  def initialize    @text = &#39;&#39;  end  def write(text)    @text += text  end  def create_memento    Memento.new(@text.dup)  end  def restore(memento)    @text = memento.state  endend</code></pre><p><strong>Step 3: Implement the Caretaker</strong></p><pre><code class="ruby">class Caretaker  def initialize    @mementos = []  end  def add_memento(memento)    @mementos &lt;&lt; memento  end  def get_memento    @mementos.pop  endend</code></pre><p><strong>Step 4: Implement Client Code</strong></p><pre><code class="ruby">editor = TextEditor.newcaretaker = Caretaker.neweditor.write(&#39;Hello&#39;)caretaker.add_memento(editor.create_memento)editor.write(&#39; World&#39;)puts editor.text # Output: Hello Worldeditor.restore(caretaker.get_memento)puts editor.text # Output: Hello</code></pre><p><em>Benefits</em>: Captures and restores an object’s state without violating encapsulation, promoting flexibility and scalability.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Implementing Undo and Redo</strong></p><p>Imagine you need to implement undo and redo functionality. Using the Memento pattern, you can easily capture and restore the state of the object without exposing its internals.</p><p><strong>Without Memento Pattern:</strong></p><pre><code class="ruby">class TextEditor  attr_accessor :text  def initialize    @text = &#39;&#39;    @history = []    @redo_stack = []  end  def write(text)    @history &lt;&lt; @text    @text += text  end  def undo    @redo_stack &lt;&lt; @text    @text = @history.pop  end  def redo    @history &lt;&lt; @text    @text = @redo_stack.pop  endendeditor = TextEditor.neweditor.write(&#39;Hello&#39;)editor.write(&#39; World&#39;)puts editor.text # Output: Hello Worldeditor.undoputs editor.text # Output: Helloeditor.redoputs editor.text # Output: Hello World</code></pre><p><em>Drawbacks</em>: Tightly coupled code that is difficult to maintain and extend.</p><p><strong>With Memento Pattern:</strong></p><pre><code class="ruby">class Memento  attr_reader :state  def initialize(state)    @state = state  endendclass TextEditor  attr_accessor :text  def initialize    @text = &#39;&#39;  end  def write(text)    @text += text  end  def create_memento    Memento.new(@text.dup)  end  def restore(memento)    @text = memento.state  endendclass Caretaker  def initialize    @undo_stack = []    @redo_stack = []  end  def add_memento(memento)    @undo_stack &lt;&lt; memento    @redo_stack.clear  end  def undo    @redo_stack &lt;&lt; @undo_stack.pop  end  def redo    @undo_stack &lt;&lt; @redo_stack.pop  endendeditor = TextEditor.newcaretaker = Caretaker.neweditor.write(&#39;Hello&#39;)caretaker.add_memento(editor.create_memento)editor.write(&#39; World&#39;)caretaker.add_memento(editor.create_memento)puts editor.text # Output: Hello Worldcaretaker.undoeditor.restore(caretaker.undo)puts editor.text # Output: Hellocaretaker.redoeditor.restore(caretaker.redo)puts editor.text # Output: Hello World</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and extensibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Memento pattern is a powerful tool for capturing and restoring an object’s internal state without violating encapsulation. It promotes flexibility, scalability, and maintainability in your code. By using the Memento pattern, you can easily implement undo and redo functionality without tightly coupling the code. Incorporate the Memento pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns. </p><p>Thôi Lo Code Đi Kẻo Sếp nạt!!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/02/12/deep_dive_memento_pattern/memento_pattern.png&quot; class=&quot;&quot; title=&quot;memento_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;Dee</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software-Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design-Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Software-Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Memento-Pattern" scheme="https://dohungthinhsts.github.io/tags/Memento-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Behavioral Patterns - The Mediator Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/02/10/deep_dive_mediator_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/02/10/deep_dive_mediator_pattern/</id>
    <published>2024-02-10T05:00:00.000Z</published>
    <updated>2024-07-05T07:36:23.867Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/02/10/deep_dive_mediator_pattern/mediator_pattern.png" class="" title="mediator_pattern"></center><br><h2 id="Deep-Dive-into-Behavioral-Patterns-The-Mediator-Pattern"><a href="#Deep-Dive-into-Behavioral-Patterns-The-Mediator-Pattern" class="headerlink" title="Deep Dive into Behavioral Patterns - The Mediator Pattern."></a>Deep Dive into Behavioral Patterns - The Mediator Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Mediator pattern. This pattern is essential for reducing the complexity of communication between multiple objects or classes. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Mediator-Pattern"><a href="#What-is-the-Mediator-Pattern" class="headerlink" title="What is the Mediator Pattern?"></a>What is the Mediator Pattern?</h3><p>The Mediator pattern is a behavioral design pattern that defines an object that encapsulates how a set of objects interact. This pattern promotes loose coupling by keeping objects from referring to each other explicitly and allows their interaction to be varied independently.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a chat application where users can send messages to each other. Each user can send and receive messages without knowing the details of how the messages are delivered.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When multiple objects need to communicate with each other, direct communication can lead to a tightly coupled and hard-to-maintain system. Adding or modifying communication paths can be difficult without changing existing code.</p><h4 id="Without-Mediator-Pattern"><a href="#Without-Mediator-Pattern" class="headerlink" title="Without Mediator Pattern"></a>Without Mediator Pattern</h4><pre><code class="ruby">class User  attr_reader :name  def initialize(name)    @name = name    @contacts = []  end  def add_contact(contact)    @contacts &lt;&lt; contact  end  def send_message(message, recipient)    recipient.receive_message(message, self)  end  def receive_message(message, sender)    puts &quot;#&#123;sender.name&#125; to #&#123;name&#125;: #&#123;message&#125;&quot;  endendalice = User.new(&#39;Alice&#39;)bob = User.new(&#39;Bob&#39;)alice.add_contact(bob)bob.add_contact(alice)alice.send_message(&#39;Hello, Bob!&#39;, bob)</code></pre><p><em>Drawbacks</em>: The code is tightly coupled and difficult to extend to support new communication paths.</p><h3 id="The-Solution-Mediator-Pattern"><a href="#The-Solution-Mediator-Pattern" class="headerlink" title="The Solution: Mediator Pattern"></a>The Solution: Mediator Pattern</h3><p>Using the Mediator pattern, we can centralize the communication logic, making the system easier to maintain and extend.</p><h4 id="With-Mediator-Pattern"><a href="#With-Mediator-Pattern" class="headerlink" title="With Mediator Pattern"></a>With Mediator Pattern</h4><p><strong>Step 1: Define the Mediator Interface</strong></p><pre><code class="ruby">class ChatMediator  def send_message(message, sender, recipient)    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 2: Create Concrete Mediator</strong></p><pre><code class="ruby">class ConcreteChatMediator &lt; ChatMediator  def send_message(message, sender, recipient)    recipient.receive_message(message, sender)  endend</code></pre><p><strong>Step 3: Modify the Colleagues to Use the Mediator</strong></p><pre><code class="ruby">class User  attr_reader :name  def initialize(name, mediator)    @name = name    @mediator = mediator  end  def send_message(message, recipient)    @mediator.send_message(message, self, recipient)  end  def receive_message(message, sender)    puts &quot;#&#123;sender.name&#125; to #&#123;name&#125;: #&#123;message&#125;&quot;  endendmediator = ConcreteChatMediator.newalice = User.new(&#39;Alice&#39;, mediator)bob = User.new(&#39;Bob&#39;, mediator)alice.send_message(&#39;Hello, Bob!&#39;, bob)</code></pre><p><em>Benefits</em>: Centralizes the communication logic, promoting loose coupling and making the system easier to maintain and extend.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Adding New Communication Features</strong></p><p>Imagine you need to add new communication features (e.g., group messages). Using the Mediator pattern, you can easily extend the communication logic without modifying the existing code.</p><p><strong>Without Mediator Pattern:</strong></p><pre><code class="ruby">class User  def send_group_message(message, recipients)    recipients.each &#123; |recipient| send_message(message, recipient) &#125;  endendalice.send_group_message(&#39;Hello, everyone!&#39;, [bob, charlie])</code></pre><p><em>Drawbacks</em>: Tightly coupled code that is difficult to maintain and extend.</p><p><strong>With Mediator Pattern:</strong></p><pre><code class="ruby">class ConcreteChatMediator &lt; ChatMediator  def send_group_message(message, sender, recipients)    recipients.each &#123; |recipient| send_message(message, sender, recipient) &#125;  endendmediator.send_group_message(&#39;Hello, everyone!&#39;, alice, [bob, charlie])</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and extensibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Mediator pattern is a powerful tool for reducing the complexity of communication between multiple objects or classes. It promotes loose coupling, scalability, and maintainability in your code. By using the Mediator pattern, you can easily manage and extend the communication logic in your system without tightly coupling the code. Incorporate the Mediator pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns. </p><p>Thôi Lo Code Đi Kẻo Sếp nạt!!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/02/10/deep_dive_mediator_pattern/mediator_pattern.png&quot; class=&quot;&quot; title=&quot;mediator_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software-Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design-Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Software-Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Mediator-Pattern" scheme="https://dohungthinhsts.github.io/tags/Mediator-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Behavioral Patterns - The Iterator Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/02/08/deep_dive_iterator_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/02/08/deep_dive_iterator_pattern/</id>
    <published>2024-02-08T05:00:00.000Z</published>
    <updated>2024-07-05T07:36:23.867Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/02/08/deep_dive_iterator_pattern/iterator_pattern.png" class="" title="iterator_pattern"></center><br><h2 id="Deep-Dive-into-Behavioral-Patterns-The-Iterator-Pattern"><a href="#Deep-Dive-into-Behavioral-Patterns-The-Iterator-Pattern" class="headerlink" title="Deep Dive into Behavioral Patterns - The Iterator Pattern."></a>Deep Dive into Behavioral Patterns - The Iterator Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Iterator pattern. This pattern is essential for providing a way to access the elements of an aggregate object sequentially without exposing its underlying representation. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Iterator-Pattern"><a href="#What-is-the-Iterator-Pattern" class="headerlink" title="What is the Iterator Pattern?"></a>What is the Iterator Pattern?</h3><p>The Iterator pattern is a behavioral design pattern that provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation. It decouples the traversal of a collection from the collection itself, allowing you to implement different traversal algorithms independently of the collection.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a library management system that needs to iterate over a collection of books. Each book can be accessed and processed without exposing the internal structure of the collection.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When dealing with collections, directly accessing the elements can lead to a tightly coupled and inflexible codebase. This approach makes it difficult to change the collection’s implementation without modifying the traversal code.</p><h4 id="Without-Iterator-Pattern"><a href="#Without-Iterator-Pattern" class="headerlink" title="Without Iterator Pattern"></a>Without Iterator Pattern</h4><pre><code class="ruby">class Book  attr_reader :title  def initialize(title)    @title = title  endendclass Library  def initialize    @books = []  end  def add_book(book)    @books &lt;&lt; book  end  def get_books    @books  endendlibrary = Library.newlibrary.add_book(Book.new(&#39;The Catcher in the Rye&#39;))library.add_book(Book.new(&#39;To Kill a Mockingbird&#39;))library.get_books.each do |book|  puts book.titleend</code></pre><p><em>Drawbacks</em>: The code is tightly coupled to the specific implementation of the collection.</p><h3 id="The-Solution-Iterator-Pattern"><a href="#The-Solution-Iterator-Pattern" class="headerlink" title="The Solution: Iterator Pattern"></a>The Solution: Iterator Pattern</h3><p>Using the Iterator pattern, we can decouple the traversal of the collection from the collection itself, promoting flexibility and scalability.</p><h4 id="With-Iterator-Pattern"><a href="#With-Iterator-Pattern" class="headerlink" title="With Iterator Pattern"></a>With Iterator Pattern</h4><p><strong>Step 1: Define the Iterator Interface</strong></p><pre><code class="ruby">class Iterator  def has_next?    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  end  def next    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 2: Create Concrete Iterators</strong></p><pre><code class="ruby">class BookIterator &lt; Iterator  def initialize(books)    @books = books    @index = 0  end  def has_next?    @index &lt; @books.length  end  def next    book = @books[@index]    @index += 1    book  endend</code></pre><p><strong>Step 3: Define the Aggregate Interface</strong></p><pre><code class="ruby">class Aggregate  def create_iterator    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 4: Create Concrete Aggregates</strong></p><pre><code class="ruby">class Library &lt; Aggregate  def initialize    @books = []  end  def add_book(book)    @books &lt;&lt; book  end  def create_iterator    BookIterator.new(@books)  endend</code></pre><p><strong>Step 5: Implement Client Code</strong></p><pre><code class="ruby">library = Library.newlibrary.add_book(Book.new(&#39;The Catcher in the Rye&#39;))library.add_book(Book.new(&#39;To Kill a Mockingbird&#39;))iterator = library.create_iteratorwhile iterator.has_next?  book = iterator.next  puts book.titleend</code></pre><p><em>Benefits</em>: Decouples the traversal of a collection from the collection itself, promoting flexibility and scalability.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Changing the Collection Implementation</strong></p><p>Imagine you need to change the implementation of the collection (e.g., using a different data structure). Using the Iterator pattern, you can easily change the collection’s implementation without modifying the traversal code.</p><p><strong>Without Iterator Pattern:</strong></p><pre><code class="ruby">class Library  def initialize    @books = &#123;&#125;    @index = 0  end  def add_book(book)    @books[@index] = book    @index += 1  end  def get_books    @books.values  endendlibrary = Library.newlibrary.add_book(Book.new(&#39;The Catcher in the Rye&#39;))library.add_book(Book.new(&#39;To Kill a Mockingbird&#39;))library.get_books.each do |book|  puts book.titleend</code></pre><p><em>Drawbacks</em>: Tightly coupled code that is difficult to maintain and extend.</p><p><strong>With Iterator Pattern:</strong></p><pre><code class="ruby">class Library &lt; Aggregate  def initialize    @books = &#123;&#125;    @index = 0  end  def add_book(book)    @books[@index] = book    @index += 1  end  def create_iterator    BookIterator.new(@books.values)  endendlibrary = Library.newlibrary.add_book(Book.new(&#39;The Catcher in the Rye&#39;))library.add_book(Book.new(&#39;To Kill a Mockingbird&#39;))iterator = library.create_iteratorwhile iterator.has_next?  book = iterator.next  puts book.titleend</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and extensibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Iterator pattern is a powerful tool for providing a way to access the elements of an aggregate object sequentially without exposing its underlying representation. It promotes flexibility, scalability, and maintainability in your code. By using the Iterator pattern, you can easily manage the traversal of collections without tightly coupling the code. Incorporate the Iterator pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns. </p><p>Thôi Lo Code Đi Kẻo Sếp nạt!!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/02/08/deep_dive_iterator_pattern/iterator_pattern.png&quot; class=&quot;&quot; title=&quot;iterator_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software-Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design-Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Software-Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Iterator-Pattern" scheme="https://dohungthinhsts.github.io/tags/Iterator-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Behavioral Patterns - The Interpreter Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/02/05/deep_dive_interpreter_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/02/05/deep_dive_interpreter_pattern/</id>
    <published>2024-02-05T05:00:00.000Z</published>
    <updated>2024-07-05T07:36:23.867Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/02/05/deep_dive_interpreter_pattern/interpreter_pattern.png" class="" title="interpreter_pattern"></center><br><h2 id="Deep-Dive-into-Behavioral-Patterns-The-Interpreter-Pattern"><a href="#Deep-Dive-into-Behavioral-Patterns-The-Interpreter-Pattern" class="headerlink" title="Deep Dive into Behavioral Patterns - The Interpreter Pattern."></a>Deep Dive into Behavioral Patterns - The Interpreter Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Interpreter pattern. This pattern is essential for defining a grammatical representation for a language and providing an interpreter to deal with this grammar. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Interpreter-Pattern"><a href="#What-is-the-Interpreter-Pattern" class="headerlink" title="What is the Interpreter Pattern?"></a>What is the Interpreter Pattern?</h3><p>The Interpreter pattern is a behavioral design pattern that defines a grammatical representation for a language and provides an interpreter to deal with this grammar. It is useful for implementing specialized languages or for parsing expressions in a language.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a calculator that can evaluate mathematical expressions. Each expression needs to be parsed and evaluated based on its grammar.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When dealing with complex expressions or languages, directly interpreting the expressions can lead to a tightly coupled and inflexible codebase. This approach makes it difficult to add or modify the grammar without changing the existing code.</p><h4 id="Without-Interpreter-Pattern"><a href="#Without-Interpreter-Pattern" class="headerlink" title="Without Interpreter Pattern"></a>Without Interpreter Pattern</h4><pre><code class="ruby">class Calculator  def evaluate(expression)    # Evaluate the expression directly    eval(expression)  endendcalculator = Calculator.newputs calculator.evaluate(&#39;3 + 5&#39;) # Output: 8puts calculator.evaluate(&#39;10 / 2&#39;) # Output: 5</code></pre><p><em>Drawbacks</em>: The code is tightly coupled to specific implementations and hard to extend to support new grammar rules.</p><h3 id="The-Solution-Interpreter-Pattern"><a href="#The-Solution-Interpreter-Pattern" class="headerlink" title="The Solution: Interpreter Pattern"></a>The Solution: Interpreter Pattern</h3><p>Using the Interpreter pattern, we can define a grammar for the expressions and provide an interpreter to evaluate them, promoting flexibility and scalability.</p><h4 id="With-Interpreter-Pattern"><a href="#With-Interpreter-Pattern" class="headerlink" title="With Interpreter Pattern"></a>With Interpreter Pattern</h4><p><strong>Step 1: Define the Abstract Expression</strong></p><pre><code class="ruby">class Expression  def interpret    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 2: Create Terminal and Non-Terminal Expressions</strong></p><pre><code class="ruby">class Number &lt; Expression  def initialize(value)    @value = value  end  def interpret    @value  endendclass Add &lt; Expression  def initialize(left, right)    @left = left    @right = right  end  def interpret    @left.interpret + @right.interpret  endendclass Subtract &lt; Expression  def initialize(left, right)    @left = left    @right = right  end  def interpret    @left.interpret - @right.interpret  endend</code></pre><p><strong>Step 3: Implement Client Code</strong></p><pre><code class="ruby">expression = Add.new(Number.new(3), Number.new(5))puts expression.interpret # Output: 8expression = Subtract.new(Number.new(10), Number.new(2))puts expression.interpret # Output: 8</code></pre><p><em>Benefits</em>: Defines a grammatical representation for a language and provides an interpreter to evaluate expressions, promoting flexibility and scalability.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Adding New Grammar Rules</strong></p><p>Imagine you need to add a new grammar rule (e.g., multiplication). Using the Interpreter pattern, you can easily introduce a new terminal or non-terminal expression without modifying the existing code.</p><p><strong>Without Interpreter Pattern:</strong></p><pre><code class="ruby">class Calculator  def evaluate(expression)    # Evaluate the expression directly    eval(expression)  endendputs calculator.evaluate(&#39;3 * 5&#39;) # Output: 15</code></pre><p><em>Drawbacks</em>: Tightly coupled code that is difficult to maintain and extend.</p><p><strong>With Interpreter Pattern:</strong></p><pre><code class="ruby">class Multiply &lt; Expression  def initialize(left, right)    @left = left    @right = right  end  def interpret    @left.interpret * @right.interpret  endendexpression = Multiply.new(Number.new(3), Number.new(5))puts expression.interpret # Output: 15</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and extensibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Interpreter pattern is a powerful tool for defining a grammatical representation for a language and providing an interpreter to evaluate expressions. It promotes flexibility, scalability, and maintainability in your code. By using the Interpreter pattern, you can easily manage and extend the grammar of a language without tightly coupling the code. Incorporate the Interpreter pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns. </p><p>Thôi Lo Code Đi Kẻo Sếp nạt!!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/02/05/deep_dive_interpreter_pattern/interpreter_pattern.png&quot; class=&quot;&quot; title=&quot;interpreter_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;
</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software-Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design-Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Software-Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Interpreter-Pattern" scheme="https://dohungthinhsts.github.io/tags/Interpreter-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Behavioral Patterns - The Command Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/02/03/deep_dive_command_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/02/03/deep_dive_command_pattern/</id>
    <published>2024-02-03T05:00:00.000Z</published>
    <updated>2024-07-05T07:36:23.867Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/02/03/deep_dive_command_pattern/command_pattern.png" class="" title="command_pattern"></center><br><h2 id="Deep-Dive-into-Behavioral-Patterns-The-Command-Pattern"><a href="#Deep-Dive-into-Behavioral-Patterns-The-Command-Pattern" class="headerlink" title="Deep Dive into Behavioral Patterns - The Command Pattern."></a>Deep Dive into Behavioral Patterns - The Command Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Command pattern. This pattern is essential for turning a request into a stand-alone object that contains all information about the request. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Command-Pattern"><a href="#What-is-the-Command-Pattern" class="headerlink" title="What is the Command Pattern?"></a>What is the Command Pattern?</h3><p>The Command pattern is a behavioral design pattern that turns a request into a stand-alone object that contains all information about the request. This transformation lets you parameterize methods with different requests, delay or queue a request’s execution, and support undoable operations.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a text editor that supports operations like copy, paste, and undo. Each operation can be represented as a command object, allowing you to easily implement undo functionality and manage the history of operations.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When managing operations that need to be executed, undone, or queued, hardcoding the logic to handle these operations can lead to a tightly coupled and inflexible codebase. This approach makes it difficult to add or modify operations without changing the existing code.</p><h4 id="Without-Command-Pattern"><a href="#Without-Command-Pattern" class="headerlink" title="Without Command Pattern"></a>Without Command Pattern</h4><pre><code class="ruby">class TextEditor  def initialize    @text = &#39;&#39;  end  def copy(text)    @clipboard = text  end  def paste    @text += @clipboard  end  def undo    # Implementation for undoing the last operation  endendeditor = TextEditor.neweditor.copy(&#39;Hello&#39;)editor.pasteputs editor.text # Output: Hello</code></pre><p><em>Drawbacks</em>: The code is tightly coupled to specific implementations and hard to extend to support new operations.</p><h3 id="The-Solution-Command-Pattern"><a href="#The-Solution-Command-Pattern" class="headerlink" title="The Solution: Command Pattern"></a>The Solution: Command Pattern</h3><p>Using the Command pattern, we can encapsulate each operation as a command object, promoting flexibility and scalability.</p><h4 id="With-Command-Pattern"><a href="#With-Command-Pattern" class="headerlink" title="With Command Pattern"></a>With Command Pattern</h4><p><strong>Step 1: Define the Command Interface</strong></p><pre><code class="ruby">class Command  def execute    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  end  def undo    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 2: Create Concrete Commands</strong></p><pre><code class="ruby">class CopyCommand &lt; Command  def initialize(editor, text)    @editor = editor    @text = text  end  def execute    @editor.copy(@text)  end  def undo    @editor.undo_copy  endendclass PasteCommand &lt; Command  def initialize(editor)    @editor = editor  end  def execute    @editor.paste  end  def undo    @editor.undo_paste  endend</code></pre><p><strong>Step 3: Implement the Receiver</strong></p><pre><code class="ruby">class TextEditor  attr_reader :text  def initialize    @text = &#39;&#39;    @clipboard = &#39;&#39;  end  def copy(text)    @clipboard = text  end  def paste    @text += @clipboard  end  def undo_copy    @clipboard = &#39;&#39;  end  def undo_paste    @text = @text[0...-@clipboard.length]  endend</code></pre><p><strong>Step 4: Implement Client Code</strong></p><pre><code class="ruby">editor = TextEditor.newcopy_command = CopyCommand.new(editor, &#39;Hello&#39;)paste_command = PasteCommand.new(editor)copy_command.executepaste_command.executeputs editor.text # Output: Hellopaste_command.undoputs editor.text # Output: </code></pre><p><em>Benefits</em>: Encapsulates each operation as a command object, promoting flexibility and scalability.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Adding New Operations</strong></p><p>Imagine you need to add a new operation (e.g., Cut). Using the Command pattern, you can easily introduce a new command for the Cut operation without modifying the existing code.</p><p><strong>Without Command Pattern:</strong></p><pre><code class="ruby">class TextEditor  def cut(text)    @clipboard = text    @text = @text.gsub(text, &#39;&#39;)  endendeditor = TextEditor.neweditor.cut(&#39;Hello&#39;)puts editor.text # Output: </code></pre><p><em>Drawbacks</em>: Tightly coupled code that is difficult to maintain and extend.</p><p><strong>With Command Pattern:</strong></p><pre><code class="ruby">class CutCommand &lt; Command  def initialize(editor, text)    @editor = editor    @text = text  end  def execute    @editor.cut(@text)  end  def undo    @editor.undo_cut  endendclass TextEditor  def cut(text)    @clipboard = text    @text = @text.gsub(text, &#39;&#39;)  end  def undo_cut    @text += @clipboard  endendcut_command = CutCommand.new(editor, &#39;Hello&#39;)cut_command.executeputs editor.text # Output: cut_command.undoputs editor.text # Output: Hello</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and extensibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Command pattern is a powerful tool for turning a request into a stand-alone object that contains all information about the request. It promotes flexibility, scalability, and maintainability in your code. By using the Command pattern, you can easily manage operations that need to be executed, undone, or queued. Incorporate the Command pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns. </p><p>Thôi Lo Code Đi Kẻo Sếp nạt!!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/02/03/deep_dive_command_pattern/command_pattern.png&quot; class=&quot;&quot; title=&quot;command_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;Dee</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software-Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design-Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Software-Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Command-Pattern" scheme="https://dohungthinhsts.github.io/tags/Command-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Behavioral Patterns - The Chain of Responsibility Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/02/01/deep_dive_chain_of_responsibility_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/02/01/deep_dive_chain_of_responsibility_pattern/</id>
    <published>2024-02-01T05:00:00.000Z</published>
    <updated>2024-07-05T07:36:23.867Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/02/01/deep_dive_chain_of_responsibility_pattern/chain_of_responsibility_pattern_pattern.png" class="" title="chain_of_responsibility_pattern"></center><br><h2 id="Deep-Dive-into-Behavioral-Patterns-The-Chain-of-Responsibility-Pattern"><a href="#Deep-Dive-into-Behavioral-Patterns-The-Chain-of-Responsibility-Pattern" class="headerlink" title="Deep Dive into Behavioral Patterns - The Chain of Responsibility Pattern."></a>Deep Dive into Behavioral Patterns - The Chain of Responsibility Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Chain of Responsibility pattern. This pattern is essential for creating a chain of processing objects where each object in the chain handles a request or passes it to the next object in the chain. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Chain-of-Responsibility-Pattern"><a href="#What-is-the-Chain-of-Responsibility-Pattern" class="headerlink" title="What is the Chain of Responsibility Pattern?"></a>What is the Chain of Responsibility Pattern?</h3><p>The Chain of Responsibility pattern is a behavioral design pattern that allows an object to pass a request along a chain of potential handlers until the request is handled. It decouples the sender of the request from its receiver by allowing multiple objects to handle the request without the sender knowing which object will handle it.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a help desk ticketing system where different levels of support handle different types of issues. A customer service representative handles basic issues, a technical support representative handles more complex issues, and a manager handles the most critical issues. Each issue needs to be escalated to the appropriate level of support based on its complexity.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When processing requests that can be handled by multiple handlers, hardcoding the logic to determine which handler should process each request can lead to a tightly coupled and inflexible codebase. This approach makes it difficult to add or modify handlers without changing the existing code.</p><h4 id="Without-Chain-of-Responsibility-Pattern"><a href="#Without-Chain-of-Responsibility-Pattern" class="headerlink" title="Without Chain of Responsibility Pattern"></a>Without Chain of Responsibility Pattern</h4><pre><code class="ruby">class HelpDesk  def handle_request(issue)    if issue.type == &#39;basic&#39;      handle_basic_issue(issue)    elsif issue.type == &#39;technical&#39;      handle_technical_issue(issue)    elsif issue.type == &#39;critical&#39;      handle_critical_issue(issue)    else      puts &#39;Unknown issue type&#39;    end  end  def handle_basic_issue(issue)    puts &quot;Handling basic issue: #&#123;issue.description&#125;&quot;  end  def handle_technical_issue(issue)    puts &quot;Handling technical issue: #&#123;issue.description&#125;&quot;  end  def handle_critical_issue(issue)    puts &quot;Handling critical issue: #&#123;issue.description&#125;&quot;  endendissue1 = OpenStruct.new(type: &#39;basic&#39;, description: &#39;Password reset&#39;)issue2 = OpenStruct.new(type: &#39;technical&#39;, description: &#39;Software installation&#39;)issue3 = OpenStruct.new(type: &#39;critical&#39;, description: &#39;System outage&#39;)help_desk = HelpDesk.newhelp_desk.handle_request(issue1)help_desk.handle_request(issue2)help_desk.handle_request(issue3)</code></pre><p><em>Drawbacks</em>: The code is tightly coupled to specific implementations and hard to extend to support new issue types.</p><h3 id="The-Solution-Chain-of-Responsibility-Pattern"><a href="#The-Solution-Chain-of-Responsibility-Pattern" class="headerlink" title="The Solution: Chain of Responsibility Pattern"></a>The Solution: Chain of Responsibility Pattern</h3><p>Using the Chain of Responsibility pattern, we can create a chain of handlers that process the request or pass it to the next handler in the chain, promoting flexibility and scalability.</p><h4 id="With-Chain-of-Responsibility-Pattern"><a href="#With-Chain-of-Responsibility-Pattern" class="headerlink" title="With Chain of Responsibility Pattern"></a>With Chain of Responsibility Pattern</h4><p><strong>Step 1: Define the Handler Interface</strong></p><pre><code class="ruby">class Handler  def initialize(successor = nil)    @successor = successor  end  def handle_request(issue)    if @successor      @successor.handle_request(issue)    else      puts &#39;Request not handled&#39;    end  endend</code></pre><p><strong>Step 2: Create Concrete Handlers</strong></p><pre><code class="ruby">class CustomerServiceHandler &lt; Handler  def handle_request(issue)    if issue.type == &#39;basic&#39;      puts &quot;Handling basic issue: #&#123;issue.description&#125;&quot;    else      super(issue)    end  endendclass TechnicalSupportHandler &lt; Handler  def handle_request(issue)    if issue.type == &#39;technical&#39;      puts &quot;Handling technical issue: #&#123;issue.description&#125;&quot;    else      super(issue)    end  endendclass ManagerHandler &lt; Handler  def handle_request(issue)    if issue.type == &#39;critical&#39;      puts &quot;Handling critical issue: #&#123;issue.description&#125;&quot;    else      super(issue)    end  endend</code></pre><p><strong>Step 3: Implement Client Code</strong></p><pre><code class="ruby">manager = ManagerHandler.newtechnical_support = TechnicalSupportHandler.new(manager)customer_service = CustomerServiceHandler.new(technical_support)issue1 = OpenStruct.new(type: &#39;basic&#39;, description: &#39;Password reset&#39;)issue2 = OpenStruct.new(type: &#39;technical&#39;, description: &#39;Software installation&#39;)issue3 = OpenStruct.new(type: &#39;critical&#39;, description: &#39;System outage&#39;)customer_service.handle_request(issue1)customer_service.handle_request(issue2)customer_service.handle_request(issue3)</code></pre><p><em>Benefits</em>: Decouples the sender of the request from its receiver, promoting flexibility and scalability.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Adding New Issue Types</strong></p><p>Imagine you need to add a new issue type (e.g., ‘billing’). Using the Chain of Responsibility pattern, you can easily introduce a new handler for billing issues without modifying the existing code.</p><p><strong>Without Chain of Responsibility Pattern:</strong></p><pre><code class="ruby">class HelpDesk  def handle_request(issue)    if issue.type == &#39;basic&#39;      handle_basic_issue(issue)    elsif issue.type == &#39;technical&#39;      handle_technical_issue(issue)    elsif issue.type == &#39;critical&#39;      handle_critical_issue(issue)    elsif issue.type == &#39;billing&#39;      handle_billing_issue(issue)    else      puts &#39;Unknown issue type&#39;    end  end  def handle_basic_issue(issue)    puts &quot;Handling basic issue: #&#123;issue.description&#125;&quot;  end  def handle_technical_issue(issue)    puts &quot;Handling technical issue: #&#123;issue.description&#125;&quot;  end  def handle_critical_issue(issue)    puts &quot;Handling critical issue: #&#123;issue.description&#125;&quot;  end  def handle_billing_issue(issue)    puts &quot;Handling billing issue: #&#123;issue.description&#125;&quot;  endend</code></pre><p><em>Drawbacks</em>: Tightly coupled code that is difficult to maintain and extend.</p><p><strong>With Chain of Responsibility Pattern:</strong></p><pre><code class="ruby">class BillingHandler &lt; Handler  def handle_request(issue)    if issue.type == &#39;billing&#39;      puts &quot;Handling billing issue: #&#123;issue.description&#125;&quot;    else      super(issue)    end  endendbilling = BillingHandler.new(manager)technical_support = TechnicalSupportHandler.new(billing)customer_service = CustomerServiceHandler.new(technical_support)issue4 = OpenStruct.new(type: &#39;billing&#39;, description: &#39;Invoice discrepancy&#39;)customer_service.handle_request(issue4)</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and extensibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Chain of Responsibility pattern is a powerful tool for creating a chain of processing objects where each object in the chain handles a request or passes it to the next object in the chain. It promotes flexibility, scalability, and maintainability in your code. By using the Chain of Responsibility pattern, you can easily manage requests that can be handled by multiple handlers without tightly coupling the sender to the receivers. Incorporate the Chain of Responsibility pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns.</p><p>Thôi Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/02/01/deep_dive_chain_of_responsibility_pattern/chain_of_responsibility_pattern_pattern.png&quot; class=&quot;&quot; title=&quot;chain_</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software-Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design-Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Software-Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Chain-of-Responsibility Pattern" scheme="https://dohungthinhsts.github.io/tags/Chain-of-Responsibility-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Structural Patterns - The Proxy Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/01/30/deep_dive_proxy_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/01/30/deep_dive_proxy_pattern/</id>
    <published>2024-01-30T05:00:00.000Z</published>
    <updated>2024-07-05T07:36:23.867Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/30/deep_dive_proxy_pattern/proxy_pattern.png" class="" title="proxy_pattern"></center><br><h2 id="Deep-Dive-into-Structural-Patterns-The-Proxy-Pattern"><a href="#Deep-Dive-into-Structural-Patterns-The-Proxy-Pattern" class="headerlink" title="Deep Dive into Structural Patterns - The Proxy Pattern."></a>Deep Dive into Structural Patterns - The Proxy Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Proxy pattern. This pattern provides a surrogate or placeholder for another object to control access to it. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Proxy-Pattern"><a href="#What-is-the-Proxy-Pattern" class="headerlink" title="What is the Proxy Pattern?"></a>What is the Proxy Pattern?</h3><p>The Proxy pattern is a structural design pattern that provides a surrogate or placeholder for another object to control access to it. It acts as an intermediary that can add functionality before or after delegating the request to the real object.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing an image viewer application that loads high-resolution images. Loading these images can be time-consuming, and you want to display a placeholder image while the high-resolution image is being loaded in the background.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When dealing with resource-intensive objects, directly accessing these objects can lead to performance issues and unnecessary resource consumption. Hardcoding the logic to manage these objects can result in a tightly coupled and inefficient codebase.</p><h4 id="Without-Proxy-Pattern"><a href="#Without-Proxy-Pattern" class="headerlink" title="Without Proxy Pattern"></a>Without Proxy Pattern</h4><pre><code class="ruby">class HighResolutionImage  def initialize(filename)    @filename = filename    load_image  end  def load_image    puts &quot;Loading high-resolution image: #&#123;@filename&#125;&quot;    # Simulate a time-consuming loading process    sleep(2)    puts &quot;Image loaded: #&#123;@filename&#125;&quot;  end  def display    puts &quot;Displaying image: #&#123;@filename&#125;&quot;  endendimage = HighResolutionImage.new(&#39;large_image.jpg&#39;)image.display</code></pre><p><em>Drawbacks</em>: The image is loaded immediately, leading to a delay before it can be displayed.</p><h3 id="The-Solution-Proxy-Pattern"><a href="#The-Solution-Proxy-Pattern" class="headerlink" title="The Solution: Proxy Pattern"></a>The Solution: Proxy Pattern</h3><p>Using the Proxy pattern, we can control access to the high-resolution image and display a placeholder image while the real image is being loaded in the background.</p><h4 id="With-Proxy-Pattern"><a href="#With-Proxy-Pattern" class="headerlink" title="With Proxy Pattern"></a>With Proxy Pattern</h4><p><strong>Step 1: Define the Subject Interface</strong></p><pre><code class="ruby">class Image  def display    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 2: Create the Real Subject</strong></p><pre><code class="ruby">class HighResolutionImage &lt; Image  def initialize(filename)    @filename = filename    load_image  end  def load_image    puts &quot;Loading high-resolution image: #&#123;@filename&#125;&quot;    # Simulate a time-consuming loading process    sleep(2)    puts &quot;Image loaded: #&#123;@filename&#125;&quot;  end  def display    puts &quot;Displaying image: #&#123;@filename&#125;&quot;  endend</code></pre><p><strong>Step 3: Create the Proxy</strong></p><pre><code class="ruby">class ImageProxy &lt; Image  def initialize(filename)    @filename = filename    @real_image = nil  end  def display    if @real_image.nil?      puts &quot;Displaying placeholder image&quot;      @real_image = HighResolutionImage.new(@filename)    end    @real_image.display  endend</code></pre><p><strong>Step 4: Implement Client Code</strong></p><pre><code class="ruby">image = ImageProxy.new(&#39;large_image.jpg&#39;)image.display</code></pre><p><em>Benefits</em>: Controls access to the high-resolution image, displaying a placeholder image while the real image is being loaded.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Managing Access to Resource-Intensive Objects</strong></p><p>Imagine you need to manage access to resource-intensive objects in a large-scale application. Using the Proxy pattern, you can control access to these objects and add functionality before or after delegating the request to the real object.</p><p><strong>Without Proxy Pattern:</strong></p><pre><code class="ruby">class DatabaseConnection  def connect    puts &#39;Establishing database connection...&#39;    # Simulate a time-consuming connection process    sleep(2)    puts &#39;Database connection established.&#39;  end  def execute_query(query)    puts &quot;Executing query: #&#123;query&#125;&quot;  endendconnection = DatabaseConnection.newconnection.connectconnection.execute_query(&#39;SELECT * FROM users&#39;)</code></pre><p><em>Drawbacks</em>: The connection is established immediately, leading to a delay before the query can be executed.</p><p><strong>With Proxy Pattern:</strong></p><pre><code class="ruby">class DatabaseConnectionProxy  def initialize    @real_connection = nil  end  def connect    if @real_connection.nil?      puts &#39;Displaying placeholder message&#39;      @real_connection = DatabaseConnection.new      @real_connection.connect    end  end  def execute_query(query)    connect    @real_connection.execute_query(query)  endendconnection = DatabaseConnectionProxy.newconnection.execute_query(&#39;SELECT * FROM users&#39;)</code></pre><p><em>Benefits</em>: Controls access to the database connection, displaying a placeholder message while the connection is being established.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Proxy pattern is a powerful tool for controlling access to objects and adding functionality before or after delegating the request to the real object. It promotes efficiency, scalability, and maintainability in your code. By using the Proxy pattern, you can manage access to resource-intensive objects and improve the performance of your application. Incorporate the Proxy pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns.</p><p>Thôi Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/30/deep_dive_proxy_pattern/proxy_pattern.png&quot; class=&quot;&quot; title=&quot;proxy_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;Deep-Dive</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software-Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design-Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Software-Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Proxy-Pattern" scheme="https://dohungthinhsts.github.io/tags/Proxy-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Structural Patterns - The Flyweight Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/01/28/deep_dive_flyweight_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/01/28/deep_dive_flyweight_pattern/</id>
    <published>2024-01-28T05:00:00.000Z</published>
    <updated>2024-07-05T07:36:23.867Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/28/deep_dive_flyweight_pattern/flyweight_pattern.png" class="" title="flyweight_pattern"></center><br><h2 id="Deep-Dive-into-Structural-Patterns-The-Flyweight-Pattern"><a href="#Deep-Dive-into-Structural-Patterns-The-Flyweight-Pattern" class="headerlink" title="Deep Dive into Structural Patterns - The Flyweight Pattern."></a>Deep Dive into Structural Patterns - The Flyweight Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Flyweight pattern. This pattern helps you efficiently support a large number of fine-grained objects by sharing as much data as possible. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Flyweight-Pattern"><a href="#What-is-the-Flyweight-Pattern" class="headerlink" title="What is the Flyweight Pattern?"></a>What is the Flyweight Pattern?</h3><p>The Flyweight pattern is a structural design pattern that allows you to minimize memory usage by sharing as much data as possible with similar objects. It is particularly useful when you need to create a large number of similar objects that would otherwise consume a significant amount of memory.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a graphical application that needs to render a large number of characters on the screen. Each character has its own properties (e.g., font, size, color), and creating an individual object for each character can lead to high memory consumption.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When creating a large number of fine-grained objects, each with its own state, memory consumption can become a significant issue. Hardcoding the logic to handle these objects can result in a tightly coupled and inefficient codebase.</p><h4 id="Without-Flyweight-Pattern"><a href="#Without-Flyweight-Pattern" class="headerlink" title="Without Flyweight Pattern"></a>Without Flyweight Pattern</h4><pre><code class="ruby">class Character  def initialize(char, font, size, color)    @char = char    @font = font    @size = size    @color = color  end  def display    puts &quot;Displaying #&#123;@char&#125; in #&#123;@font&#125; font, size #&#123;@size&#125;, color #&#123;@color&#125;&quot;  endendcharacters = [](&#39;a&#39;..&#39;z&#39;).each do |char|  characters &lt;&lt; Character.new(char, &#39;Arial&#39;, 12, &#39;black&#39;)endcharacters.each(&amp;:display)</code></pre><p><em>Drawbacks</em>: Each character object consumes memory for storing its properties, leading to high memory consumption.</p><h3 id="The-Solution-Flyweight-Pattern"><a href="#The-Solution-Flyweight-Pattern" class="headerlink" title="The Solution: Flyweight Pattern"></a>The Solution: Flyweight Pattern</h3><p>Using the Flyweight pattern, we can share the common properties of similar objects, reducing memory consumption and improving efficiency.</p><h4 id="With-Flyweight-Pattern"><a href="#With-Flyweight-Pattern" class="headerlink" title="With Flyweight Pattern"></a>With Flyweight Pattern</h4><p><strong>Step 1: Define the Flyweight</strong></p><pre><code class="ruby">class CharacterFlyweight  def initialize(char)    @char = char  end  def display(font, size, color)    puts &quot;Displaying #&#123;@char&#125; in #&#123;font&#125; font, size #&#123;size&#125;, color #&#123;color&#125;&quot;  endend</code></pre><p><strong>Step 2: Create the Flyweight Factory</strong></p><pre><code class="ruby">class FlyweightFactory  def initialize    @flyweights = &#123;&#125;  end  def get_flyweight(char)    @flyweights[char] ||= CharacterFlyweight.new(char)  endend</code></pre><p><strong>Step 3: Implement Client Code</strong></p><pre><code class="ruby">factory = FlyweightFactory.newcharacters = [](&#39;a&#39;..&#39;z&#39;).each do |char|  characters &lt;&lt; factory.get_flyweight(char)endcharacters.each do |char|  char.display(&#39;Arial&#39;, 12, &#39;black&#39;)end</code></pre><p><em>Benefits</em>: Shares the common properties of similar objects, reducing memory consumption and improving efficiency.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Rendering Characters in a Graphical Application</strong></p><p>Imagine you need to render a large number of characters on the screen with various properties. Using the Flyweight pattern, you can minimize memory usage by sharing the common properties of similar characters.</p><p><strong>Without Flyweight Pattern:</strong></p><pre><code class="ruby">class Character  def initialize(char, font, size, color)    @char = char    @font = font    @size = size    @color = color  end  def display    puts &quot;Displaying #&#123;@char&#125; in #&#123;@font&#125; font, size #&#123;@size&#125;, color #&#123;@color&#125;&quot;  endendcharacters = [](&#39;a&#39;..&#39;z&#39;).each do |char|  characters &lt;&lt; Character.new(char, &#39;Arial&#39;, 12, &#39;black&#39;)endcharacters.each(&amp;:display)</code></pre><p><em>Drawbacks</em>: High memory consumption due to each character object storing its own properties.</p><p><strong>With Flyweight Pattern:</strong></p><pre><code class="ruby">class CharacterFlyweight  def initialize(char)    @char = char  end  def display(font, size, color)    puts &quot;Displaying #&#123;@char&#125; in #&#123;font&#125; font, size #&#123;size&#125;, color #&#123;color&#125;&quot;  endendclass FlyweightFactory  def initialize    @flyweights = &#123;&#125;  end  def get_flyweight(char)    @flyweights[char] ||= CharacterFlyweight.new(char)  endendfactory = FlyweightFactory.newcharacters = [](&#39;a&#39;..&#39;z&#39;).each do |char|  characters &lt;&lt; factory.get_flyweight(char)endcharacters.each do |char|  char.display(&#39;Arial&#39;, 12, &#39;black&#39;)end</code></pre><p><em>Benefits</em>: Minimizes memory usage by sharing the common properties of similar objects.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Flyweight pattern is a powerful tool for minimizing memory usage by sharing as much data as possible with similar objects. It promotes efficiency and scalability in your code. By using the Flyweight pattern, you can support a large number of fine-grained objects without consuming excessive memory. Incorporate the Flyweight pattern into your design strategies to build more efficient and scalable software systems.</p><p>Stay tuned for more insights into software design principles and patterns.</p><p>Thôi Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/28/deep_dive_flyweight_pattern/flyweight_pattern.png&quot; class=&quot;&quot; title=&quot;flyweight_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 i</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software-Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design-Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Software-Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Flyweight-Pattern" scheme="https://dohungthinhsts.github.io/tags/Flyweight-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Structural Patterns - The Facade Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/01/26/deep_dive_facade_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/01/26/deep_dive_facade_pattern/</id>
    <published>2024-01-26T05:00:00.000Z</published>
    <updated>2024-07-05T07:36:23.867Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/26/deep_dive_facade_pattern/facade_pattern.png" class="" title="facade_pattern"></center><br><h2 id="Deep-Dive-into-Structural-Patterns-The-Facade-Pattern"><a href="#Deep-Dive-into-Structural-Patterns-The-Facade-Pattern" class="headerlink" title="Deep Dive into Structural Patterns - The Facade Pattern."></a>Deep Dive into Structural Patterns - The Facade Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Facade pattern. This pattern provides a simplified interface to a complex subsystem, making it easier to use. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Facade-Pattern"><a href="#What-is-the-Facade-Pattern" class="headerlink" title="What is the Facade Pattern?"></a>What is the Facade Pattern?</h3><p>The Facade pattern is a structural design pattern that provides a simplified interface to a complex subsystem. It defines a higher-level interface that makes the subsystem easier to use by hiding the complexity behind a simpler API.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a home automation system that controls various devices like lights, thermostats, and security cameras. Each device has its own interface and functionality, making it difficult for users to control them through a single interface.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When dealing with complex subsystems, directly interacting with their interfaces can lead to a complicated and hard-to-maintain codebase. Hardcoding the logic to handle different parts of the subsystem can result in tightly coupled and inflexible code.</p><h4 id="Without-Facade-Pattern"><a href="#Without-Facade-Pattern" class="headerlink" title="Without Facade Pattern"></a>Without Facade Pattern</h4><pre><code class="ruby">class Light  def turn_on    puts &#39;Turning on the light&#39;  end  def turn_off    puts &#39;Turning off the light&#39;  endendclass Thermostat  def set_temperature(temperature)    puts &quot;Setting temperature to #&#123;temperature&#125; degrees&quot;  endendclass SecurityCamera  def activate    puts &#39;Activating security camera&#39;  end  def deactivate    puts &#39;Deactivating security camera&#39;  endendlight = Light.newthermostat = Thermostat.newcamera = SecurityCamera.newlight.turn_onthermostat.set_temperature(22)camera.activate</code></pre><p><em>Drawbacks</em>: The code is tightly coupled to specific implementations and hard to extend to support new devices.</p><h3 id="The-Solution-Facade-Pattern"><a href="#The-Solution-Facade-Pattern" class="headerlink" title="The Solution: Facade Pattern"></a>The Solution: Facade Pattern</h3><p>Using the Facade pattern, we can provide a simplified interface to the complex subsystem, promoting flexibility and scalability.</p><h4 id="With-Facade-Pattern"><a href="#With-Facade-Pattern" class="headerlink" title="With Facade Pattern"></a>With Facade Pattern</h4><p><strong>Step 1: Define the Subsystem Interfaces</strong></p><pre><code class="ruby">class Light  def turn_on    puts &#39;Turning on the light&#39;  end  def turn_off    puts &#39;Turning off the light&#39;  endendclass Thermostat  def set_temperature(temperature)    puts &quot;Setting temperature to #&#123;temperature&#125; degrees&quot;  endendclass SecurityCamera  def activate    puts &#39;Activating security camera&#39;  end  def deactivate    puts &#39;Deactivating security camera&#39;  endend</code></pre><p><strong>Step 2: Create the Facade</strong></p><pre><code class="ruby">class HomeAutomationFacade  def initialize    @light = Light.new    @thermostat = Thermostat.new    @camera = SecurityCamera.new  end  def leave_home    @light.turn_off    @thermostat.set_temperature(18)    @camera.activate  end  def arrive_home    @light.turn_on    @thermostat.set_temperature(22)    @camera.deactivate  endend</code></pre><p><strong>Step 3: Implement Client Code</strong></p><pre><code class="ruby">home = HomeAutomationFacade.newhome.leave_homehome.arrive_home</code></pre><p><em>Benefits</em>: Provides a simplified interface to a complex subsystem, promoting flexibility and scalability.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Adding New Devices</strong></p><p>Imagine you need to add a new device (e.g., Smart Lock). Using the Facade pattern, you can easily extend the home automation system without modifying the existing code.</p><p><strong>Without Facade Pattern:</strong></p><pre><code class="ruby">class SmartLock  def lock    puts &#39;Locking the smart lock&#39;  end  def unlock    puts &#39;Unlocking the smart lock&#39;  endendlock = SmartLock.newlock.locklock.unlock</code></pre><p><em>Drawbacks</em>: Tightly coupled code that is difficult to maintain and extend.</p><p><strong>With Facade Pattern:</strong></p><pre><code class="ruby">class HomeAutomationFacade  def initialize    @light = Light.new    @thermostat = Thermostat.new    @camera = SecurityCamera.new    @lock = SmartLock.new  end  def leave_home    @light.turn_off    @thermostat.set_temperature(18)    @camera.activate    @lock.lock  end  def arrive_home    @light.turn_on    @thermostat.set_temperature(22)    @camera.deactivate    @lock.unlock  endendhome = HomeAutomationFacade.newhome.leave_homehome.arrive_home</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and extensibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Facade pattern is a powerful tool for providing a simplified interface to a complex subsystem. It promotes flexibility, scalability, and maintainability in your code. By using the Facade pattern, you can easily extend and manage complex subsystems through a unified and simplified interface. Incorporate the Facade pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns.</p><p>Thôi Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/26/deep_dive_facade_pattern/facade_pattern.png&quot; class=&quot;&quot; title=&quot;facade_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;Deep-D</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software-Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design-Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Software-Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Facade-Pattern" scheme="https://dohungthinhsts.github.io/tags/Facade-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Structural Patterns - The Decorator Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/01/24/deep_dive_decorator_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/01/24/deep_dive_decorator_pattern/</id>
    <published>2024-01-24T05:00:00.000Z</published>
    <updated>2024-07-05T07:36:23.867Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/24/deep_dive_decorator_pattern/decorator_pattern.png" class="" title="decorator_pattern"></center><br><h2 id="Deep-Dive-into-Structural-Patterns-The-Decorator-Pattern"><a href="#Deep-Dive-into-Structural-Patterns-The-Decorator-Pattern" class="headerlink" title="Deep Dive into Structural Patterns - The Decorator Pattern."></a>Deep Dive into Structural Patterns - The Decorator Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Decorator pattern. This pattern allows you to add new functionality to objects dynamically and transparently. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Decorator-Pattern"><a href="#What-is-the-Decorator-Pattern" class="headerlink" title="What is the Decorator Pattern?"></a>What is the Decorator Pattern?</h3><p>The Decorator pattern is a structural design pattern that allows you to dynamically add behavior to objects without altering their code. It provides a flexible alternative to subclassing for extending functionality.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a text editor that allows users to add various formatting options to text (e.g., bold, italic, underline). Each formatting option can be applied independently or in combination with others. Managing these formatting options can be challenging.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When extending the functionality of objects, subclassing can lead to a rigid and inflexible class hierarchy. Hardcoding the logic to handle different combinations of behavior can result in tightly coupled and hard-to-maintain code.</p><h4 id="Without-Decorator-Pattern"><a href="#Without-Decorator-Pattern" class="headerlink" title="Without Decorator Pattern"></a>Without Decorator Pattern</h4><pre><code class="ruby">class Text  def initialize(content)    @content = content  end  def display    @content  endendclass BoldText &lt; Text  def display    &quot;&lt;b&gt;#&#123;super&#125;&lt;/b&gt;&quot;  endendclass ItalicText &lt; Text  def display    &quot;&lt;i&gt;#&#123;super&#125;&lt;/i&gt;&quot;  endendbold_text = BoldText.new(&quot;Hello&quot;)puts bold_text.displayitalic_text = ItalicText.new(&quot;Hello&quot;)puts italic_text.display</code></pre><p><em>Drawbacks</em>: The code is tightly coupled to specific implementations and hard to extend to support new formatting options.</p><h3 id="The-Solution-Decorator-Pattern"><a href="#The-Solution-Decorator-Pattern" class="headerlink" title="The Solution: Decorator Pattern"></a>The Solution: Decorator Pattern</h3><p>Using the Decorator pattern, we can dynamically add behavior to objects without altering their code, promoting flexibility and scalability.</p><h4 id="With-Decorator-Pattern"><a href="#With-Decorator-Pattern" class="headerlink" title="With Decorator Pattern"></a>With Decorator Pattern</h4><p><strong>Step 1: Define the Component Interface</strong></p><pre><code class="ruby">class Text  def display    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 2: Create Concrete Components</strong></p><pre><code class="ruby">class PlainText &lt; Text  def initialize(content)    @content = content  end  def display    @content  endend</code></pre><p><strong>Step 3: Create Decorators</strong></p><pre><code class="ruby">class TextDecorator &lt; Text  def initialize(text)    @text = text  end  def display    @text.display  endendclass BoldDecorator &lt; TextDecorator  def display    &quot;&lt;b&gt;#&#123;super&#125;&lt;/b&gt;&quot;  endendclass ItalicDecorator &lt; TextDecorator  def display    &quot;&lt;i&gt;#&#123;super&#125;&lt;/i&gt;&quot;  endend</code></pre><p><strong>Step 4: Implement Client Code</strong></p><pre><code class="ruby">plain_text = PlainText.new(&quot;Hello&quot;)bold_text = BoldDecorator.new(plain_text)puts bold_text.displayitalic_text = ItalicDecorator.new(plain_text)puts italic_text.displaybold_italic_text = ItalicDecorator.new(bold_text)puts bold_italic_text.display</code></pre><p><em>Benefits</em>: Dynamically adds behavior to objects without altering their code, promoting flexibility and scalability.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Adding New Formatting Options</strong></p><p>Imagine you need to add a new formatting option (e.g., Underline). Using the Decorator pattern, you can easily introduce a new decorator for the Underline formatting without modifying the existing code.</p><p><strong>Without Decorator Pattern:</strong></p><pre><code class="ruby">class UnderlineText &lt; Text  def display    &quot;&lt;u&gt;#&#123;super&#125;&lt;/u&gt;&quot;  endendunderline_text = UnderlineText.new(&quot;Hello&quot;)puts underline_text.display</code></pre><p><em>Drawbacks</em>: Tightly coupled code that is difficult to maintain and extend.</p><p><strong>With Decorator Pattern:</strong></p><pre><code class="ruby">class UnderlineDecorator &lt; TextDecorator  def display    &quot;&lt;u&gt;#&#123;super&#125;&lt;/u&gt;&quot;  endendunderline_text = UnderlineDecorator.new(plain_text)puts underline_text.displaybold_underline_text = UnderlineDecorator.new(bold_text)puts bold_underline_text.display</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and extensibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Decorator pattern is a powerful tool for dynamically adding behavior to objects without altering their code. It promotes flexibility, scalability, and maintainability in your code. By using the Decorator pattern, you can easily extend the functionality of objects without creating a rigid and inflexible class hierarchy. Incorporate the Decorator pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns.</p><p>Thôi Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/24/deep_dive_decorator_pattern/decorator_pattern.png&quot; class=&quot;&quot; title=&quot;decorator_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 i</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software-Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design-Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Software-Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Decorator-Pattern" scheme="https://dohungthinhsts.github.io/tags/Decorator-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Structural Patterns - The Composite Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/01/22/deep_dive_composite_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/01/22/deep_dive_composite_pattern/</id>
    <published>2024-01-22T05:00:00.000Z</published>
    <updated>2024-07-05T07:36:23.867Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/22/deep_dive_composite_pattern/composite_pattern.png" class="" title="composite_pattern"></center><br><h2 id="Deep-Dive-into-Structural-Patterns-The-Composite-Pattern"><a href="#Deep-Dive-into-Structural-Patterns-The-Composite-Pattern" class="headerlink" title="Deep Dive into Structural Patterns - The Composite Pattern."></a>Deep Dive into Structural Patterns - The Composite Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Composite pattern. This pattern allows you to compose objects into tree structures to represent part-whole hierarchies. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Composite-Pattern"><a href="#What-is-the-Composite-Pattern" class="headerlink" title="What is the Composite Pattern?"></a>What is the Composite Pattern?</h3><p>The Composite pattern is a structural design pattern that allows you to compose objects into tree structures to represent part-whole hierarchies. It lets clients treat individual objects and compositions of objects uniformly.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a graphics editor that allows users to draw shapes like circles, rectangles, and groups of shapes. Each shape can be an individual object or a composition of multiple shapes. Managing these shapes in a consistent and flexible way can be challenging.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When managing individual objects and compositions of objects, treating them differently can lead to a complex and hard-to-maintain codebase. Hardcoding the logic to handle different types of objects can result in tightly coupled and inflexible code.</p><h4 id="Without-Composite-Pattern"><a href="#Without-Composite-Pattern" class="headerlink" title="Without Composite Pattern"></a>Without Composite Pattern</h4><pre><code class="ruby">class Circle  def draw    puts &#39;Drawing a circle&#39;  endendclass Rectangle  def draw    puts &#39;Drawing a rectangle&#39;  endendclass Group  def initialize    @shapes = []  end  def add(shape)    @shapes &lt;&lt; shape  end  def draw    @shapes.each(&amp;:draw)  endendcircle = Circle.newrectangle = Rectangle.newgroup = Group.newgroup.add(circle)group.add(rectangle)group.draw</code></pre><p><em>Drawbacks</em>: The code is tightly coupled to specific implementations and hard to extend to support new shapes.</p><h3 id="The-Solution-Composite-Pattern"><a href="#The-Solution-Composite-Pattern" class="headerlink" title="The Solution: Composite Pattern"></a>The Solution: Composite Pattern</h3><p>Using the Composite pattern, we can treat individual objects and compositions of objects uniformly, promoting flexibility and scalability.</p><h4 id="With-Composite-Pattern"><a href="#With-Composite-Pattern" class="headerlink" title="With Composite Pattern"></a>With Composite Pattern</h4><p><strong>Step 1: Define the Component Interface</strong></p><pre><code class="ruby">class Shape  def draw    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 2: Create Leaf Components</strong></p><pre><code class="ruby">class Circle &lt; Shape  def draw    puts &#39;Drawing a circle&#39;  endendclass Rectangle &lt; Shape  def draw    puts &#39;Drawing a rectangle&#39;  endend</code></pre><p><strong>Step 3: Create Composite Components</strong></p><pre><code class="ruby">class Group &lt; Shape  def initialize    @shapes = []  end  def add(shape)    @shapes &lt;&lt; shape  end  def draw    @shapes.each(&amp;:draw)  endend</code></pre><p><strong>Step 4: Implement Client Code</strong></p><pre><code class="ruby">circle = Circle.newrectangle = Rectangle.newgroup = Group.newgroup.add(circle)group.add(rectangle)group.draw</code></pre><p><em>Benefits</em>: Treats individual objects and compositions of objects uniformly, promoting flexibility and scalability.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Adding New Shapes</strong></p><p>Imagine you need to add a new shape (e.g., Triangle). Using the Composite pattern, you can easily introduce a new shape without modifying the existing code.</p><p><strong>Without Composite Pattern:</strong></p><pre><code class="ruby">class Triangle  def draw    puts &#39;Drawing a triangle&#39;  endendgroup = Group.newtriangle = Triangle.newgroup.add(triangle)group.draw</code></pre><p><em>Drawbacks</em>: Tightly coupled code that is difficult to maintain and extend.</p><p><strong>With Composite Pattern:</strong></p><pre><code class="ruby">class Triangle &lt; Shape  def draw    puts &#39;Drawing a triangle&#39;  endendtriangle = Triangle.newgroup.add(triangle)group.draw</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and extensibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Composite pattern is a powerful tool for composing objects into tree structures to represent part-whole hierarchies. It promotes flexibility, scalability, and maintainability in your code. By using the Composite pattern, you can easily manage individual objects and compositions of objects uniformly. Incorporate the Composite pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns.</p><p>Thôi Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/22/deep_dive_composite_pattern/composite_pattern.png&quot; class=&quot;&quot; title=&quot;composite_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 i</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software-Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design-Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Software-Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Composite-Pattern" scheme="https://dohungthinhsts.github.io/tags/Composite-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Structural Patterns - The Bridge Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/01/20/deep_dive_bridge_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/01/20/deep_dive_bridge_pattern/</id>
    <published>2024-01-20T05:00:00.000Z</published>
    <updated>2024-07-05T07:36:23.867Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/20/deep_dive_bridge_pattern/bridge_pattern.png" class="" title="bridge_pattern"></center><br><h2 id="Deep-Dive-into-Structural-Patterns-The-Bridge-Pattern"><a href="#Deep-Dive-into-Structural-Patterns-The-Bridge-Pattern" class="headerlink" title="Deep Dive into Structural Patterns - The Bridge Pattern."></a>Deep Dive into Structural Patterns - The Bridge Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Bridge pattern. This pattern allows you to separate an object’s abstraction from its implementation, promoting flexibility and scalability. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Bridge-Pattern"><a href="#What-is-the-Bridge-Pattern" class="headerlink" title="What is the Bridge Pattern?"></a>What is the Bridge Pattern?</h3><p>The Bridge pattern is a structural design pattern that decouples an abstraction from its implementation so that the two can vary independently. It achieves this by creating two separate class hierarchies: one for the abstraction and one for the implementation.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a remote control system for various electronic devices (TVs, radios, lights). Each device has different functionalities and interfaces. Directly integrating these devices with the remote control can lead to a tightly coupled and inflexible system.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When an application needs to support multiple abstractions and implementations that should vary independently, directly integrating these abstractions and implementations can lead to a complex and tightly coupled system. This approach makes it difficult to introduce new abstractions or implementations without modifying existing code.</p><h4 id="Without-Bridge-Pattern"><a href="#Without-Bridge-Pattern" class="headerlink" title="Without Bridge Pattern"></a>Without Bridge Pattern</h4><pre><code class="ruby">class RemoteControl  def initialize(device)    @device = device  end  def turn_on    if @device == &#39;TV&#39;      puts &#39;Turning on the TV&#39;    elsif @device == &#39;Radio&#39;      puts &#39;Turning on the Radio&#39;    else      raise &#39;Unknown device&#39;    end  endendremote = RemoteControl.new(&#39;TV&#39;)remote.turn_onremote = RemoteControl.new(&#39;Radio&#39;)remote.turn_on</code></pre><p><em>Drawbacks</em>: The code is tightly coupled to specific implementations and hard to extend to support new devices.</p><h3 id="The-Solution-Bridge-Pattern"><a href="#The-Solution-Bridge-Pattern" class="headerlink" title="The Solution: Bridge Pattern"></a>The Solution: Bridge Pattern</h3><p>Using the Bridge pattern, we can decouple the abstraction (remote control) from its implementation (devices), promoting flexibility and scalability.</p><h4 id="With-Bridge-Pattern"><a href="#With-Bridge-Pattern" class="headerlink" title="With Bridge Pattern"></a>With Bridge Pattern</h4><p><strong>Step 1: Define the Implementor Interface</strong></p><pre><code class="ruby">class Device  def turn_on    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 2: Create Concrete Implementors</strong></p><pre><code class="ruby">class TV &lt; Device  def turn_on    puts &#39;Turning on the TV&#39;  endendclass Radio &lt; Device  def turn_on    puts &#39;Turning on the Radio&#39;  endend</code></pre><p><strong>Step 3: Define the Abstraction</strong></p><pre><code class="ruby">class RemoteControl  def initialize(device)    @device = device  end  def turn_on    @device.turn_on  endend</code></pre><p><strong>Step 4: Implement Client Code</strong></p><pre><code class="ruby">tv = TV.newradio = Radio.newremote = RemoteControl.new(tv)remote.turn_onremote = RemoteControl.new(radio)remote.turn_on</code></pre><p><em>Benefits</em>: Decouples the abstraction from its implementation, promoting flexibility and scalability.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Adding New Devices</strong></p><p>Imagine you need to add a new device (e.g., Light). Using the Bridge pattern, you can easily introduce a new implementor for the Light device without modifying the existing code.</p><p><strong>Without Bridge Pattern:</strong></p><pre><code class="ruby">class RemoteControl  def initialize(device)    @device = device  end  def turn_on    case @device    when &#39;TV&#39;      puts &#39;Turning on the TV&#39;    when &#39;Radio&#39;      puts &#39;Turning on the Radio&#39;    when &#39;Light&#39;      puts &#39;Turning on the Light&#39;    else      raise &#39;Unknown device&#39;    end  endendremote = RemoteControl.new(&#39;Light&#39;)remote.turn_on</code></pre><p><em>Drawbacks</em>: Tightly coupled code that is difficult to maintain and extend.</p><p><strong>With Bridge Pattern:</strong></p><pre><code class="ruby">class Light &lt; Device  def turn_on    puts &#39;Turning on the Light&#39;  endendlight = Light.newremote = RemoteControl.new(light)remote.turn_on</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and extensibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Bridge pattern is a powerful tool for decoupling abstractions from implementations. It promotes flexibility, scalability, and maintainability in your code. By using the Bridge pattern, you can easily introduce new abstractions and implementations without modifying existing code. Incorporate the Bridge pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns.</p><p>Thôi Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/20/deep_dive_bridge_pattern/bridge_pattern.png&quot; class=&quot;&quot; title=&quot;bridge_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;Deep-D</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software-Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design-Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Software-Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Bridge-Pattern" scheme="https://dohungthinhsts.github.io/tags/Bridge-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Structural Patterns - The Adapter Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/01/18/deep_dive_adapter_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/01/18/deep_dive_adapter_pattern/</id>
    <published>2024-01-18T05:00:00.000Z</published>
    <updated>2024-07-05T07:36:23.867Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/18/deep_dive_adapter_pattern/adapter_pattern.png" class="" title="adapter_pattern"></center><br><h2 id="Deep-Dive-into-Structural-Patterns-The-Adapter-Pattern"><a href="#Deep-Dive-into-Structural-Patterns-The-Adapter-Pattern" class="headerlink" title="Deep Dive into Structural Patterns - The Adapter Pattern."></a>Deep Dive into Structural Patterns - The Adapter Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Adapter pattern. This pattern allows incompatible interfaces to work together, providing a flexible solution to interface mismatches. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Adapter-Pattern"><a href="#What-is-the-Adapter-Pattern" class="headerlink" title="What is the Adapter Pattern?"></a>What is the Adapter Pattern?</h3><p>The Adapter pattern is a structural design pattern that allows objects with incompatible interfaces to work together. It acts as a bridge between two incompatible interfaces by wrapping an existing class with a new interface.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a payment processing system that needs to integrate with multiple third-party payment gateways. Each payment gateway has a different API, making it challenging to integrate them directly into your system.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When integrating multiple third-party services with different interfaces, directly using these services can lead to a tangled and hard-to-maintain codebase. Hardcoding the integration logic can result in tightly coupled and inflexible code.</p><h4 id="Without-Adapter-Pattern"><a href="#Without-Adapter-Pattern" class="headerlink" title="Without Adapter Pattern"></a>Without Adapter Pattern</h4><pre><code class="ruby">class PayPalPayment  def send_payment(amount)    puts &quot;Sending payment of #&#123;amount&#125; via PayPal&quot;  endendclass StripePayment  def process_payment(amount)    puts &quot;Processing payment of #&#123;amount&#125; via Stripe&quot;  endendclass PaymentProcessor  def process(amount, gateway)    case gateway    when &#39;PayPal&#39;      PayPalPayment.new.send_payment(amount)    when &#39;Stripe&#39;      StripePayment.new.process_payment(amount)    else      raise &#39;Unknown payment gateway&#39;    end  endendprocessor = PaymentProcessor.newprocessor.process(100, &#39;PayPal&#39;)processor.process(200, &#39;Stripe&#39;)</code></pre><p><em>Drawbacks</em>: The code is tightly coupled to specific implementations and hard to extend to support new payment gateways.</p><h3 id="The-Solution-Adapter-Pattern"><a href="#The-Solution-Adapter-Pattern" class="headerlink" title="The Solution: Adapter Pattern"></a>The Solution: Adapter Pattern</h3><p>Using the Adapter pattern, we can create a unified interface for different payment gateways, making the code more flexible and maintainable.</p><h4 id="With-Adapter-Pattern"><a href="#With-Adapter-Pattern" class="headerlink" title="With Adapter Pattern"></a>With Adapter Pattern</h4><p><strong>Step 1: Define the Target Interface</strong></p><pre><code class="ruby">class PaymentGateway  def pay(amount)    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 2: Create Adapters for Each Payment Gateway</strong></p><pre><code class="ruby">class PayPalAdapter &lt; PaymentGateway  def initialize(paypal_payment)    @paypal_payment = paypal_payment  end  def pay(amount)    @paypal_payment.send_payment(amount)  endendclass StripeAdapter &lt; PaymentGateway  def initialize(stripe_payment)    @stripe_payment = stripe_payment  end  def pay(amount)    @stripe_payment.process_payment(amount)  endend</code></pre><p><strong>Step 3: Implement Client Code</strong></p><pre><code class="ruby">class PaymentProcessor  def initialize(gateway)    @gateway = gateway  end  def process(amount)    @gateway.pay(amount)  endendpaypal = PayPalAdapter.new(PayPalPayment.new)stripe = StripeAdapter.new(StripePayment.new)processor = PaymentProcessor.new(paypal)processor.process(100)processor = PaymentProcessor.new(stripe)processor.process(200)</code></pre><p><em>Benefits</em>: Promotes loose coupling and makes the code more flexible and maintainable.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Adding New Payment Gateways</strong></p><p>Imagine you need to add a new payment gateway (e.g., Square). Using the Adapter pattern, you can easily introduce a new adapter for the Square payment gateway without modifying the existing code.</p><p><strong>Without Adapter Pattern:</strong></p><pre><code class="ruby">class PaymentProcessor  def process(amount, gateway)    case gateway    when &#39;PayPal&#39;      PayPalPayment.new.send_payment(amount)    when &#39;Stripe&#39;      StripePayment.new.process_payment(amount)    when &#39;Square&#39;      SquarePayment.new.make_payment(amount)    else      raise &#39;Unknown payment gateway&#39;    end  endendclass SquarePayment  def make_payment(amount)    puts &quot;Making payment of #&#123;amount&#125; via Square&quot;  endend</code></pre><p><em>Drawbacks</em>: Tightly coupled code that is difficult to maintain and extend.</p><p><strong>With Adapter Pattern:</strong></p><pre><code class="ruby">class SquareAdapter &lt; PaymentGateway  def initialize(square_payment)    @square_payment = square_payment  end  def pay(amount)    @square_payment.make_payment(amount)  endendsquare = SquareAdapter.new(SquarePayment.new)processor = PaymentProcessor.new(square)processor.process(300)</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and extensibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Adapter pattern is a powerful tool for allowing incompatible interfaces to work together. It promotes flexibility, maintainability, and loose coupling in your code. By using the Adapter pattern, you can easily integrate third-party services and components with different interfaces into your system. Incorporate the Adapter pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns.</p><p>Thôi Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/18/deep_dive_adapter_pattern/adapter_pattern.png&quot; class=&quot;&quot; title=&quot;adapter_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;Dee</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software-Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design-Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Adapter-Pattern" scheme="https://dohungthinhsts.github.io/tags/Adapter-Pattern/"/>
    
    <category term="Software-Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
  </entry>
  
</feed>
