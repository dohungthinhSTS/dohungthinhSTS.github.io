<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://dohungthinhsts.github.io/atom.xml" rel="self"/>
  
  <link href="https://dohungthinhsts.github.io/"/>
  <updated>2024-07-05T04:19:35.516Z</updated>
  <id>https://dohungthinhsts.github.io/</id>
  
  <author>
    <name>ThinhDo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Deep Dive into Structural Patterns - The Proxy Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/01/30/deep_dive_proxy_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/01/30/deep_dive_proxy_pattern/</id>
    <published>2024-01-30T05:00:00.000Z</published>
    <updated>2024-07-05T04:19:35.516Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/30/deep_dive_proxy_pattern/proxy_pattern.png" class="" title="proxy_pattern"></center><br><h2 id="Deep-Dive-into-Structural-Patterns-The-Proxy-Pattern"><a href="#Deep-Dive-into-Structural-Patterns-The-Proxy-Pattern" class="headerlink" title="Deep Dive into Structural Patterns - The Proxy Pattern."></a>Deep Dive into Structural Patterns - The Proxy Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Proxy pattern. This pattern provides a surrogate or placeholder for another object to control access to it. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Proxy-Pattern"><a href="#What-is-the-Proxy-Pattern" class="headerlink" title="What is the Proxy Pattern?"></a>What is the Proxy Pattern?</h3><p>The Proxy pattern is a structural design pattern that provides a surrogate or placeholder for another object to control access to it. It acts as an intermediary that can add functionality before or after delegating the request to the real object.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing an image viewer application that loads high-resolution images. Loading these images can be time-consuming, and you want to display a placeholder image while the high-resolution image is being loaded in the background.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When dealing with resource-intensive objects, directly accessing these objects can lead to performance issues and unnecessary resource consumption. Hardcoding the logic to manage these objects can result in a tightly coupled and inefficient codebase.</p><h4 id="Without-Proxy-Pattern"><a href="#Without-Proxy-Pattern" class="headerlink" title="Without Proxy Pattern"></a>Without Proxy Pattern</h4><pre><code class="ruby">class HighResolutionImage  def initialize(filename)    @filename = filename    load_image  end  def load_image    puts &quot;Loading high-resolution image: #&#123;@filename&#125;&quot;    # Simulate a time-consuming loading process    sleep(2)    puts &quot;Image loaded: #&#123;@filename&#125;&quot;  end  def display    puts &quot;Displaying image: #&#123;@filename&#125;&quot;  endendimage = HighResolutionImage.new(&#39;large_image.jpg&#39;)image.display</code></pre><p><em>Drawbacks</em>: The image is loaded immediately, leading to a delay before it can be displayed.</p><h3 id="The-Solution-Proxy-Pattern"><a href="#The-Solution-Proxy-Pattern" class="headerlink" title="The Solution: Proxy Pattern"></a>The Solution: Proxy Pattern</h3><p>Using the Proxy pattern, we can control access to the high-resolution image and display a placeholder image while the real image is being loaded in the background.</p><h4 id="With-Proxy-Pattern"><a href="#With-Proxy-Pattern" class="headerlink" title="With Proxy Pattern"></a>With Proxy Pattern</h4><p><strong>Step 1: Define the Subject Interface</strong></p><pre><code class="ruby">class Image  def display    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 2: Create the Real Subject</strong></p><pre><code class="ruby">class HighResolutionImage &lt; Image  def initialize(filename)    @filename = filename    load_image  end  def load_image    puts &quot;Loading high-resolution image: #&#123;@filename&#125;&quot;    # Simulate a time-consuming loading process    sleep(2)    puts &quot;Image loaded: #&#123;@filename&#125;&quot;  end  def display    puts &quot;Displaying image: #&#123;@filename&#125;&quot;  endend</code></pre><p><strong>Step 3: Create the Proxy</strong></p><pre><code class="ruby">class ImageProxy &lt; Image  def initialize(filename)    @filename = filename    @real_image = nil  end  def display    if @real_image.nil?      puts &quot;Displaying placeholder image&quot;      @real_image = HighResolutionImage.new(@filename)    end    @real_image.display  endend</code></pre><p><strong>Step 4: Implement Client Code</strong></p><pre><code class="ruby">image = ImageProxy.new(&#39;large_image.jpg&#39;)image.display</code></pre><p><em>Benefits</em>: Controls access to the high-resolution image, displaying a placeholder image while the real image is being loaded.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Managing Access to Resource-Intensive Objects</strong></p><p>Imagine you need to manage access to resource-intensive objects in a large-scale application. Using the Proxy pattern, you can control access to these objects and add functionality before or after delegating the request to the real object.</p><p><strong>Without Proxy Pattern:</strong></p><pre><code class="ruby">class DatabaseConnection  def connect    puts &#39;Establishing database connection...&#39;    # Simulate a time-consuming connection process    sleep(2)    puts &#39;Database connection established.&#39;  end  def execute_query(query)    puts &quot;Executing query: #&#123;query&#125;&quot;  endendconnection = DatabaseConnection.newconnection.connectconnection.execute_query(&#39;SELECT * FROM users&#39;)</code></pre><p><em>Drawbacks</em>: The connection is established immediately, leading to a delay before the query can be executed.</p><p><strong>With Proxy Pattern:</strong></p><pre><code class="ruby">class DatabaseConnectionProxy  def initialize    @real_connection = nil  end  def connect    if @real_connection.nil?      puts &#39;Displaying placeholder message&#39;      @real_connection = DatabaseConnection.new      @real_connection.connect    end  end  def execute_query(query)    connect    @real_connection.execute_query(query)  endendconnection = DatabaseConnectionProxy.newconnection.execute_query(&#39;SELECT * FROM users&#39;)</code></pre><p><em>Benefits</em>: Controls access to the database connection, displaying a placeholder message while the connection is being established.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Proxy pattern is a powerful tool for controlling access to objects and adding functionality before or after delegating the request to the real object. It promotes efficiency, scalability, and maintainability in your code. By using the Proxy pattern, you can manage access to resource-intensive objects and improve the performance of your application. Incorporate the Proxy pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns.</p><p>Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/30/deep_dive_proxy_pattern/proxy_pattern.png&quot; class=&quot;&quot; title=&quot;proxy_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;Deep-Dive</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Proxy Pattern" scheme="https://dohungthinhsts.github.io/tags/Proxy-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Structural Patterns - The Flyweight Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/01/28/deep_dive_flyweight_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/01/28/deep_dive_flyweight_pattern/</id>
    <published>2024-01-28T05:00:00.000Z</published>
    <updated>2024-07-05T04:18:06.089Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/28/deep_dive_flyweight_pattern/flyweight_pattern.png" class="" title="flyweight_pattern"></center><br><h2 id="Deep-Dive-into-Structural-Patterns-The-Flyweight-Pattern"><a href="#Deep-Dive-into-Structural-Patterns-The-Flyweight-Pattern" class="headerlink" title="Deep Dive into Structural Patterns - The Flyweight Pattern."></a>Deep Dive into Structural Patterns - The Flyweight Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Flyweight pattern. This pattern helps you efficiently support a large number of fine-grained objects by sharing as much data as possible. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Flyweight-Pattern"><a href="#What-is-the-Flyweight-Pattern" class="headerlink" title="What is the Flyweight Pattern?"></a>What is the Flyweight Pattern?</h3><p>The Flyweight pattern is a structural design pattern that allows you to minimize memory usage by sharing as much data as possible with similar objects. It is particularly useful when you need to create a large number of similar objects that would otherwise consume a significant amount of memory.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a graphical application that needs to render a large number of characters on the screen. Each character has its own properties (e.g., font, size, color), and creating an individual object for each character can lead to high memory consumption.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When creating a large number of fine-grained objects, each with its own state, memory consumption can become a significant issue. Hardcoding the logic to handle these objects can result in a tightly coupled and inefficient codebase.</p><h4 id="Without-Flyweight-Pattern"><a href="#Without-Flyweight-Pattern" class="headerlink" title="Without Flyweight Pattern"></a>Without Flyweight Pattern</h4><pre><code class="ruby">class Character  def initialize(char, font, size, color)    @char = char    @font = font    @size = size    @color = color  end  def display    puts &quot;Displaying #&#123;@char&#125; in #&#123;@font&#125; font, size #&#123;@size&#125;, color #&#123;@color&#125;&quot;  endendcharacters = [](&#39;a&#39;..&#39;z&#39;).each do |char|  characters &lt;&lt; Character.new(char, &#39;Arial&#39;, 12, &#39;black&#39;)endcharacters.each(&amp;:display)</code></pre><p><em>Drawbacks</em>: Each character object consumes memory for storing its properties, leading to high memory consumption.</p><h3 id="The-Solution-Flyweight-Pattern"><a href="#The-Solution-Flyweight-Pattern" class="headerlink" title="The Solution: Flyweight Pattern"></a>The Solution: Flyweight Pattern</h3><p>Using the Flyweight pattern, we can share the common properties of similar objects, reducing memory consumption and improving efficiency.</p><h4 id="With-Flyweight-Pattern"><a href="#With-Flyweight-Pattern" class="headerlink" title="With Flyweight Pattern"></a>With Flyweight Pattern</h4><p><strong>Step 1: Define the Flyweight</strong></p><pre><code class="ruby">class CharacterFlyweight  def initialize(char)    @char = char  end  def display(font, size, color)    puts &quot;Displaying #&#123;@char&#125; in #&#123;font&#125; font, size #&#123;size&#125;, color #&#123;color&#125;&quot;  endend</code></pre><p><strong>Step 2: Create the Flyweight Factory</strong></p><pre><code class="ruby">class FlyweightFactory  def initialize    @flyweights = &#123;&#125;  end  def get_flyweight(char)    @flyweights[char] ||= CharacterFlyweight.new(char)  endend</code></pre><p><strong>Step 3: Implement Client Code</strong></p><pre><code class="ruby">factory = FlyweightFactory.newcharacters = [](&#39;a&#39;..&#39;z&#39;).each do |char|  characters &lt;&lt; factory.get_flyweight(char)endcharacters.each do |char|  char.display(&#39;Arial&#39;, 12, &#39;black&#39;)end</code></pre><p><em>Benefits</em>: Shares the common properties of similar objects, reducing memory consumption and improving efficiency.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Rendering Characters in a Graphical Application</strong></p><p>Imagine you need to render a large number of characters on the screen with various properties. Using the Flyweight pattern, you can minimize memory usage by sharing the common properties of similar characters.</p><p><strong>Without Flyweight Pattern:</strong></p><pre><code class="ruby">class Character  def initialize(char, font, size, color)    @char = char    @font = font    @size = size    @color = color  end  def display    puts &quot;Displaying #&#123;@char&#125; in #&#123;@font&#125; font, size #&#123;@size&#125;, color #&#123;@color&#125;&quot;  endendcharacters = [](&#39;a&#39;..&#39;z&#39;).each do |char|  characters &lt;&lt; Character.new(char, &#39;Arial&#39;, 12, &#39;black&#39;)endcharacters.each(&amp;:display)</code></pre><p><em>Drawbacks</em>: High memory consumption due to each character object storing its own properties.</p><p><strong>With Flyweight Pattern:</strong></p><pre><code class="ruby">class CharacterFlyweight  def initialize(char)    @char = char  end  def display(font, size, color)    puts &quot;Displaying #&#123;@char&#125; in #&#123;font&#125; font, size #&#123;size&#125;, color #&#123;color&#125;&quot;  endendclass FlyweightFactory  def initialize    @flyweights = &#123;&#125;  end  def get_flyweight(char)    @flyweights[char] ||= CharacterFlyweight.new(char)  endendfactory = FlyweightFactory.newcharacters = [](&#39;a&#39;..&#39;z&#39;).each do |char|  characters &lt;&lt; factory.get_flyweight(char)endcharacters.each do |char|  char.display(&#39;Arial&#39;, 12, &#39;black&#39;)end</code></pre><p><em>Benefits</em>: Minimizes memory usage by sharing the common properties of similar objects.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Flyweight pattern is a powerful tool for minimizing memory usage by sharing as much data as possible with similar objects. It promotes efficiency and scalability in your code. By using the Flyweight pattern, you can support a large number of fine-grained objects without consuming excessive memory. Incorporate the Flyweight pattern into your design strategies to build more efficient and scalable software systems.</p><p>Stay tuned for more insights into software design principles and patterns.</p><p>Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/28/deep_dive_flyweight_pattern/flyweight_pattern.png&quot; class=&quot;&quot; title=&quot;flyweight_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 i</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Flyweight Pattern" scheme="https://dohungthinhsts.github.io/tags/Flyweight-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Structural Patterns - The Facade Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/01/26/deep_dive_facade_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/01/26/deep_dive_facade_pattern/</id>
    <published>2024-01-26T05:00:00.000Z</published>
    <updated>2024-07-05T04:17:52.599Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/26/deep_dive_facade_pattern/facade_pattern.png" class="" title="facade_pattern"></center><br><h2 id="Deep-Dive-into-Structural-Patterns-The-Facade-Pattern"><a href="#Deep-Dive-into-Structural-Patterns-The-Facade-Pattern" class="headerlink" title="Deep Dive into Structural Patterns - The Facade Pattern."></a>Deep Dive into Structural Patterns - The Facade Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Facade pattern. This pattern provides a simplified interface to a complex subsystem, making it easier to use. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Facade-Pattern"><a href="#What-is-the-Facade-Pattern" class="headerlink" title="What is the Facade Pattern?"></a>What is the Facade Pattern?</h3><p>The Facade pattern is a structural design pattern that provides a simplified interface to a complex subsystem. It defines a higher-level interface that makes the subsystem easier to use by hiding the complexity behind a simpler API.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a home automation system that controls various devices like lights, thermostats, and security cameras. Each device has its own interface and functionality, making it difficult for users to control them through a single interface.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When dealing with complex subsystems, directly interacting with their interfaces can lead to a complicated and hard-to-maintain codebase. Hardcoding the logic to handle different parts of the subsystem can result in tightly coupled and inflexible code.</p><h4 id="Without-Facade-Pattern"><a href="#Without-Facade-Pattern" class="headerlink" title="Without Facade Pattern"></a>Without Facade Pattern</h4><pre><code class="ruby">class Light  def turn_on    puts &#39;Turning on the light&#39;  end  def turn_off    puts &#39;Turning off the light&#39;  endendclass Thermostat  def set_temperature(temperature)    puts &quot;Setting temperature to #&#123;temperature&#125; degrees&quot;  endendclass SecurityCamera  def activate    puts &#39;Activating security camera&#39;  end  def deactivate    puts &#39;Deactivating security camera&#39;  endendlight = Light.newthermostat = Thermostat.newcamera = SecurityCamera.newlight.turn_onthermostat.set_temperature(22)camera.activate</code></pre><p><em>Drawbacks</em>: The code is tightly coupled to specific implementations and hard to extend to support new devices.</p><h3 id="The-Solution-Facade-Pattern"><a href="#The-Solution-Facade-Pattern" class="headerlink" title="The Solution: Facade Pattern"></a>The Solution: Facade Pattern</h3><p>Using the Facade pattern, we can provide a simplified interface to the complex subsystem, promoting flexibility and scalability.</p><h4 id="With-Facade-Pattern"><a href="#With-Facade-Pattern" class="headerlink" title="With Facade Pattern"></a>With Facade Pattern</h4><p><strong>Step 1: Define the Subsystem Interfaces</strong></p><pre><code class="ruby">class Light  def turn_on    puts &#39;Turning on the light&#39;  end  def turn_off    puts &#39;Turning off the light&#39;  endendclass Thermostat  def set_temperature(temperature)    puts &quot;Setting temperature to #&#123;temperature&#125; degrees&quot;  endendclass SecurityCamera  def activate    puts &#39;Activating security camera&#39;  end  def deactivate    puts &#39;Deactivating security camera&#39;  endend</code></pre><p><strong>Step 2: Create the Facade</strong></p><pre><code class="ruby">class HomeAutomationFacade  def initialize    @light = Light.new    @thermostat = Thermostat.new    @camera = SecurityCamera.new  end  def leave_home    @light.turn_off    @thermostat.set_temperature(18)    @camera.activate  end  def arrive_home    @light.turn_on    @thermostat.set_temperature(22)    @camera.deactivate  endend</code></pre><p><strong>Step 3: Implement Client Code</strong></p><pre><code class="ruby">home = HomeAutomationFacade.newhome.leave_homehome.arrive_home</code></pre><p><em>Benefits</em>: Provides a simplified interface to a complex subsystem, promoting flexibility and scalability.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Adding New Devices</strong></p><p>Imagine you need to add a new device (e.g., Smart Lock). Using the Facade pattern, you can easily extend the home automation system without modifying the existing code.</p><p><strong>Without Facade Pattern:</strong></p><pre><code class="ruby">class SmartLock  def lock    puts &#39;Locking the smart lock&#39;  end  def unlock    puts &#39;Unlocking the smart lock&#39;  endendlock = SmartLock.newlock.locklock.unlock</code></pre><p><em>Drawbacks</em>: Tightly coupled code that is difficult to maintain and extend.</p><p><strong>With Facade Pattern:</strong></p><pre><code class="ruby">class HomeAutomationFacade  def initialize    @light = Light.new    @thermostat = Thermostat.new    @camera = SecurityCamera.new    @lock = SmartLock.new  end  def leave_home    @light.turn_off    @thermostat.set_temperature(18)    @camera.activate    @lock.lock  end  def arrive_home    @light.turn_on    @thermostat.set_temperature(22)    @camera.deactivate    @lock.unlock  endendhome = HomeAutomationFacade.newhome.leave_homehome.arrive_home</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and extensibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Facade pattern is a powerful tool for providing a simplified interface to a complex subsystem. It promotes flexibility, scalability, and maintainability in your code. By using the Facade pattern, you can easily extend and manage complex subsystems through a unified and simplified interface. Incorporate the Facade pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns.</p><p>Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/26/deep_dive_facade_pattern/facade_pattern.png&quot; class=&quot;&quot; title=&quot;facade_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;Deep-D</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Facade Pattern" scheme="https://dohungthinhsts.github.io/tags/Facade-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Structural Patterns - The Decorator Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/01/24/deep_dive_decorator_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/01/24/deep_dive_decorator_pattern/</id>
    <published>2024-01-24T05:00:00.000Z</published>
    <updated>2024-07-05T04:17:46.664Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/24/deep_dive_decorator_pattern/decorator_pattern.png" class="" title="decorator_pattern"></center><br><h2 id="Deep-Dive-into-Structural-Patterns-The-Decorator-Pattern"><a href="#Deep-Dive-into-Structural-Patterns-The-Decorator-Pattern" class="headerlink" title="Deep Dive into Structural Patterns - The Decorator Pattern."></a>Deep Dive into Structural Patterns - The Decorator Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Decorator pattern. This pattern allows you to add new functionality to objects dynamically and transparently. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Decorator-Pattern"><a href="#What-is-the-Decorator-Pattern" class="headerlink" title="What is the Decorator Pattern?"></a>What is the Decorator Pattern?</h3><p>The Decorator pattern is a structural design pattern that allows you to dynamically add behavior to objects without altering their code. It provides a flexible alternative to subclassing for extending functionality.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a text editor that allows users to add various formatting options to text (e.g., bold, italic, underline). Each formatting option can be applied independently or in combination with others. Managing these formatting options can be challenging.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When extending the functionality of objects, subclassing can lead to a rigid and inflexible class hierarchy. Hardcoding the logic to handle different combinations of behavior can result in tightly coupled and hard-to-maintain code.</p><h4 id="Without-Decorator-Pattern"><a href="#Without-Decorator-Pattern" class="headerlink" title="Without Decorator Pattern"></a>Without Decorator Pattern</h4><pre><code class="ruby">class Text  def initialize(content)    @content = content  end  def display    @content  endendclass BoldText &lt; Text  def display    &quot;&lt;b&gt;#&#123;super&#125;&lt;/b&gt;&quot;  endendclass ItalicText &lt; Text  def display    &quot;&lt;i&gt;#&#123;super&#125;&lt;/i&gt;&quot;  endendbold_text = BoldText.new(&quot;Hello&quot;)puts bold_text.displayitalic_text = ItalicText.new(&quot;Hello&quot;)puts italic_text.display</code></pre><p><em>Drawbacks</em>: The code is tightly coupled to specific implementations and hard to extend to support new formatting options.</p><h3 id="The-Solution-Decorator-Pattern"><a href="#The-Solution-Decorator-Pattern" class="headerlink" title="The Solution: Decorator Pattern"></a>The Solution: Decorator Pattern</h3><p>Using the Decorator pattern, we can dynamically add behavior to objects without altering their code, promoting flexibility and scalability.</p><h4 id="With-Decorator-Pattern"><a href="#With-Decorator-Pattern" class="headerlink" title="With Decorator Pattern"></a>With Decorator Pattern</h4><p><strong>Step 1: Define the Component Interface</strong></p><pre><code class="ruby">class Text  def display    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 2: Create Concrete Components</strong></p><pre><code class="ruby">class PlainText &lt; Text  def initialize(content)    @content = content  end  def display    @content  endend</code></pre><p><strong>Step 3: Create Decorators</strong></p><pre><code class="ruby">class TextDecorator &lt; Text  def initialize(text)    @text = text  end  def display    @text.display  endendclass BoldDecorator &lt; TextDecorator  def display    &quot;&lt;b&gt;#&#123;super&#125;&lt;/b&gt;&quot;  endendclass ItalicDecorator &lt; TextDecorator  def display    &quot;&lt;i&gt;#&#123;super&#125;&lt;/i&gt;&quot;  endend</code></pre><p><strong>Step 4: Implement Client Code</strong></p><pre><code class="ruby">plain_text = PlainText.new(&quot;Hello&quot;)bold_text = BoldDecorator.new(plain_text)puts bold_text.displayitalic_text = ItalicDecorator.new(plain_text)puts italic_text.displaybold_italic_text = ItalicDecorator.new(bold_text)puts bold_italic_text.display</code></pre><p><em>Benefits</em>: Dynamically adds behavior to objects without altering their code, promoting flexibility and scalability.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Adding New Formatting Options</strong></p><p>Imagine you need to add a new formatting option (e.g., Underline). Using the Decorator pattern, you can easily introduce a new decorator for the Underline formatting without modifying the existing code.</p><p><strong>Without Decorator Pattern:</strong></p><pre><code class="ruby">class UnderlineText &lt; Text  def display    &quot;&lt;u&gt;#&#123;super&#125;&lt;/u&gt;&quot;  endendunderline_text = UnderlineText.new(&quot;Hello&quot;)puts underline_text.display</code></pre><p><em>Drawbacks</em>: Tightly coupled code that is difficult to maintain and extend.</p><p><strong>With Decorator Pattern:</strong></p><pre><code class="ruby">class UnderlineDecorator &lt; TextDecorator  def display    &quot;&lt;u&gt;#&#123;super&#125;&lt;/u&gt;&quot;  endendunderline_text = UnderlineDecorator.new(plain_text)puts underline_text.displaybold_underline_text = UnderlineDecorator.new(bold_text)puts bold_underline_text.display</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and extensibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Decorator pattern is a powerful tool for dynamically adding behavior to objects without altering their code. It promotes flexibility, scalability, and maintainability in your code. By using the Decorator pattern, you can easily extend the functionality of objects without creating a rigid and inflexible class hierarchy. Incorporate the Decorator pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns.</p><p>Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/24/deep_dive_decorator_pattern/decorator_pattern.png&quot; class=&quot;&quot; title=&quot;decorator_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 i</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Decorator Pattern" scheme="https://dohungthinhsts.github.io/tags/Decorator-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Structural Patterns - The Composite Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/01/22/deep_dive_composite_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/01/22/deep_dive_composite_pattern/</id>
    <published>2024-01-22T05:00:00.000Z</published>
    <updated>2024-07-05T04:17:39.054Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/22/deep_dive_composite_pattern/composite_pattern.png" class="" title="composite_pattern"></center><br><h2 id="Deep-Dive-into-Structural-Patterns-The-Composite-Pattern"><a href="#Deep-Dive-into-Structural-Patterns-The-Composite-Pattern" class="headerlink" title="Deep Dive into Structural Patterns - The Composite Pattern."></a>Deep Dive into Structural Patterns - The Composite Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Composite pattern. This pattern allows you to compose objects into tree structures to represent part-whole hierarchies. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Composite-Pattern"><a href="#What-is-the-Composite-Pattern" class="headerlink" title="What is the Composite Pattern?"></a>What is the Composite Pattern?</h3><p>The Composite pattern is a structural design pattern that allows you to compose objects into tree structures to represent part-whole hierarchies. It lets clients treat individual objects and compositions of objects uniformly.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a graphics editor that allows users to draw shapes like circles, rectangles, and groups of shapes. Each shape can be an individual object or a composition of multiple shapes. Managing these shapes in a consistent and flexible way can be challenging.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When managing individual objects and compositions of objects, treating them differently can lead to a complex and hard-to-maintain codebase. Hardcoding the logic to handle different types of objects can result in tightly coupled and inflexible code.</p><h4 id="Without-Composite-Pattern"><a href="#Without-Composite-Pattern" class="headerlink" title="Without Composite Pattern"></a>Without Composite Pattern</h4><pre><code class="ruby">class Circle  def draw    puts &#39;Drawing a circle&#39;  endendclass Rectangle  def draw    puts &#39;Drawing a rectangle&#39;  endendclass Group  def initialize    @shapes = []  end  def add(shape)    @shapes &lt;&lt; shape  end  def draw    @shapes.each(&amp;:draw)  endendcircle = Circle.newrectangle = Rectangle.newgroup = Group.newgroup.add(circle)group.add(rectangle)group.draw</code></pre><p><em>Drawbacks</em>: The code is tightly coupled to specific implementations and hard to extend to support new shapes.</p><h3 id="The-Solution-Composite-Pattern"><a href="#The-Solution-Composite-Pattern" class="headerlink" title="The Solution: Composite Pattern"></a>The Solution: Composite Pattern</h3><p>Using the Composite pattern, we can treat individual objects and compositions of objects uniformly, promoting flexibility and scalability.</p><h4 id="With-Composite-Pattern"><a href="#With-Composite-Pattern" class="headerlink" title="With Composite Pattern"></a>With Composite Pattern</h4><p><strong>Step 1: Define the Component Interface</strong></p><pre><code class="ruby">class Shape  def draw    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 2: Create Leaf Components</strong></p><pre><code class="ruby">class Circle &lt; Shape  def draw    puts &#39;Drawing a circle&#39;  endendclass Rectangle &lt; Shape  def draw    puts &#39;Drawing a rectangle&#39;  endend</code></pre><p><strong>Step 3: Create Composite Components</strong></p><pre><code class="ruby">class Group &lt; Shape  def initialize    @shapes = []  end  def add(shape)    @shapes &lt;&lt; shape  end  def draw    @shapes.each(&amp;:draw)  endend</code></pre><p><strong>Step 4: Implement Client Code</strong></p><pre><code class="ruby">circle = Circle.newrectangle = Rectangle.newgroup = Group.newgroup.add(circle)group.add(rectangle)group.draw</code></pre><p><em>Benefits</em>: Treats individual objects and compositions of objects uniformly, promoting flexibility and scalability.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Adding New Shapes</strong></p><p>Imagine you need to add a new shape (e.g., Triangle). Using the Composite pattern, you can easily introduce a new shape without modifying the existing code.</p><p><strong>Without Composite Pattern:</strong></p><pre><code class="ruby">class Triangle  def draw    puts &#39;Drawing a triangle&#39;  endendgroup = Group.newtriangle = Triangle.newgroup.add(triangle)group.draw</code></pre><p><em>Drawbacks</em>: Tightly coupled code that is difficult to maintain and extend.</p><p><strong>With Composite Pattern:</strong></p><pre><code class="ruby">class Triangle &lt; Shape  def draw    puts &#39;Drawing a triangle&#39;  endendtriangle = Triangle.newgroup.add(triangle)group.draw</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and extensibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Composite pattern is a powerful tool for composing objects into tree structures to represent part-whole hierarchies. It promotes flexibility, scalability, and maintainability in your code. By using the Composite pattern, you can easily manage individual objects and compositions of objects uniformly. Incorporate the Composite pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns.</p><p>Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/22/deep_dive_composite_pattern/composite_pattern.png&quot; class=&quot;&quot; title=&quot;composite_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 i</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Composite Pattern" scheme="https://dohungthinhsts.github.io/tags/Composite-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Structural Patterns - The Bridge Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/01/20/deep_dive_bridge_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/01/20/deep_dive_bridge_pattern/</id>
    <published>2024-01-20T05:00:00.000Z</published>
    <updated>2024-07-05T04:17:26.599Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/20/deep_dive_bridge_pattern/bridge_pattern.png" class="" title="bridge_pattern"></center><br><h2 id="Deep-Dive-into-Structural-Patterns-The-Bridge-Pattern"><a href="#Deep-Dive-into-Structural-Patterns-The-Bridge-Pattern" class="headerlink" title="Deep Dive into Structural Patterns - The Bridge Pattern."></a>Deep Dive into Structural Patterns - The Bridge Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Bridge pattern. This pattern allows you to separate an object’s abstraction from its implementation, promoting flexibility and scalability. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Bridge-Pattern"><a href="#What-is-the-Bridge-Pattern" class="headerlink" title="What is the Bridge Pattern?"></a>What is the Bridge Pattern?</h3><p>The Bridge pattern is a structural design pattern that decouples an abstraction from its implementation so that the two can vary independently. It achieves this by creating two separate class hierarchies: one for the abstraction and one for the implementation.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a remote control system for various electronic devices (TVs, radios, lights). Each device has different functionalities and interfaces. Directly integrating these devices with the remote control can lead to a tightly coupled and inflexible system.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When an application needs to support multiple abstractions and implementations that should vary independently, directly integrating these abstractions and implementations can lead to a complex and tightly coupled system. This approach makes it difficult to introduce new abstractions or implementations without modifying existing code.</p><h4 id="Without-Bridge-Pattern"><a href="#Without-Bridge-Pattern" class="headerlink" title="Without Bridge Pattern"></a>Without Bridge Pattern</h4><pre><code class="ruby">class RemoteControl  def initialize(device)    @device = device  end  def turn_on    if @device == &#39;TV&#39;      puts &#39;Turning on the TV&#39;    elsif @device == &#39;Radio&#39;      puts &#39;Turning on the Radio&#39;    else      raise &#39;Unknown device&#39;    end  endendremote = RemoteControl.new(&#39;TV&#39;)remote.turn_onremote = RemoteControl.new(&#39;Radio&#39;)remote.turn_on</code></pre><p><em>Drawbacks</em>: The code is tightly coupled to specific implementations and hard to extend to support new devices.</p><h3 id="The-Solution-Bridge-Pattern"><a href="#The-Solution-Bridge-Pattern" class="headerlink" title="The Solution: Bridge Pattern"></a>The Solution: Bridge Pattern</h3><p>Using the Bridge pattern, we can decouple the abstraction (remote control) from its implementation (devices), promoting flexibility and scalability.</p><h4 id="With-Bridge-Pattern"><a href="#With-Bridge-Pattern" class="headerlink" title="With Bridge Pattern"></a>With Bridge Pattern</h4><p><strong>Step 1: Define the Implementor Interface</strong></p><pre><code class="ruby">class Device  def turn_on    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 2: Create Concrete Implementors</strong></p><pre><code class="ruby">class TV &lt; Device  def turn_on    puts &#39;Turning on the TV&#39;  endendclass Radio &lt; Device  def turn_on    puts &#39;Turning on the Radio&#39;  endend</code></pre><p><strong>Step 3: Define the Abstraction</strong></p><pre><code class="ruby">class RemoteControl  def initialize(device)    @device = device  end  def turn_on    @device.turn_on  endend</code></pre><p><strong>Step 4: Implement Client Code</strong></p><pre><code class="ruby">tv = TV.newradio = Radio.newremote = RemoteControl.new(tv)remote.turn_onremote = RemoteControl.new(radio)remote.turn_on</code></pre><p><em>Benefits</em>: Decouples the abstraction from its implementation, promoting flexibility and scalability.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Adding New Devices</strong></p><p>Imagine you need to add a new device (e.g., Light). Using the Bridge pattern, you can easily introduce a new implementor for the Light device without modifying the existing code.</p><p><strong>Without Bridge Pattern:</strong></p><pre><code class="ruby">class RemoteControl  def initialize(device)    @device = device  end  def turn_on    case @device    when &#39;TV&#39;      puts &#39;Turning on the TV&#39;    when &#39;Radio&#39;      puts &#39;Turning on the Radio&#39;    when &#39;Light&#39;      puts &#39;Turning on the Light&#39;    else      raise &#39;Unknown device&#39;    end  endendremote = RemoteControl.new(&#39;Light&#39;)remote.turn_on</code></pre><p><em>Drawbacks</em>: Tightly coupled code that is difficult to maintain and extend.</p><p><strong>With Bridge Pattern:</strong></p><pre><code class="ruby">class Light &lt; Device  def turn_on    puts &#39;Turning on the Light&#39;  endendlight = Light.newremote = RemoteControl.new(light)remote.turn_on</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and extensibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Bridge pattern is a powerful tool for decoupling abstractions from implementations. It promotes flexibility, scalability, and maintainability in your code. By using the Bridge pattern, you can easily introduce new abstractions and implementations without modifying existing code. Incorporate the Bridge pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns.</p><p>Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/20/deep_dive_bridge_pattern/bridge_pattern.png&quot; class=&quot;&quot; title=&quot;bridge_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;Deep-D</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Bridge Pattern" scheme="https://dohungthinhsts.github.io/tags/Bridge-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Structural Patterns - The Adapter Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/01/18/deep_dive_adapter_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/01/18/deep_dive_adapter_pattern/</id>
    <published>2024-01-18T05:00:00.000Z</published>
    <updated>2024-07-05T04:17:31.798Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/18/deep_dive_adapter_pattern/adapter_pattern.png" class="" title="adapter_pattern"></center><br><h2 id="Deep-Dive-into-Structural-Patterns-The-Adapter-Pattern"><a href="#Deep-Dive-into-Structural-Patterns-The-Adapter-Pattern" class="headerlink" title="Deep Dive into Structural Patterns - The Adapter Pattern."></a>Deep Dive into Structural Patterns - The Adapter Pattern.</h2><p>  Hey software designers! Today, we’re diving into the Adapter pattern. This pattern allows incompatible interfaces to work together, providing a flexible solution to interface mismatches. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Adapter-Pattern"><a href="#What-is-the-Adapter-Pattern" class="headerlink" title="What is the Adapter Pattern?"></a>What is the Adapter Pattern?</h3><p>The Adapter pattern is a structural design pattern that allows objects with incompatible interfaces to work together. It acts as a bridge between two incompatible interfaces by wrapping an existing class with a new interface.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a payment processing system that needs to integrate with multiple third-party payment gateways. Each payment gateway has a different API, making it challenging to integrate them directly into your system.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When integrating multiple third-party services with different interfaces, directly using these services can lead to a tangled and hard-to-maintain codebase. Hardcoding the integration logic can result in tightly coupled and inflexible code.</p><h4 id="Without-Adapter-Pattern"><a href="#Without-Adapter-Pattern" class="headerlink" title="Without Adapter Pattern"></a>Without Adapter Pattern</h4><pre><code class="ruby">class PayPalPayment  def send_payment(amount)    puts &quot;Sending payment of #&#123;amount&#125; via PayPal&quot;  endendclass StripePayment  def process_payment(amount)    puts &quot;Processing payment of #&#123;amount&#125; via Stripe&quot;  endendclass PaymentProcessor  def process(amount, gateway)    case gateway    when &#39;PayPal&#39;      PayPalPayment.new.send_payment(amount)    when &#39;Stripe&#39;      StripePayment.new.process_payment(amount)    else      raise &#39;Unknown payment gateway&#39;    end  endendprocessor = PaymentProcessor.newprocessor.process(100, &#39;PayPal&#39;)processor.process(200, &#39;Stripe&#39;)</code></pre><p><em>Drawbacks</em>: The code is tightly coupled to specific implementations and hard to extend to support new payment gateways.</p><h3 id="The-Solution-Adapter-Pattern"><a href="#The-Solution-Adapter-Pattern" class="headerlink" title="The Solution: Adapter Pattern"></a>The Solution: Adapter Pattern</h3><p>Using the Adapter pattern, we can create a unified interface for different payment gateways, making the code more flexible and maintainable.</p><h4 id="With-Adapter-Pattern"><a href="#With-Adapter-Pattern" class="headerlink" title="With Adapter Pattern"></a>With Adapter Pattern</h4><p><strong>Step 1: Define the Target Interface</strong></p><pre><code class="ruby">class PaymentGateway  def pay(amount)    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 2: Create Adapters for Each Payment Gateway</strong></p><pre><code class="ruby">class PayPalAdapter &lt; PaymentGateway  def initialize(paypal_payment)    @paypal_payment = paypal_payment  end  def pay(amount)    @paypal_payment.send_payment(amount)  endendclass StripeAdapter &lt; PaymentGateway  def initialize(stripe_payment)    @stripe_payment = stripe_payment  end  def pay(amount)    @stripe_payment.process_payment(amount)  endend</code></pre><p><strong>Step 3: Implement Client Code</strong></p><pre><code class="ruby">class PaymentProcessor  def initialize(gateway)    @gateway = gateway  end  def process(amount)    @gateway.pay(amount)  endendpaypal = PayPalAdapter.new(PayPalPayment.new)stripe = StripeAdapter.new(StripePayment.new)processor = PaymentProcessor.new(paypal)processor.process(100)processor = PaymentProcessor.new(stripe)processor.process(200)</code></pre><p><em>Benefits</em>: Promotes loose coupling and makes the code more flexible and maintainable.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Adding New Payment Gateways</strong></p><p>Imagine you need to add a new payment gateway (e.g., Square). Using the Adapter pattern, you can easily introduce a new adapter for the Square payment gateway without modifying the existing code.</p><p><strong>Without Adapter Pattern:</strong></p><pre><code class="ruby">class PaymentProcessor  def process(amount, gateway)    case gateway    when &#39;PayPal&#39;      PayPalPayment.new.send_payment(amount)    when &#39;Stripe&#39;      StripePayment.new.process_payment(amount)    when &#39;Square&#39;      SquarePayment.new.make_payment(amount)    else      raise &#39;Unknown payment gateway&#39;    end  endendclass SquarePayment  def make_payment(amount)    puts &quot;Making payment of #&#123;amount&#125; via Square&quot;  endend</code></pre><p><em>Drawbacks</em>: Tightly coupled code that is difficult to maintain and extend.</p><p><strong>With Adapter Pattern:</strong></p><pre><code class="ruby">class SquareAdapter &lt; PaymentGateway  def initialize(square_payment)    @square_payment = square_payment  end  def pay(amount)    @square_payment.make_payment(amount)  endendsquare = SquareAdapter.new(SquarePayment.new)processor = PaymentProcessor.new(square)processor.process(300)</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and extensibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Adapter pattern is a powerful tool for allowing incompatible interfaces to work together. It promotes flexibility, maintainability, and loose coupling in your code. By using the Adapter pattern, you can easily integrate third-party services and components with different interfaces into your system. Incorporate the Adapter pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns.</p><p>Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/18/deep_dive_adapter_pattern/adapter_pattern.png&quot; class=&quot;&quot; title=&quot;adapter_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;Dee</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Adapter Pattern" scheme="https://dohungthinhsts.github.io/tags/Adapter-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Creational Patterns - The Factory Method Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/01/16/deep_dive_factory_method_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/01/16/deep_dive_factory_method_pattern/</id>
    <published>2024-01-16T05:00:00.000Z</published>
    <updated>2024-07-05T04:17:59.622Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/16/deep_dive_factory_method_pattern/factory_method_pattern.png" class="" title="factory_method_pattern"></center><br><h2 id="Deep-Dive-into-Creational-Patterns-The-Factory-Method-Pattern"><a href="#Deep-Dive-into-Creational-Patterns-The-Factory-Method-Pattern" class="headerlink" title="Deep Dive into Creational Patterns - The Factory Method Pattern."></a>Deep Dive into Creational Patterns - The Factory Method Pattern.</h2><p>  Hey software designers! Today, we’re exploring the Factory Method pattern. This pattern provides an interface for creating objects in a superclass but allows subclasses to alter the type of objects that will be created. Let’s dive into its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Factory-Method-Pattern"><a href="#What-is-the-Factory-Method-Pattern" class="headerlink" title="What is the Factory Method Pattern?"></a>What is the Factory Method Pattern?</h3><p>The Factory Method pattern is a creational design pattern that defines an interface for creating an object but allows subclasses to alter the type of objects that will be created. The Factory Method pattern promotes loose coupling by eliminating the need to bind application-specific classes into the code, allowing the code to refer to the newly created objects through their common interface.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a document editor that supports different types of documents (Word, PDF, Excel). Each type of document requires a different way of opening, editing, and saving. Without a systematic approach, you might end up with tightly coupled code that is hard to maintain and extend.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When an application needs to create instances of multiple derived classes, hardcoding the object creation logic can lead to a tightly coupled and inflexible codebase. This approach makes it difficult to introduce new types or change existing types without modifying the existing code.</p><h4 id="Without-Factory-Method-Pattern"><a href="#Without-Factory-Method-Pattern" class="headerlink" title="Without Factory Method Pattern"></a>Without Factory Method Pattern</h4><pre><code class="ruby">class DocumentEditor  def open_document(type)    case type    when &#39;Word&#39;      WordDocument.new.open    when &#39;PDF&#39;      PDFDocument.new.open    when &#39;Excel&#39;      ExcelDocument.new.open    else      raise &#39;Unknown document type&#39;    end  endendclass WordDocument  def open    puts &#39;Opening Word document...&#39;  endendclass PDFDocument  def open    puts &#39;Opening PDF document...&#39;  endendclass ExcelDocument  def open    puts &#39;Opening Excel document...&#39;  endendeditor = DocumentEditor.neweditor.open_document(&#39;Word&#39;)editor.open_document(&#39;PDF&#39;)</code></pre><p><em>Drawbacks</em>: The code is tightly coupled to specific implementations and hard to extend.</p><h3 id="The-Solution-Factory-Method-Pattern"><a href="#The-Solution-Factory-Method-Pattern" class="headerlink" title="The Solution: Factory Method Pattern"></a>The Solution: Factory Method Pattern</h3><p>Using the Factory Method pattern, we can delegate the responsibility of creating objects to subclasses, promoting flexibility and extensibility.</p><h4 id="With-Factory-Method-Pattern"><a href="#With-Factory-Method-Pattern" class="headerlink" title="With Factory Method Pattern"></a>With Factory Method Pattern</h4><p><strong>Step 1: Define the Product Interface</strong></p><pre><code class="ruby">class Document  def open    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 2: Create Concrete Products</strong></p><pre><code class="ruby">class WordDocument &lt; Document  def open    puts &#39;Opening Word document...&#39;  endendclass PDFDocument &lt; Document  def open    puts &#39;Opening PDF document...&#39;  endendclass ExcelDocument &lt; Document  def open    puts &#39;Opening Excel document...&#39;  endend</code></pre><p><strong>Step 3: Define the Creator Interface</strong></p><pre><code class="ruby">class DocumentCreator  def create_document    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  end  def open_document    document = create_document    document.open  endend</code></pre><p><strong>Step 4: Implement Concrete Creators</strong></p><pre><code class="ruby">class WordDocumentCreator &lt; DocumentCreator  def create_document    WordDocument.new  endendclass PDFDocumentCreator &lt; DocumentCreator  def create_document    PDFDocument.new  endendclass ExcelDocumentCreator &lt; DocumentCreator  def create_document    ExcelDocument.new  endend</code></pre><p><strong>Step 5: Implement Client Code</strong></p><pre><code class="ruby">word_creator = WordDocumentCreator.newword_creator.open_documentpdf_creator = PDFDocumentCreator.newpdf_creator.open_documentexcel_creator = ExcelDocumentCreator.newexcel_creator.open_document</code></pre><p><em>Benefits</em>: Promotes loose coupling, making the code more flexible and easier to extend.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Adding New Document Types</strong></p><p>Imagine you need to add a new type of document (e.g., TextDocument). Using the Factory Method pattern, you can easily introduce new document types without modifying the existing code.</p><p><strong>Without Factory Method Pattern:</strong></p><pre><code class="ruby">class DocumentEditor  def open_document(type)    case type    when &#39;Word&#39;      WordDocument.new.open    when &#39;PDF&#39;      PDFDocument.new.open    when &#39;Excel&#39;      ExcelDocument.new.open    when &#39;Text&#39;      TextDocument.new.open    else      raise &#39;Unknown document type&#39;    end  endendclass TextDocument  def open    puts &#39;Opening Text document...&#39;  endend</code></pre><p><em>Drawbacks</em>: Tightly coupled code that is difficult to maintain and extend.</p><p><strong>With Factory Method Pattern:</strong></p><pre><code class="ruby">class TextDocument &lt; Document  def open    puts &#39;Opening Text document...&#39;  endendclass TextDocumentCreator &lt; DocumentCreator  def create_document    TextDocument.new  endendtext_creator = TextDocumentCreator.newtext_creator.open_document</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and extensibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Factory Method pattern is a powerful tool for creating objects in a flexible and extensible manner. It promotes loose coupling and enhances the maintainability of your code. By using the Factory Method pattern, you can easily introduce new types and alter existing ones without modifying the existing code. Incorporate the Factory Method pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns.</p><p>Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/16/deep_dive_factory_method_pattern/factory_method_pattern.png&quot; class=&quot;&quot; title=&quot;factory_method_pattern&quot;&gt;
&lt;/cente</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Factory Method Pattern" scheme="https://dohungthinhsts.github.io/tags/Factory-Method-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Creational Patterns - The Singleton Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/01/15/deep_dive_singleton_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/01/15/deep_dive_singleton_pattern/</id>
    <published>2024-01-15T05:00:00.000Z</published>
    <updated>2024-07-05T04:19:42.343Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/15/deep_dive_singleton_pattern/singleton_pattern.png" class="" title="singleton_pattern"></center><br><h2 id="Deep-Dive-into-Creational-Patterns-The-Singleton-Pattern"><a href="#Deep-Dive-into-Creational-Patterns-The-Singleton-Pattern" class="headerlink" title="Deep Dive into Creational Patterns - The Singleton Pattern."></a>Deep Dive into Creational Patterns - The Singleton Pattern.</h2><p>  Hey software designers! Today, we’re exploring the Singleton pattern. This pattern ensures that a class has only one instance and provides a global point of access to it. Let’s dive into its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Singleton-Pattern"><a href="#What-is-the-Singleton-Pattern" class="headerlink" title="What is the Singleton Pattern?"></a>What is the Singleton Pattern?</h3><p>The Singleton pattern is a creational design pattern that restricts the instantiation of a class to a single instance. This is useful when exactly one object is needed to coordinate actions across the system. The Singleton pattern ensures that a class has only one instance and provides a global point of access to it.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re developing a logging system for an application. The logging system should only have one instance to ensure that all parts of the application log messages to the same place. Without a systematic approach, you might end up with multiple loggers, leading to inconsistent and hard-to-track logs.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When a class must have only one instance, creating multiple instances can lead to problems such as inconsistent state, increased memory usage, and difficulty in managing shared resources. Hardcoding a single instance throughout the application can lead to tight coupling and inflexibility.</p><h4 id="Without-Singleton-Pattern"><a href="#Without-Singleton-Pattern" class="headerlink" title="Without Singleton Pattern"></a>Without Singleton Pattern</h4><pre><code class="ruby">class Logger  def log(message)    puts &quot;Log: #&#123;message&#125;&quot;  endendlogger1 = Logger.newlogger2 = Logger.newlogger1.log(&#39;First message&#39;)logger2.log(&#39;Second message&#39;)</code></pre><p><em>Drawbacks</em>: Multiple instances of the Logger class can lead to inconsistent logging and difficulty in managing the logging process.</p><h3 id="The-Solution-Singleton-Pattern"><a href="#The-Solution-Singleton-Pattern" class="headerlink" title="The Solution: Singleton Pattern"></a>The Solution: Singleton Pattern</h3><p>Using the Singleton pattern, we can ensure that only one instance of the Logger class exists, providing a consistent and manageable logging process.</p><h4 id="With-Singleton-Pattern"><a href="#With-Singleton-Pattern" class="headerlink" title="With Singleton Pattern"></a>With Singleton Pattern</h4><p><strong>Step 1: Define the Singleton Class</strong></p><pre><code class="ruby">class Logger  @instance = Logger.new  private_class_method :new  def self.instance    @instance  end  def log(message)    puts &quot;Log: #&#123;message&#125;&quot;  endend</code></pre><p><strong>Step 2: Implement Client Code</strong></p><pre><code class="ruby">logger1 = Logger.instancelogger2 = Logger.instancelogger1.log(&#39;First message&#39;)logger2.log(&#39;Second message&#39;)</code></pre><p><em>Benefits</em>: Ensures that only one instance of the Logger class exists, providing consistent and manageable logging.</p><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Managing Configuration Settings</strong></p><p>Imagine you need to manage configuration settings for your application. Using the Singleton pattern, you can ensure that only one instance of the configuration manager exists, providing a consistent and manageable way to access and update settings.</p><p><strong>Without Singleton Pattern:</strong></p><pre><code class="ruby">class ConfigManager  def initialize    @settings = &#123;&#125;  end  def set(key, value)    @settings[key] = value  end  def get(key)    @settings[key]  endendconfig1 = ConfigManager.newconfig2 = ConfigManager.newconfig1.set(&#39;theme&#39;, &#39;dark&#39;)puts config2.get(&#39;theme&#39;) # nil</code></pre><p><em>Drawbacks</em>: Multiple instances of the ConfigManager class can lead to inconsistent settings and difficulty in managing the configuration process.</p><p><strong>With Singleton Pattern:</strong></p><pre><code class="ruby">class ConfigManager  @instance = ConfigManager.new  private_class_method :new  def self.instance    @instance  end  def initialize    @settings = &#123;&#125;  end  def set(key, value)    @settings[key] = value  end  def get(key)    @settings[key]  endendconfig1 = ConfigManager.instanceconfig2 = ConfigManager.instanceconfig1.set(&#39;theme&#39;, &#39;dark&#39;)puts config2.get(&#39;theme&#39;) # dark</code></pre><p><em>Benefits</em>: Ensures that only one instance of the ConfigManager class exists, providing consistent and manageable configuration settings.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Singleton pattern is a powerful tool for ensuring that a class has only one instance and providing a global point of access to it. It promotes consistency, efficiency, and manageability in your code. By using the Singleton pattern, you can ensure that shared resources are used effectively and that your application behaves predictably. Incorporate the Singleton pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns.</p><p>Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/15/deep_dive_singleton_pattern/singleton_pattern.png&quot; class=&quot;&quot; title=&quot;singleton_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 i</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Singleton Pattern" scheme="https://dohungthinhsts.github.io/tags/Singleton-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Creational Patterns - The Prototype Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/01/14/deep_dive_prototype_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/01/14/deep_dive_prototype_pattern/</id>
    <published>2024-01-14T05:00:00.000Z</published>
    <updated>2024-07-05T04:19:29.912Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/14/deep_dive_prototype_pattern/prototype_pattern.png" class="" title="prototype_pattern"></center><br><h2 id="Deep-Dive-into-Creational-Patterns-The-Prototype-Pattern"><a href="#Deep-Dive-into-Creational-Patterns-The-Prototype-Pattern" class="headerlink" title="Deep Dive into Creational Patterns - The Prototype Pattern."></a>Deep Dive into Creational Patterns - The Prototype Pattern.</h2><p> Hey software designers! Today, we’re exploring the Prototype pattern. This pattern is a powerful tool for creating new objects by copying existing ones, offering flexibility and performance improvements. Let’s dive into its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Prototype-Pattern"><a href="#What-is-the-Prototype-Pattern" class="headerlink" title="What is the Prototype Pattern?"></a>What is the Prototype Pattern?</h3><p>The Prototype pattern is a creational design pattern that allows you to create new objects by copying an existing object, known as the prototype. Instead of instantiating a new object from scratch, you clone the prototype, which can be more efficient and flexible, especially when creating objects that are resource-intensive to instantiate.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re working on a game that includes various types of characters (warriors, mages, archers). Each character has different attributes and abilities, and creating them from scratch every time could be time-consuming and inefficient.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When creating multiple instances of complex objects, instantiating each one from scratch can be resource-intensive and slow. Hardcoding the creation logic for each type of character can lead to duplication and inflexible code.</p><h4 id="Without-Prototype-Pattern"><a href="#Without-Prototype-Pattern" class="headerlink" title="Without Prototype Pattern"></a>Without Prototype Pattern</h4><pre><code class="ruby">class Warrior  attr_accessor :name, :health, :attack_power  def initialize(name, health, attack_power)    @name = name    @health = health    @attack_power = attack_power  endendwarrior1 = Warrior.new(&#39;Aragon&#39;, 100, 50)warrior2 = Warrior.new(&#39;Boromir&#39;, 100, 50)</code></pre><p><em>Drawbacks</em>: Duplicate initialization logic, inflexible and hard to maintain.</p><h3 id="The-Solution-Prototype-Pattern"><a href="#The-Solution-Prototype-Pattern" class="headerlink" title="The Solution: Prototype Pattern"></a>The Solution: Prototype Pattern</h3><p>Using the Prototype pattern, we can create new instances by cloning existing ones, reducing the need for repetitive initialization logic and improving performance.</p><h4 id="With-Prototype-Pattern"><a href="#With-Prototype-Pattern" class="headerlink" title="With Prototype Pattern"></a>With Prototype Pattern</h4><p><strong>Step 1: Define the Prototype Interface</strong></p><pre><code class="ruby">class CharacterPrototype  def clone    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 2: Create Concrete Prototypes</strong></p><pre><code class="ruby">class Warrior &lt; CharacterPrototype  attr_accessor :name, :health, :attack_power  def initialize(name, health, attack_power)    @name = name    @health = health    @attack_power = attack_power  end  def clone    Warrior.new(@name, @health, @attack_power)  endendclass Mage &lt; CharacterPrototype  attr_accessor :name, :health, :magic_power  def initialize(name, health, magic_power)    @name = name    @health = health    @magic_power = magic_power  end  def clone    Mage.new(@name, @health, @magic_power)  endend</code></pre><p><strong>Step 3: Implement Client Code</strong></p><pre><code class="ruby">warrior1 = Warrior.new(&#39;Aragon&#39;, 100, 50)warrior2 = warrior1.clonewarrior2.name = &#39;Boromir&#39;mage1 = Mage.new(&#39;Gandalf&#39;, 80, 100)mage2 = mage1.clonemage2.name = &#39;Saruman&#39;puts warrior1.name # Aragonputs warrior2.name # Boromirputs mage1.name    # Gandalfputs mage2.name    # Saruman</code></pre><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Creating Different Character Types</strong></p><p>Imagine you need to create various character types (warriors, mages, archers) with different attributes. Using the Prototype pattern, you can easily clone existing characters and modify their attributes without writing repetitive code.</p><p><strong>Without Prototype Pattern:</strong></p><pre><code class="ruby">class CharacterFactory  def create_warrior(name)    Warrior.new(name, 100, 50)  end  def create_mage(name)    Mage.new(name, 80, 100)  endendfactory = CharacterFactory.newwarrior1 = factory.create_warrior(&#39;Aragon&#39;)warrior2 = factory.create_warrior(&#39;Boromir&#39;)</code></pre><p><em>Drawbacks</em>: Repetitive initialization logic, inflexible and hard to extend.</p><p><strong>With Prototype Pattern:</strong></p><pre><code class="ruby">prototype_warrior = Warrior.new(&#39;Prototype&#39;, 100, 50)prototype_mage = Mage.new(&#39;Prototype&#39;, 80, 100)warrior1 = prototype_warrior.clonewarrior1.name = &#39;Aragon&#39;warrior2 = prototype_warrior.clonewarrior2.name = &#39;Boromir&#39;mage1 = prototype_mage.clonemage1.name = &#39;Gandalf&#39;mage2 = prototype_mage.clonemage2.name = &#39;Saruman&#39;</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and efficiency.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Prototype pattern is a powerful tool for creating new objects by copying existing ones. It promotes flexibility, efficiency, and maintainability in your code. By cloning existing objects, the Prototype pattern allows you to create complex objects without the need for repetitive initialization logic. Incorporate the Prototype pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns.</p><p>Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/14/deep_dive_prototype_pattern/prototype_pattern.png&quot; class=&quot;&quot; title=&quot;prototype_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 i</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Prototype Pattern" scheme="https://dohungthinhsts.github.io/tags/Prototype-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Creational Patterns - The Builder Pattern</title>
    <link href="https://dohungthinhsts.github.io/2024/01/13/deep_dive_builder_pattern/"/>
    <id>https://dohungthinhsts.github.io/2024/01/13/deep_dive_builder_pattern/</id>
    <published>2024-01-13T05:00:00.000Z</published>
    <updated>2024-07-05T03:40:49.533Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/13/deep_dive_builder_pattern/builder_pattern.png" class="" title="builder_pattern"></center><br><h2 id="Deep-Dive-into-Creational-Patterns-The-Builder-Pattern"><a href="#Deep-Dive-into-Creational-Patterns-The-Builder-Pattern" class="headerlink" title="Deep Dive into Creational Patterns: The Builder Pattern."></a>Deep Dive into Creational Patterns: The Builder Pattern.</h2><p> Hey software designers! Today, we’re diving into the Builder pattern. This pattern is essential for constructing complex objects step by step, providing a flexible solution to object creation. Let’s explore its workings, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Builder-Pattern"><a href="#What-is-the-Builder-Pattern" class="headerlink" title="What is the Builder Pattern?"></a>What is the Builder Pattern?</h3><p>The Builder pattern is a creational design pattern that allows you to construct complex objects step by step. Unlike other creational patterns, the Builder pattern doesn’t require products to have a common interface. It separates the construction of a complex object from its representation, enabling the same construction process to create different representations.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re building a customizable burger at a fast-food restaurant. A customer can choose from a variety of ingredients (buns, patties, vegetables, sauces). Without a systematic approach, you might end up with a disorganized process, leading to incorrect orders and unhappy customers.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When constructing complex objects like customizable burgers, managing the creation process can become chaotic. Hardcoding the creation logic can result in a monolithic and inflexible codebase.</p><h4 id="Without-Builder-Pattern"><a href="#Without-Builder-Pattern" class="headerlink" title="Without Builder Pattern"></a>Without Builder Pattern</h4><pre><code class="ruby">class Burger  attr_accessor :bun, :patty, :vegetables, :sauce  def initialize(bun, patty, vegetables, sauce)    @bun = bun    @patty = patty    @vegetables = vegetables    @sauce = sauce  endendburger = Burger.new(&#39;Sesame&#39;, &#39;Beef&#39;, [&#39;Lettuce&#39;, &#39;Tomato&#39;], &#39;Mayo&#39;)</code></pre><p><em>Drawbacks</em>: The constructor becomes unwieldy with many parameters, making it hard to read and maintain.</p><h3 id="The-Solution-Builder-Pattern"><a href="#The-Solution-Builder-Pattern" class="headerlink" title="The Solution: Builder Pattern"></a>The Solution: Builder Pattern</h3><p>Using the Builder pattern, we can construct complex objects step by step, allowing for greater flexibility and readability.</p><h4 id="With-Builder-Pattern"><a href="#With-Builder-Pattern" class="headerlink" title="With Builder Pattern"></a>With Builder Pattern</h4><p><strong>Step 1: Define the Product</strong></p><pre><code class="ruby">class Burger  attr_accessor :bun, :patty, :vegetables, :sauce  def initialize    @vegetables = []  end  def describe    &quot;Burger with #&#123;@bun&#125; bun, #&#123;@patty&#125; patty, #&#123;vegetables.join(&#39;, &#39;)&#125; vegetables, and #&#123;@sauce&#125; sauce.&quot;  endend</code></pre><p><strong>Step 2: Create the Builder Interface</strong></p><pre><code class="ruby">class BurgerBuilder  def add_bun(bun)    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  end  def add_patty(patty)    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  end  def add_vegetables(vegetables)    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  end  def add_sauce(sauce)    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  end  def build    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 3: Implement Concrete Builders</strong></p><pre><code class="ruby">class ConcreteBurgerBuilder &lt; BurgerBuilder  def initialize    @burger = Burger.new  end  def add_bun(bun)    @burger.bun = bun    self  end  def add_patty(patty)    @burger.patty = patty    self  end  def add_vegetables(vegetables)    @burger.vegetables.concat(vegetables)    self  end  def add_sauce(sauce)    @burger.sauce = sauce    self  end  def build    @burger  endend</code></pre><p><strong>Step 4: Create the Director</strong></p><pre><code class="ruby">class BurgerDirector  def initialize(builder)    @builder = builder  end  def construct    @builder.add_bun(&#39;Sesame&#39;)           .add_patty(&#39;Beef&#39;)           .add_vegetables([&#39;Lettuce&#39;, &#39;Tomato&#39;])           .add_sauce(&#39;Mayo&#39;)           .build  endend</code></pre><p><strong>Step 5: Implement Client Code</strong></p><pre><code class="ruby">builder = ConcreteBurgerBuilder.newdirector = BurgerDirector.new(builder)burger = director.constructputs burger.describe</code></pre><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Creating Customizable Orders</strong></p><p>Imagine you need to offer various types of burgers (vegan, chicken, beef) with different combinations of ingredients. Using the Builder pattern, you can easily construct different types of burgers without altering the client code.</p><p><strong>Without Builder Pattern:</strong></p><pre><code class="ruby">class Burger  def initialize(type)    case type    when &#39;vegan&#39;      @bun = &#39;Whole Wheat&#39;      @patty = &#39;Black Bean&#39;      @vegetables = [&#39;Lettuce&#39;, &#39;Tomato&#39;]      @sauce = &#39;Hummus&#39;    when &#39;chicken&#39;      @bun = &#39;Sesame&#39;      @patty = &#39;Chicken&#39;      @vegetables = [&#39;Lettuce&#39;, &#39;Pickles&#39;]      @sauce = &#39;Mayo&#39;    else      @bun = &#39;Sesame&#39;      @patty = &#39;Beef&#39;      @vegetables = [&#39;Lettuce&#39;, &#39;Tomato&#39;]      @sauce = &#39;Mayo&#39;    end  endendburger = Burger.new(&#39;vegan&#39;)</code></pre><p><em>Drawbacks</em>: The constructor becomes cluttered with conditional logic, making it difficult to extend and maintain.</p><p><strong>With Builder Pattern:</strong></p><pre><code class="ruby">builder = ConcreteBurgerBuilder.newdirector = BurgerDirector.new(builder)vegan_burger = director.construct(&#39;vegan&#39;)puts vegan_burger.describe</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility and readability.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Builder pattern is a powerful tool for constructing complex objects step by step. It promotes flexibility, readability, and maintainability in your code. By separating the construction of a complex object from its representation, the Builder pattern allows for greater control over the object creation process. Incorporate the Builder pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns.</p><p>Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/13/deep_dive_builder_pattern/builder_pattern.png&quot; class=&quot;&quot; title=&quot;builder_pattern&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;Dee</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Builder Pattern" scheme="https://dohungthinhsts.github.io/tags/Builder-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Deep Dive into Creational Patterns - The Abstract Factory</title>
    <link href="https://dohungthinhsts.github.io/2024/01/12/deep_dive_abstract_factory/"/>
    <id>https://dohungthinhsts.github.io/2024/01/12/deep_dive_abstract_factory/</id>
    <published>2024-01-12T05:00:00.000Z</published>
    <updated>2024-07-05T03:40:57.276Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/12/deep_dive_abstract_factory/abstract_factory.png" class="" title="abstract_factory"></center><br><h2 id="Deep-Dive-into-Creational-Patterns-The-Abstract-Factory"><a href="#Deep-Dive-into-Creational-Patterns-The-Abstract-Factory" class="headerlink" title="Deep Dive into Creational Patterns: The Abstract Factory."></a>Deep Dive into Creational Patterns: The Abstract Factory.</h2><p> Hey software designers! Today, we’re exploring the Abstract Factory pattern in depth. This pattern is a cornerstone in the world of design patterns, providing a robust way to create families of related or dependent objects without specifying their concrete classes. Let’s uncover its intricacies, benefits, and real-world applications with detailed examples.</p><h3 id="What-is-the-Abstract-Factory-Pattern"><a href="#What-is-the-Abstract-Factory-Pattern" class="headerlink" title="What is the Abstract Factory Pattern?"></a>What is the Abstract Factory Pattern?</h3><p>The Abstract Factory pattern is a creational design pattern that provides an interface for creating families of related or dependent objects without specifying their concrete classes. It encapsulates a group of individual factories with a common goal. In essence, the pattern defines a high-level interface to create objects, but delegates the actual creation to specific subclasses.</p><h3 id="Real-World-Scenario"><a href="#Real-World-Scenario" class="headerlink" title="Real-World Scenario"></a>Real-World Scenario</h3><p>Imagine you’re tasked with developing a cross-platform GUI application. You need to support multiple operating systems (Windows, macOS, Linux), each having its own set of UI components like buttons and checkboxes. Without a systematic approach, you might end up with a lot of platform-specific code scattered throughout your application, making it hard to maintain and extend.</p><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>When building a cross-platform GUI toolkit, different platforms have different UI controls. For instance, a button in Windows looks different from a button in macOS. Hardcoding the creation of these UI elements for each platform can lead to a mess of if-else statements or switch cases, making your codebase fragile and hard to maintain.</p><h4 id="Without-Abstract-Factory"><a href="#Without-Abstract-Factory" class="headerlink" title="Without Abstract Factory"></a>Without Abstract Factory</h4><pre><code class="ruby">class Application  def initialize(os)    @os = os  end  def create_ui    if @os == &#39;Windows&#39;      button = WindowsButton.new      checkbox = WindowsCheckbox.new    elsif @os == &#39;Mac&#39;      button = MacButton.new      checkbox = MacCheckbox.new    else      raise &#39;Unknown operating system&#39;    end    button.paint    checkbox.paint  endendclass WindowsButton  def paint    puts &#39;Render a button in Windows style&#39;  endendclass WindowsCheckbox  def paint    puts &#39;Render a checkbox in Windows style&#39;  endendclass MacButton  def paint    puts &#39;Render a button in macOS style&#39;  endendclass MacCheckbox  def paint    puts &#39;Render a checkbox in macOS style&#39;  endendapp = Application.new(&#39;Windows&#39;)app.create_ui</code></pre><p><em>Drawbacks</em>: The code is tightly coupled to specific implementations and hard to extend to support new platforms.</p><h3 id="The-Solution-Abstract-Factory-Pattern"><a href="#The-Solution-Abstract-Factory-Pattern" class="headerlink" title="The Solution: Abstract Factory Pattern"></a>The Solution: Abstract Factory Pattern</h3><p>Using the Abstract Factory pattern, we can encapsulate the platform-specific creation logic into separate factory classes. This way, the client code remains agnostic to the actual product classes.</p><h4 id="With-Abstract-Factory"><a href="#With-Abstract-Factory" class="headerlink" title="With Abstract Factory"></a>With Abstract Factory</h4><p><strong>Step 1: Define Abstract Products</strong></p><pre><code class="ruby"># Abstract product interfacesclass Button  def paint    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endendclass Checkbox  def paint    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 2: Create Concrete Products</strong></p><pre><code class="ruby"># Concrete product implementations for Windowsclass WindowsButton &lt; Button  def paint    puts &#39;Render a button in Windows style&#39;  endendclass WindowsCheckbox &lt; Checkbox  def paint    puts &#39;Render a checkbox in Windows style&#39;  endend# Concrete product implementations for macOSclass MacButton &lt; Button  def paint    puts &#39;Render a button in macOS style&#39;  endendclass MacCheckbox &lt; Checkbox  def paint    puts &#39;Render a checkbox in macOS style&#39;  endend</code></pre><p><strong>Step 3: Define Abstract Factory</strong></p><pre><code class="ruby"># Abstract factory interfaceclass GUIFactory  def create_button    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  end  def create_checkbox    raise NotImplementedError, &quot;#&#123;self.class&#125; has not implemented method &#39;#&#123;__method__&#125;&#39;&quot;  endend</code></pre><p><strong>Step 4: Create Concrete Factories</strong></p><pre><code class="ruby"># Concrete factory implementations for Windowsclass WindowsFactory &lt; GUIFactory  def create_button    WindowsButton.new  end  def create_checkbox    WindowsCheckbox.new  endend# Concrete factory implementations for macOSclass MacFactory &lt; GUIFactory  def create_button    MacButton.new  end  def create_checkbox    MacCheckbox.new  endend</code></pre><p><strong>Step 5: Implement Client Code</strong></p><pre><code class="ruby"># Client code that uses the factoryclass Application  def initialize(factory)    @factory = factory    @button = @factory.create_button    @checkbox = @factory.create_checkbox  end  def paint    @button.paint    @checkbox.paint  endend# Example usagedef configure_application(os)  factory = case os            when &#39;Windows&#39; then WindowsFactory.new            when &#39;Mac&#39; then MacFactory.new            else raise &#39;Unknown operating system&#39;            end  app = Application.new(factory)  app.paintendconfigure_application(&#39;Windows&#39;)</code></pre><h3 id="Real-World-Benefits"><a href="#Real-World-Benefits" class="headerlink" title="Real-World Benefits"></a>Real-World Benefits</h3><p><strong>Scenario: Switching UI Themes</strong></p><p>Imagine you need to switch from a light theme to a dark theme in your application. Using the Abstract Factory pattern, you can easily create a new set of products (buttons, checkboxes, etc.) for the dark theme and switch factories without changing the client code.</p><p><strong>Without Abstract Factory:</strong></p><pre><code class="ruby">class Application  def paint    if theme == &#39;light&#39;      button = LightButton.new      checkbox = LightCheckbox.new    elsif theme == &#39;dark&#39;      button = DarkButton.new      checkbox = DarkCheckbox.new    end    button.paint    checkbox.paint  endend</code></pre><p><em>Drawbacks</em>: Code is tightly coupled, difficult to maintain, and modify.</p><p><strong>With Abstract Factory:</strong></p><pre><code class="ruby">def configure_application(theme)  factory = case theme            when &#39;light&#39; then LightThemeFactory.new            when &#39;dark&#39; then DarkThemeFactory.new            else raise &#39;Unknown theme&#39;            end  app = Application.new(factory)  app.paintend</code></pre><p><em>Benefits</em>: Clean, maintainable code with high flexibility.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Abstract Factory pattern is a powerful tool in the software designer’s toolkit. It helps in creating families of related objects without being tied to their concrete implementations. This pattern promotes flexibility, consistency, and decoupling, making your code easier to manage and extend. Incorporate the Abstract Factory pattern into your design strategies to build more robust and adaptable software systems.</p><p>Stay tuned for more insights into software design principles and patterns.</p><p>Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/12/deep_dive_abstract_factory/abstract_factory.png&quot; class=&quot;&quot; title=&quot;abstract_factory&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="Abstract Factory" scheme="https://dohungthinhsts.github.io/tags/Abstract-Factory/"/>
    
  </entry>
  
  <entry>
    <title>Overview of Design Patterns from GOF - The Foundations of Modern Software Design</title>
    <link href="https://dohungthinhsts.github.io/2024/01/11/overview_of_gof_design_patterns/"/>
    <id>https://dohungthinhsts.github.io/2024/01/11/overview_of_gof_design_patterns/</id>
    <published>2024-01-11T05:00:00.000Z</published>
    <updated>2024-07-04T13:21:23.566Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/11/overview_of_gof_design_patterns/design_patterns_gof.png" class="" title="design_patterns_gof"></center><br><h2 id="Overview-of-Design-Patterns-from-GOF-The-Foundations-of-Modern-Software-Design"><a href="#Overview-of-Design-Patterns-from-GOF-The-Foundations-of-Modern-Software-Design" class="headerlink" title="Overview of Design Patterns from GOF: The Foundations of Modern Software Design"></a>Overview of Design Patterns from GOF: The Foundations of Modern Software Design</h2><p>Hey software designers! Today, we’re diving into the world of Design Patterns from the Gang of Four (GOF). These patterns have been the cornerstone of software design, offering tried-and-true solutions to common problems. Let’s explore their history, importance, real-world problems when not applying them, and the benefits of using them.</p><h3 id="The-History-of-GOF-Design-Patterns"><a href="#The-History-of-GOF-Design-Patterns" class="headerlink" title="The History of GOF Design Patterns"></a>The History of GOF Design Patterns</h3><p>The term “Design Patterns” in software development became widely recognized with the publication of the book <em>“Design Patterns: Elements of Reusable Object-Oriented Software”</em> in 1994 by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, collectively known as the Gang of Four (GOF). This seminal work was inspired by the earlier work of architect Christopher Alexander, who introduced the concept of design patterns in the context of building architecture.</p><h3 id="The-Importance-of-Design-Patterns"><a href="#The-Importance-of-Design-Patterns" class="headerlink" title="The Importance of Design Patterns"></a>The Importance of Design Patterns</h3><p>Design patterns play a crucial role in software engineering for several reasons:</p><ul><li><strong>Reusability</strong>: Patterns provide a template that can be reused in different contexts, reducing the need to reinvent solutions.</li><li><strong>Communication</strong>: They offer a common language for developers to discuss and convey complex design concepts.</li><li><strong>Best Practices</strong>: Patterns encapsulate best practices and proven solutions, helping to improve the quality and maintainability of software.</li><li><strong>Flexibility</strong>: By following patterns, developers can create systems that are more flexible and easier to modify as requirements change.</li></ul><h3 id="Problems-Without-Design-Patterns"><a href="#Problems-Without-Design-Patterns" class="headerlink" title="Problems Without Design Patterns"></a>Problems Without Design Patterns</h3><p>Imagine you’re building a house without a blueprint. You might end up with a structurally unsound building, rooms that don’t fit together well, and a lot of wasted materials. The same applies to software design. Without design patterns, you may face:</p><ul><li><strong>Rigid Code</strong>: Hard-to-change code because dependencies are tightly coupled.</li><li><strong>Duplicate Code</strong>: Repetitive solutions scattered throughout the codebase, making maintenance a nightmare.</li><li><strong>Poor Scalability</strong>: Systems that can’t easily grow or adapt to new requirements.</li><li><strong>Difficult Debugging</strong>: Increased complexity and intertwined code, making it harder to identify and fix bugs.</li></ul><h3 id="Benefits-of-Applying-Design-Patterns"><a href="#Benefits-of-Applying-Design-Patterns" class="headerlink" title="Benefits of Applying Design Patterns"></a>Benefits of Applying Design Patterns</h3><p>Now, let’s consider the benefits of applying design patterns with some real-world examples:</p><h4 id="Creational-Patterns"><a href="#Creational-Patterns" class="headerlink" title="Creational Patterns"></a>Creational Patterns</h4><p><strong>Example: Singleton Pattern</strong></p><p><strong>Without Singleton:</strong></p><pre><code class="ruby">class Logger  def log(message)    # Log message  endend# Multiple instances can cause inconsistencylogger1 = Logger.newlogger2 = Logger.new</code></pre><p><strong>With Singleton:</strong></p><pre><code class="ruby">class Logger  @@instance = Logger.new  def self.instance    @@instance  end  def log(message)    # Log message  end  private_class_method :newend# Consistent single instancelogger1 = Logger.instancelogger2 = Logger.instance</code></pre><p><em>Benefits:</em> Ensures a single instance of <code>Logger</code>, providing consistent logging and saving resources.</p><h4 id="Structural-Patterns"><a href="#Structural-Patterns" class="headerlink" title="Structural Patterns"></a>Structural Patterns</h4><p><strong>Example: Adapter Pattern</strong></p><p><strong>Without Adapter:</strong></p><pre><code class="ruby">class EuropeanPlug  def plug_in    # Plug in with European standards  endendclass AmericanSocket  def plug_in    # Plug in with American standards  endend# Incompatible interfaceseuropean_plug = EuropeanPlug.newamerican_socket = AmericanSocket.new</code></pre><p><strong>With Adapter:</strong></p><pre><code class="ruby">class EuropeanPlugAdapter  def initialize(european_plug)    @european_plug = european_plug  end  def plug_in    @european_plug.plug_in  endendeuropean_plug = EuropeanPlug.newadapter = EuropeanPlugAdapter.new(european_plug)adapter.plug_in</code></pre><p><em>Benefits:</em> Allows incompatible interfaces to work together, enhancing flexibility and reusability.</p><h4 id="Behavioral-Patterns"><a href="#Behavioral-Patterns" class="headerlink" title="Behavioral Patterns"></a>Behavioral Patterns</h4><p><strong>Example: Observer Pattern</strong></p><p><strong>Without Observer:</strong></p><pre><code class="ruby">class DataSource  def initialize    @data = []  end  def add_data(data)    @data &lt;&lt; data    # Notify all views (tightly coupled)    view1.update(data)    view2.update(data)  endendclass View1  def update(data)    # Update view  endendclass View2  def update(data)    # Update view  endend</code></pre><p><strong>With Observer:</strong></p><pre><code class="ruby">class DataSource  def initialize    @data = []    @observers = []  end  def add_observer(observer)    @observers &lt;&lt; observer  end  def add_data(data)    @data &lt;&lt; data    notify_observers(data)  end  private  def notify_observers(data)    @observers.each &#123; |observer| observer.update(data) &#125;  endendclass Observer  def update(data)    # Update observer  endendview1 = Observer.newview2 = Observer.newdata_source = DataSource.newdata_source.add_observer(view1)data_source.add_observer(view2)</code></pre><p><em>Benefits:</em> Decouples the data source and observers, making the system more flexible and easier to maintain.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The design patterns introduced by the GOF have stood the test of time and continue to be relevant in modern software development. They offer a toolkit of solutions that can make your code more robust, flexible, and maintainable. Embrace these patterns and incorporate them into your projects to become a more effective and efficient developer.</p><p>Stay tuned for more insights into software design principles and patterns.<br>Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/11/overview_of_gof_design_patterns/design_patterns_gof.png&quot; class=&quot;&quot; title=&quot;design_patterns_gof&quot;&gt;
&lt;/center&gt;

&lt;br</summary>
      
    
    
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/categories/Software-Design/"/>
    
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Software Design" scheme="https://dohungthinhsts.github.io/tags/Software-Design/"/>
    
    <category term="Design Patterns" scheme="https://dohungthinhsts.github.io/tags/Design-Patterns/"/>
    
    <category term="GOF" scheme="https://dohungthinhsts.github.io/tags/GOF/"/>
    
  </entry>
  
  <entry>
    <title>The Dependency Inversion Principle in Rails - Stay Flexible</title>
    <link href="https://dohungthinhsts.github.io/2024/01/10/dip_in_rails_detailed/"/>
    <id>https://dohungthinhsts.github.io/2024/01/10/dip_in_rails_detailed/</id>
    <published>2024-01-10T05:00:00.000Z</published>
    <updated>2024-07-04T13:17:54.075Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/10/dip_in_rails_detailed/dependency_inversion_principle.png" class="" title="dependency_inversion_principle"></center><br><h2 id="The-Dependency-Inversion-Principle-in-Rails-Stay-Flexible"><a href="#The-Dependency-Inversion-Principle-in-Rails-Stay-Flexible" class="headerlink" title="The Dependency Inversion Principle in Rails: Stay Flexible"></a>The Dependency Inversion Principle in Rails: Stay Flexible</h2><p>Hey Rails devs! Today, we’re tackling the Dependency Inversion Principle (DIP). This principle is all about making your code flexible and adaptable. Think of it like using adapters for your gadgets – the device and the power source don’t need to know about each other, just the adapter.</p><h3 id="What-is-the-Dependency-Inversion-Principle"><a href="#What-is-the-Dependency-Inversion-Principle" class="headerlink" title="What is the Dependency Inversion Principle?"></a>What is the Dependency Inversion Principle?</h3><p>The Dependency Inversion Principle states that high-level modules should not depend on low-level modules. Both should depend on abstractions. Additionally, abstractions should not depend on details. Details should depend on abstractions.</p><h3 id="Why-is-DIP-Important"><a href="#Why-is-DIP-Important" class="headerlink" title="Why is DIP Important?"></a>Why is DIP Important?</h3><p>Following DIP helps make your code more flexible and easier to change. It’s like having a universal charger that works with all your devices – no more worrying about compatibility issues.</p><h3 id="DIP-in-Models"><a href="#DIP-in-Models" class="headerlink" title="DIP in Models"></a>DIP in Models</h3><p>Let’s start with models. Imagine you have a <code>Payment</code> model that processes different types of payments. Instead of hardcoding the payment logic, you can use DIP to make it more flexible.</p><h4 id="Example-Notifications-System"><a href="#Example-Notifications-System" class="headerlink" title="Example: Notifications System"></a>Example: Notifications System</h4><p><strong>Before:</strong></p><pre><code class="ruby">class Notification  def send_email(message)    # Send email notification  end  def send_sms(message)    # Send SMS notification  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class Notification  def initialize(sender)    @sender = sender  end  def send(message)    @sender.send(message)  endendclass EmailSender  def send(message)    # Send email notification  endendclass SmsSender  def send(message)    # Send SMS notification  endendclass PushNotificationSender  def send(message)    # Send push notification  endend</code></pre><p>Now you can easily switch between different notification types by simply changing the sender. It’s like using a universal charger – one adapter for all your devices.</p><h3 id="DIP-in-Controllers"><a href="#DIP-in-Controllers" class="headerlink" title="DIP in Controllers"></a>DIP in Controllers</h3><p>Controllers should also follow DIP by depending on abstractions rather than concrete implementations.</p><h4 id="Example-Payment-Processing"><a href="#Example-Payment-Processing" class="headerlink" title="Example: Payment Processing"></a>Example: Payment Processing</h4><p><strong>Before:</strong></p><pre><code class="ruby">class PaymentsController &lt; ApplicationController  def create    if params[:payment_type] == &#39;credit_card&#39;      # Process credit card payment    elsif params[:payment_type] == &#39;paypal&#39;      # Process PayPal payment    end  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class PaymentsController &lt; ApplicationController  def create    payment_processor = PaymentProcessorFactory.create(params[:payment_type])    payment_processor.process(params[:amount])  endendclass PaymentProcessorFactory  def self.create(payment_type)    case payment_type    when &#39;credit_card&#39;      CreditCardProcessor.new    when &#39;paypal&#39;      PayPalProcessor.new    else      raise &quot;Unknown payment type&quot;    end  endend</code></pre><p>By depending on <code>PaymentProcessorFactory</code>, the controller remains flexible and adaptable. It’s like having a multi-tool that can handle any job – just switch the attachment.</p><h3 id="DIP-in-Views"><a href="#DIP-in-Views" class="headerlink" title="DIP in Views"></a>DIP in Views</h3><p>Views should also follow the Dependency Inversion Principle to keep the presentation logic flexible.</p><h4 id="Example-Rendering-Different-Payment-Methods"><a href="#Example-Rendering-Different-Payment-Methods" class="headerlink" title="Example: Rendering Different Payment Methods"></a>Example: Rendering Different Payment Methods</h4><p><strong>Before:</strong></p><pre><code class="erb">&lt;% if payment.method == &#39;credit_card&#39; %&gt;  &lt;%= render &#39;credit_card_form&#39;, payment: payment %&gt;&lt;% elsif payment.method == &#39;paypal&#39; %&gt;  &lt;%= render &#39;paypal_form&#39;, payment: payment %&gt;&lt;% end %&gt;</code></pre><p><strong>After:</strong></p><pre><code class="erb">&lt;%= render partial: payment.form_partial, locals: &#123; payment: payment &#125; %&gt;</code></pre><pre><code class="ruby">class Payment  def form_partial    raise NotImplementedError, &#39;You must implement the form_partial method&#39;  endendclass CreditCardPayment &lt; Payment  def form_partial    &#39;credit_card_form&#39;  endendclass PayPalPayment &lt; Payment  def form_partial    &#39;paypal_form&#39;  endend</code></pre><p>With this approach, you can add new payment methods without changing the main view file. It’s like having a universal adapter for all your devices – one slot fits all.</p><h3 id="DIP-in-Services"><a href="#DIP-in-Services" class="headerlink" title="DIP in Services"></a>DIP in Services</h3><p>Services can greatly benefit from the Dependency Inversion Principle by allowing new functionalities to be added easily.</p><h4 id="Example-Notification-Service"><a href="#Example-Notification-Service" class="headerlink" title="Example: Notification Service"></a>Example: Notification Service</h4><p><strong>Before:</strong></p><pre><code class="ruby">class NotificationService  def send_email(message)    # Send email notification  end  def send_sms(message)    # Send SMS notification  end  def send_push(message)    # Send push notification  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class NotificationService  def initialize(sender)    @sender = sender  end  def send(message)    @sender.send(message)  endendclass EmailSender  def send(message)    # Send email notification  endendclass SmsSender  def send(message)    # Send SMS notification  endendclass PushSender  def send(message)    # Send push notification  endend</code></pre><p>By using DIP, you can easily swap out different notification senders without changing the <code>NotificationService</code>. It’s like using different plug adapters for the same power strip.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Dependency Inversion Principle is about making your code flexible and adaptable. By following DIP, you can create software that is easier to change and maintain. It’s like using universal adapters – one tool for all your needs.</p><p>Stay tuned for more tips on writing clean, efficient, and fun Ruby on Rails code.</p><p>Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/10/dip_in_rails_detailed/dependency_inversion_principle.png&quot; class=&quot;&quot; title=&quot;dependency_inversion_principle&quot;&gt;
&lt;/</summary>
      
    
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/categories/Ruby/"/>
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/tags/Ruby/"/>
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Rails" scheme="https://dohungthinhsts.github.io/tags/Rails/"/>
    
    <category term="SOLID" scheme="https://dohungthinhsts.github.io/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>The Interface Segregation Principle in Rails - Keep It Clean and Focused</title>
    <link href="https://dohungthinhsts.github.io/2024/01/09/isp_in_rails_detailed/"/>
    <id>https://dohungthinhsts.github.io/2024/01/09/isp_in_rails_detailed/</id>
    <published>2024-01-09T05:00:00.000Z</published>
    <updated>2024-07-04T13:17:56.564Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/09/isp_in_rails_detailed/interface_segregation_principle.png" class="" title="interface_segregation_principle"></center><br><h2 id="The-Interface-Segregation-Principle-in-Rails-Keep-It-Clean-and-Focused"><a href="#The-Interface-Segregation-Principle-in-Rails-Keep-It-Clean-and-Focused" class="headerlink" title="The Interface Segregation Principle in Rails: Keep It Clean and Focused"></a>The Interface Segregation Principle in Rails: Keep It Clean and Focused</h2><p>Hey Rails devs! Today, we’re delving into the Interface Segregation Principle (ISP). This principle is all about keeping your interfaces clean and focused. Think of it like having different remotes for different devices – no more turning off the TV when you meant to adjust the volume on the stereo.</p><h3 id="What-is-the-Interface-Segregation-Principle"><a href="#What-is-the-Interface-Segregation-Principle" class="headerlink" title="What is the Interface Segregation Principle?"></a>What is the Interface Segregation Principle?</h3><p>The Interface Segregation Principle states that no client should be forced to depend on methods it does not use. This means creating specific interfaces for different clients, so each client gets exactly what it needs and nothing more.</p><h3 id="Why-is-ISP-Important"><a href="#Why-is-ISP-Important" class="headerlink" title="Why is ISP Important?"></a>Why is ISP Important?</h3><p>Following ISP helps make your code more modular and easier to understand. It’s like having a toolbox where each tool has a specific purpose, making it easy to find what you need without digging through a pile of unrelated tools.</p><h3 id="ISP-in-Models"><a href="#ISP-in-Models" class="headerlink" title="ISP in Models"></a>ISP in Models</h3><p>Let’s start with models. Imagine you have a <code>Report</code> class that generates different types of reports. Instead of cramming all the report generation logic into one class, you can use ISP to create specific interfaces for each type of report.</p><h4 id="Example-Different-Types-of-Reports"><a href="#Example-Different-Types-of-Reports" class="headerlink" title="Example: Different Types of Reports"></a>Example: Different Types of Reports</h4><p><strong>Before:</strong></p><pre><code class="ruby">class Report  def generate_pdf    # Generate PDF report  end  def generate_csv    # Generate CSV report  end  def generate_html    # Generate HTML report  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class Reportendclass PdfReport &lt; Report  def generate    # Generate PDF report  endendclass CsvReport &lt; Report  def generate    # Generate CSV report  endendclass HtmlReport &lt; Report  def generate    # Generate HTML report  endend</code></pre><p>Now each report type has its own class, making the code easier to understand and maintain. It’s like having separate apps for streaming music, videos, and news – each with its own interface.</p><h3 id="ISP-in-Controllers"><a href="#ISP-in-Controllers" class="headerlink" title="ISP in Controllers"></a>ISP in Controllers</h3><p>Controllers should also follow ISP by delegating specific tasks to specialized classes instead of handling everything themselves.</p><h4 id="Example-User-Authentication"><a href="#Example-User-Authentication" class="headerlink" title="Example: User Authentication"></a>Example: User Authentication</h4><p><strong>Before:</strong></p><pre><code class="ruby">class UsersController &lt; ApplicationController  def authenticate    user = User.find_by(email: params[:email])    if user &amp;&amp; user.authenticate(params[:password])      # Authentication logic    else      # Handle authentication failure    end  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class UsersController &lt; ApplicationController  def authenticate    authenticator = UserAuthenticator.new(params[:email], params[:password])    if authenticator.authenticate      # Handle successful authentication    else      # Handle authentication failure    end  endend</code></pre><pre><code class="ruby">class UserAuthenticator  def initialize(email, password)    @user = User.find_by(email: email)    @password = password  end  def authenticate    @user &amp;&amp; @user.authenticate(@password)  endend</code></pre><p>By moving the authentication logic to <code>UserAuthenticator</code>, the controller is now cleaner and more focused. It’s like having a dedicated remote for your smart TV – no more accidental channel surfing while trying to adjust the volume.</p><h3 id="ISP-in-Views"><a href="#ISP-in-Views" class="headerlink" title="ISP in Views"></a>ISP in Views</h3><p>Views should also adhere to the Interface Segregation Principle to ensure they can be easily extended without modifying the existing code.</p><h4 id="Example-Rendering-Different-Notification-Types"><a href="#Example-Rendering-Different-Notification-Types" class="headerlink" title="Example: Rendering Different Notification Types"></a>Example: Rendering Different Notification Types</h4><p><strong>Before:</strong></p><pre><code class="erb">&lt;% if notification.type == &#39;success&#39; %&gt;  &lt;div class=&quot;alert alert-success&quot;&gt;&lt;%= notification.message %&gt;&lt;/div&gt;&lt;% elsif notification.type == &#39;error&#39; %&gt;  &lt;div class=&quot;alert alert-danger&quot;&gt;&lt;%= notification.message %&gt;&lt;/div&gt;&lt;% end %&gt;</code></pre><p><strong>After:</strong></p><pre><code class="erb">&lt;%= render &quot;notifications/#&#123;notification.type&#125;&quot;, notification: notification %&gt;</code></pre><pre><code class="erb">&lt;!-- _success.html.erb --&gt;&lt;div class=&quot;alert alert-success&quot;&gt;&lt;%= notification.message %&gt;&lt;/div&gt;&lt;!-- _error.html.erb --&gt;&lt;div class=&quot;alert alert-danger&quot;&gt;&lt;%= notification.message %&gt;&lt;/div&gt;</code></pre><p>With this approach, you can add new notification types without changing the main view file. It’s like having different remotes for different devices – each one fits perfectly without interfering with the others.</p><h3 id="ISP-in-Services"><a href="#ISP-in-Services" class="headerlink" title="ISP in Services"></a>ISP in Services</h3><p>Services can benefit greatly from the Interface Segregation Principle by allowing new functionalities to be added easily.</p><h4 id="Example-Notification-Service"><a href="#Example-Notification-Service" class="headerlink" title="Example: Notification Service"></a>Example: Notification Service</h4><p><strong>Before:</strong></p><pre><code class="ruby">class NotificationService  def send_email(message)    # Send email notification  end  def send_sms(message)    # Send SMS notification  end  def send_push(message)    # Send push notification  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class NotificationService  def send(notification)    notification.send  endendclass EmailNotification  def send(message)    # Send email notification  endendclass SmsNotification  def send(message)    # Send SMS notification  endendclass PushNotification  def send(message)    # Send push notification  endend</code></pre><p>Now you can add new notification types without modifying the <code>NotificationService</code> class. It’s like having different adapters for different devices – each one fits perfectly without altering the others.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Interface Segregation Principle is about keeping your interfaces clean and focused. By applying ISP, you can create more modular and understandable code. It’s like having specific tools for specific tasks, making your life easier and your code more maintainable.</p><p>Stay tuned for more tips on writing clean, efficient, and fun Ruby on Rails code.</p><p>Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/09/isp_in_rails_detailed/interface_segregation_principle.png&quot; class=&quot;&quot; title=&quot;interface_segregation_principle&quot;&gt;
</summary>
      
    
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/categories/Ruby/"/>
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/tags/Ruby/"/>
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Rails" scheme="https://dohungthinhsts.github.io/tags/Rails/"/>
    
    <category term="SOLID" scheme="https://dohungthinhsts.github.io/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>The Liskov Substitution Principle in Rails - Swap Without Fear</title>
    <link href="https://dohungthinhsts.github.io/2024/01/08/lsp_in_rails_detailed/"/>
    <id>https://dohungthinhsts.github.io/2024/01/08/lsp_in_rails_detailed/</id>
    <published>2024-01-08T05:00:00.000Z</published>
    <updated>2024-07-04T13:17:54.039Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/08/lsp_in_rails_detailed/liskov_substitution_principle.png" class="" title="liskov_substitution_principle"></center><br><h2 id="The-Liskov-Substitution-Principle-in-Rails-Swap-Without-Fear"><a href="#The-Liskov-Substitution-Principle-in-Rails-Swap-Without-Fear" class="headerlink" title="The Liskov Substitution Principle in Rails: Swap Without Fear"></a>The Liskov Substitution Principle in Rails: Swap Without Fear</h2><p>Hello Rails developers! Today, we’re diving into the Liskov Substitution Principle (LSP), which is all about ensuring your code can handle swaps without a hitch. Think of it like changing the battery in your remote – the new one should fit perfectly and work just as well as the old one.</p><h3 id="What-is-the-Liskov-Substitution-Principle"><a href="#What-is-the-Liskov-Substitution-Principle" class="headerlink" title="What is the Liskov Substitution Principle?"></a>What is the Liskov Substitution Principle?</h3><p>The Liskov Substitution Principle states that objects of a superclass should be replaceable with objects of a subclass without affecting the functionality of the program. This means your subclasses should be able to stand in for their parent classes without any surprises.</p><h3 id="Why-is-LSP-Important"><a href="#Why-is-LSP-Important" class="headerlink" title="Why is LSP Important?"></a>Why is LSP Important?</h3><p>Following LSP helps make your code more flexible and robust. It’s like having interchangeable parts that fit perfectly every time, making maintenance a breeze.</p><h3 id="LSP-in-Models"><a href="#LSP-in-Models" class="headerlink" title="LSP in Models"></a>LSP in Models</h3><p>Let’s start with models. Imagine you have a <code>Shape</code> class hierarchy with <code>Square</code> and <code>Rectangle</code> subclasses. You should be able to use instances of these subclasses wherever you use the superclass.</p><h4 id="Example-Shape-Hierarchy"><a href="#Example-Shape-Hierarchy" class="headerlink" title="Example: Shape Hierarchy"></a>Example: Shape Hierarchy</h4><p><strong>Before:</strong></p><pre><code class="ruby">class Rectangle  attr_accessor :width, :height  def initialize(width, height)    @width = width    @height = height  end  def area    @width * @height  endendclass Square &lt; Rectangle  def initialize(side)    @width = side    @height = side  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class Shape  def area    raise NotImplementedError, &#39;You must implement the area method&#39;  endendclass Rectangle &lt; Shape  def initialize(width, height)    @width = width    @height = height  end  def area    @width * @height  endendclass Square &lt; Shape  def initialize(side)    @side = side  end  def area    @side * @side  endend</code></pre><p>With this setup, you can use <code>Rectangle</code> and <code>Square</code> objects interchangeably. It’s like having universal batteries that fit any device.</p><h3 id="LSP-in-Controllers"><a href="#LSP-in-Controllers" class="headerlink" title="LSP in Controllers"></a>LSP in Controllers</h3><p>Controllers should also adhere to LSP, allowing you to substitute subclasses without breaking the application.</p><h4 id="Example-Payment-Processing"><a href="#Example-Payment-Processing" class="headerlink" title="Example: Payment Processing"></a>Example: Payment Processing</h4><p><strong>Before:</strong></p><pre><code class="ruby">class PaymentsController &lt; ApplicationController  def process_payment(payment)    if payment.type == &#39;credit_card&#39;      process_credit_card(payment)    elsif payment.type == &#39;paypal&#39;      process_paypal(payment)    end  end  def process_credit_card(payment)    # Credit card processing logic  end  def process_paypal(payment)    # PayPal processing logic  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class PaymentsController &lt; ApplicationController  def process_payment(payment)    payment.process  endendclass Payment  def process    raise NotImplementedError, &#39;You must implement the process method&#39;  endendclass CreditCardPayment &lt; Payment  def process    # Credit card processing logic  endendclass PayPalPayment &lt; Payment  def process    # PayPal processing logic  endend</code></pre><p>Now, you can substitute <code>Payment</code> objects with <code>CreditCardPayment</code> or <code>PayPalPayment</code> without any issues. It’s like having different chargers that fit the same port.</p><h3 id="LSP-in-Views"><a href="#LSP-in-Views" class="headerlink" title="LSP in Views"></a>LSP in Views</h3><p>Views should also adhere to the Liskov Substitution Principle to ensure they can be easily swapped without modifying the existing code.</p><h4 id="Example-Rendering-Different-User-Roles"><a href="#Example-Rendering-Different-User-Roles" class="headerlink" title="Example: Rendering Different User Roles"></a>Example: Rendering Different User Roles</h4><p><strong>Before:</strong></p><pre><code class="erb">&lt;% if user.is_a?(Admin) %&gt;  &lt;div&gt;Welcome, Admin &lt;%= user.name %&gt;!&lt;/div&gt;&lt;% elsif user.is_a?(Guest) %&gt;  &lt;div&gt;Welcome, Guest!&lt;/div&gt;&lt;% end %&gt;</code></pre><p><strong>After:</strong></p><pre><code class="erb">&lt;%= render &quot;users/#&#123;user.role&#125;&quot;, user: user %&gt;</code></pre><pre><code class="erb">&lt;!-- _admin.html.erb --&gt;&lt;div&gt;Welcome, Admin &lt;%= user.name %&gt;!&lt;/div&gt;&lt;!-- _guest.html.erb --&gt;&lt;div&gt;Welcome, Guest!&lt;/div&gt;</code></pre><p>With this approach, you can add new user roles without changing the main view file. It’s like having different covers for the same book – each one fits perfectly without altering the content.</p><h3 id="LSP-in-Services"><a href="#LSP-in-Services" class="headerlink" title="LSP in Services"></a>LSP in Services</h3><p>Services can benefit greatly from the Liskov Substitution Principle by allowing new functionalities to be added easily.</p><h4 id="Example-Notification-Service"><a href="#Example-Notification-Service" class="headerlink" title="Example: Notification Service"></a>Example: Notification Service</h4><p><strong>Before:</strong></p><pre><code class="ruby">class NotificationService  def send(notification_type, message)    if notification_type == &#39;email&#39;      # Send email notification    elsif notification_type == &#39;sms&#39;      # Send SMS notification    end  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class NotificationService  def send(notification)    notification.send  endendclass Notification  def send    raise NotImplementedError, &#39;You must implement the send method&#39;  endendclass EmailNotification &lt; Notification  def send    # Send email notification  endendclass SmsNotification &lt; Notification  def send    # Send SMS notification  endendclass PushNotification &lt; Notification  def send    # Send push notification  endend</code></pre><p>Now you can add new notification types without modifying the <code>NotificationService</code> class. It’s like adding new flavors to your ice cream shop without changing the base recipe.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Liskov Substitution Principle is about ensuring that your subclasses can replace their parent classes without causing any problems. By following LSP, you can create more flexible and maintainable code. It’s like having parts that fit perfectly every time, making your life easier.</p><p>Stay tuned for more tips on writing clean, efficient, and fun Ruby on Rails code.</p><p>Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/08/lsp_in_rails_detailed/liskov_substitution_principle.png&quot; class=&quot;&quot; title=&quot;liskov_substitution_principle&quot;&gt;
&lt;/ce</summary>
      
    
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/categories/Ruby/"/>
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/tags/Ruby/"/>
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Rails" scheme="https://dohungthinhsts.github.io/tags/Rails/"/>
    
    <category term="SOLID" scheme="https://dohungthinhsts.github.io/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>The Open/Closed Principle in Rails - Extend Without Breaking a Sweat</title>
    <link href="https://dohungthinhsts.github.io/2024/01/07/ocp_in_rails_detailed/"/>
    <id>https://dohungthinhsts.github.io/2024/01/07/ocp_in_rails_detailed/</id>
    <published>2024-01-07T05:00:00.000Z</published>
    <updated>2024-07-04T13:17:54.039Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/07/ocp_in_rails_detailed/open_closed_principle.png" class="" title="open_closed_principle"></center><br><h2 id="The-Open-x2F-Closed-Principle-in-Rails-Extend-Without-Breaking-a-Sweat"><a href="#The-Open-x2F-Closed-Principle-in-Rails-Extend-Without-Breaking-a-Sweat" class="headerlink" title="The Open&#x2F;Closed Principle in Rails: Extend Without Breaking a Sweat."></a>The Open&#x2F;Closed Principle in Rails: Extend Without Breaking a Sweat.</h2><p> Hey Rails devs! Today we’re diving into the Open&#x2F;Closed Principle (OCP), which is all about making your code open for extension but closed for modification. Think of it as adding new features to your app without smashing the existing ones, like upgrading your kitchen appliances without remodeling the whole kitchen.</p><h3 id="What-is-the-Open-x2F-Closed-Principle"><a href="#What-is-the-Open-x2F-Closed-Principle" class="headerlink" title="What is the Open&#x2F;Closed Principle?"></a>What is the Open&#x2F;Closed Principle?</h3><p>The Open&#x2F;Closed Principle states that software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. This means you should be able to add new functionality without changing existing code.</p><h3 id="Why-is-OCP-Important"><a href="#Why-is-OCP-Important" class="headerlink" title="Why is OCP Important?"></a>Why is OCP Important?</h3><p>Following OCP helps make your code more flexible and easier to maintain. It’s like having a modular kitchen where you can add new appliances without tearing down the walls. Your code stays neat, organized, and ready for new features.</p><h3 id="OCP-in-Models"><a href="#OCP-in-Models" class="headerlink" title="OCP in Models"></a>OCP in Models</h3><p>Let’s start with models. Imagine you have a <code>Payment</code> model that processes different types of payments. Instead of cramming all the logic into one class, you can use OCP to make it more flexible.</p><h4 id="Example-Payment-Processing"><a href="#Example-Payment-Processing" class="headerlink" title="Example: Payment Processing"></a>Example: Payment Processing</h4><p><strong>Before:</strong></p><pre><code class="ruby">class Payment  def process(type)    if type == &#39;credit_card&#39;      # Process credit card payment    elsif type == &#39;paypal&#39;      # Process PayPal payment    end  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class Payment  def process(payment_method)    payment_method.process  endendclass CreditCardPayment  def process    # Process credit card payment  endendclass PayPalPayment  def process    # Process PayPal payment  endendclass BitcoinPayment  def process    # Process Bitcoin payment  endend</code></pre><p>With this setup, you can add new payment methods without touching the <code>Payment</code> class. It’s like upgrading your kitchen appliances without breaking your countertops.</p><h3 id="OCP-in-Controllers"><a href="#OCP-in-Controllers" class="headerlink" title="OCP in Controllers"></a>OCP in Controllers</h3><p>Controllers often become bloated with various responsibilities. OCP helps keep them clean and focused by allowing you to extend their functionality without modifying them.</p><h4 id="Example-Order-Processing"><a href="#Example-Order-Processing" class="headerlink" title="Example: Order Processing"></a>Example: Order Processing</h4><p><strong>Before:</strong></p><pre><code class="ruby">class OrdersController &lt; ApplicationController  def create    @order = Order.new(order_params)    if @order.save      if @order.payment_type == &#39;credit_card&#39;        # Process credit card payment      elsif @order.payment_type == &#39;paypal&#39;        # Process PayPal payment      end      render json: &#123; message: &#39;Order created successfully&#39; &#125;, status: :created    else      render json: &#123; errors: @order.errors &#125;, status: :unprocessable_entity    end  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class OrdersController &lt; ApplicationController  def create    @order = Order.new(order_params)    if @order.save      payment_processor = PaymentProcessor.new(@order)      payment_processor.process      render json: &#123; message: &#39;Order created successfully&#39; &#125;, status: :created    else      render json: &#123; errors: @order.errors &#125;, status: :unprocessable_entity    end  endend</code></pre><pre><code class="ruby">class PaymentProcessor  def initialize(order)    @order = order  end  def process    case @order.payment_type    when &#39;credit_card&#39;      CreditCardPayment.new.process    when &#39;paypal&#39;      PayPalPayment.new.process    end  endend</code></pre><h3 id="OCP-in-Views"><a href="#OCP-in-Views" class="headerlink" title="OCP in Views"></a>OCP in Views</h3><p>Views should also adhere to the Open&#x2F;Closed Principle to ensure they can be easily extended without modifying the existing code.</p><h4 id="Example-Displaying-Different-Types-of-Notifications"><a href="#Example-Displaying-Different-Types-of-Notifications" class="headerlink" title="Example: Displaying Different Types of Notifications"></a>Example: Displaying Different Types of Notifications</h4><p><strong>Before:</strong></p><pre><code class="erb">&lt;% if notification.type == &#39;success&#39; %&gt;  &lt;div class=&quot;alert alert-success&quot;&gt;&lt;%= notification.message %&gt;&lt;/div&gt;&lt;% elsif notification.type == &#39;error&#39; %&gt;  &lt;div class=&quot;alert alert-danger&quot;&gt;&lt;%= notification.message %&gt;&lt;/div&gt;&lt;% end %&gt;</code></pre><p><strong>After:</strong></p><pre><code class="erb">&lt;%= render &quot;notifications/#&#123;notification.type&#125;&quot;, notification: notification %&gt;</code></pre><pre><code class="erb">&lt;!-- _success.html.erb --&gt;&lt;div class=&quot;alert alert-success&quot;&gt;&lt;%= notification.message %&gt;&lt;/div&gt;&lt;!-- _error.html.erb --&gt;&lt;div class=&quot;alert alert-danger&quot;&gt;&lt;%= notification.message %&gt;&lt;/div&gt;</code></pre><p>With this approach, you can add new notification types without changing the main view file. It’s like adding new decorations to your room without repainting the walls.</p><h3 id="OCP-in-Services"><a href="#OCP-in-Services" class="headerlink" title="OCP in Services"></a>OCP in Services</h3><p>Services can benefit greatly from the Open&#x2F;Closed Principle by allowing new functionalities to be added easily.</p><h4 id="Example-Notification-Service"><a href="#Example-Notification-Service" class="headerlink" title="Example: Notification Service"></a>Example: Notification Service</h4><p><strong>Before:</strong></p><pre><code class="ruby">class NotificationService  def send(notification_type, message)    if notification_type == &#39;email&#39;      # Send email notification    elsif notification_type == &#39;sms&#39;      # Send SMS notification    end  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class NotificationService  def send(notification)    notification.send  endendclass EmailNotification  def send    # Send email notification  endendclass SmsNotification  def send    # Send SMS notification  endendclass PushNotification  def send    # Send push notification  endend</code></pre><p>Now you can add new notification types without modifying the <code>NotificationService</code> class. It’s like adding new tools to your toolbox without rearranging everything.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Open&#x2F;Closed Principle is about keeping your code open for new functionality while being closed to modifications. By applying OCP, you can add new features without worrying about breaking existing code. It’s like adding new tools to your toolbox without having to reorganize everything.</p><p>Stay tuned for more tips on writing clean, efficient, and fun Ruby on Rails code.</p><p>Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/07/ocp_in_rails_detailed/open_closed_principle.png&quot; class=&quot;&quot; title=&quot;open_closed_principle&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2</summary>
      
    
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/categories/Ruby/"/>
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/tags/Ruby/"/>
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Rails" scheme="https://dohungthinhsts.github.io/tags/Rails/"/>
    
    <category term="SOLID" scheme="https://dohungthinhsts.github.io/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>The Single Responsibility Principle in Rails</title>
    <link href="https://dohungthinhsts.github.io/2024/01/06/srp_in_rails/"/>
    <id>https://dohungthinhsts.github.io/2024/01/06/srp_in_rails/</id>
    <published>2024-01-06T05:00:00.000Z</published>
    <updated>2024-07-04T13:17:54.039Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/06/srp_in_rails/single_responsibility.png" class="" title="single_responsibility"></center><br><h2 id="The-Single-Responsibility-Principle-in-Rails"><a href="#The-Single-Responsibility-Principle-in-Rails" class="headerlink" title="The Single Responsibility Principle in Rails."></a>The Single Responsibility Principle in Rails.</h2><p> Welcome, Rails developers! Today, we’re diving into the world of the Single Responsibility Principle (SRP), the first letter in the SOLID acronym. Get ready for an engaging journey filled with humor, insights, and practical examples for each layer of your Rails application.</p><h3 id="What-is-the-Single-Responsibility-Principle-SRP"><a href="#What-is-the-Single-Responsibility-Principle-SRP" class="headerlink" title="What is the Single Responsibility Principle (SRP)?"></a>What is the Single Responsibility Principle (SRP)?</h3><p>The Single Responsibility Principle states that a class should have one, and only one, reason to change. This means that a class should only have one job or responsibility. Think of it as giving your class a clear job title. No one likes a job description that says, “Do everything.”</p><h3 id="Why-is-SRP-Important"><a href="#Why-is-SRP-Important" class="headerlink" title="Why is SRP Important?"></a>Why is SRP Important?</h3><p>Following SRP helps make your codebase more modular, easier to maintain, and less prone to bugs. It’s like having a well-organized kitchen where each utensil has a specific purpose. You wouldn’t use a spatula to cut vegetables, would you?</p><h3 id="SRP-in-Models"><a href="#SRP-in-Models" class="headerlink" title="SRP in Models"></a>SRP in Models</h3><p>Let’s start with models, the backbone of your Rails application. A model should handle database interactions and nothing more. But sometimes, models get burdened with extra responsibilities like validation, callbacks, or even business logic.</p><h4 id="Example-User-Model-with-Too-Many-Responsibilities"><a href="#Example-User-Model-with-Too-Many-Responsibilities" class="headerlink" title="Example: User Model with Too Many Responsibilities"></a>Example: User Model with Too Many Responsibilities</h4><p><strong>Before:</strong></p><pre><code class="ruby">class User &lt; ApplicationRecord  def send_welcome_email    # Code to send welcome email  end  def calculate_age    # Code to calculate user&#39;s age  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class User &lt; ApplicationRecordendclass UserNotifier  def initialize(user)    @user = user  end  def send_welcome_email    # Code to send welcome email  endendclass UserAgeCalculator  def initialize(user)    @user = user  end  def calculate_age    # Code to calculate user&#39;s age  endend</code></pre><p>Now, our <code>User</code> model can focus on database interactions, while <code>UserNotifier</code> and <code>UserAgeCalculator</code> handle their respective tasks. It’s like having a chef, a waiter, and a dishwasher each doing their own job.</p><h3 id="SRP-in-Controllers"><a href="#SRP-in-Controllers" class="headerlink" title="SRP in Controllers"></a>SRP in Controllers</h3><p>Controllers should handle HTTP requests and responses. However, they often get bogged down with business logic or data manipulation.</p><h4 id="Example-UserController-with-Too-Many-Responsibilities"><a href="#Example-UserController-with-Too-Many-Responsibilities" class="headerlink" title="Example: UserController with Too Many Responsibilities"></a>Example: UserController with Too Many Responsibilities</h4><p><strong>Before:</strong></p><pre><code class="ruby">class UsersController &lt; ApplicationController  def create    @user = User.new(user_params)    if @user.save      send_welcome_email(@user)      render json: &#123; message: &#39;User created successfully&#39; &#125;, status: :created    else      render json: &#123; errors: @user.errors &#125;, status: :unprocessable_entity    end  end  private  def send_welcome_email(user)    # Code to send welcome email  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class UsersController &lt; ApplicationController  def create    @user = User.new(user_params)    if @user.save      UserNotifier.new(@user).send_welcome_email      render json: &#123; message: &#39;User created successfully&#39; &#125;, status: :created    else      render json: &#123; errors: @user.errors &#125;, status: :unprocessable_entity    end  endend</code></pre><p>By moving the email sending logic to <code>UserNotifier</code>, our controller is now leaner and cleaner. It’s like having a sous-chef to handle the prep work so the head chef can focus on cooking.</p><h3 id="SRP-in-Views"><a href="#SRP-in-Views" class="headerlink" title="SRP in Views"></a>SRP in Views</h3><p>Views should display data and nothing more. Sometimes, we sneak in logic that doesn’t belong there.</p><h4 id="Example-View-with-Business-Logic"><a href="#Example-View-with-Business-Logic" class="headerlink" title="Example: View with Business Logic"></a>Example: View with Business Logic</h4><p><strong>Before:</strong></p><pre><code class="erb">&lt;% @users.each do |user| %&gt;  &lt;p&gt;    Name: &lt;%= user.name %&gt;&lt;br&gt;    Age: &lt;%= user.age %&gt;    &lt;% if user.age &gt;= 18 %&gt;      &lt;span&gt;(Adult)&lt;/span&gt;    &lt;% else %&gt;      &lt;span&gt;(Minor)&lt;/span&gt;    &lt;% end %&gt;  &lt;/p&gt;&lt;% end %&gt;</code></pre><p><strong>After:</strong></p><pre><code class="erb">&lt;% @users.each do |user| %&gt;  &lt;p&gt;    Name: &lt;%= user.name %&gt;&lt;br&gt;    Age: &lt;%= user.age %&gt;    &lt;%= display_age_group(user) %&gt;  &lt;/p&gt;&lt;% end %&gt;</code></pre><pre><code class="ruby">module UsersHelper  def display_age_group(user)    user.age &gt;= 18 ? &#39;&lt;span&gt;(Adult)&lt;/span&gt;&#39;.html_safe : &#39;&lt;span&gt;(Minor)&lt;/span&gt;&#39;.html_safe  endend</code></pre><p>Moving the age group logic to a helper makes the view simpler and easier to maintain. It’s like putting the finishing touches on a dish without worrying about the recipe.</p><h3 id="SRP-in-Services"><a href="#SRP-in-Services" class="headerlink" title="SRP in Services"></a>SRP in Services</h3><p>Service objects are perfect for encapsulating complex business logic. They can be your secret weapon for keeping your models and controllers slim.</p><h4 id="Example-Payment-Processing-Service"><a href="#Example-Payment-Processing-Service" class="headerlink" title="Example: Payment Processing Service"></a>Example: Payment Processing Service</h4><p><strong>Before:</strong></p><pre><code class="ruby">class OrdersController &lt; ApplicationController  def create    @order = Order.new(order_params)    if @order.save      process_payment(@order)      render json: &#123; message: &#39;Order created successfully&#39; &#125;, status: :created    else      render json: &#123; errors: @order.errors &#125;, status: :unprocessable_entity    end  end  private  def process_payment(order)    # Code to process payment  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class OrdersController &lt; ApplicationController  def create    @order = Order.new(order_params)    if @order.save      PaymentProcessor.new(@order).process      render json: &#123; message: &#39;Order created successfully&#39; &#125;, status: :created    else      render json: &#123; errors: @order.errors &#125;, status: :unprocessable_entity    end  endend</code></pre><pre><code class="ruby">class PaymentProcessor  def initialize(order)    @order = order  end  def process    # Code to process payment  endend</code></pre><p>By moving the payment processing logic to a service object, our controller remains focused on handling HTTP requests. It’s like having a dedicated cashier while the sales staff handles customer service.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Single Responsibility Principle is all about giving each class a clear and focused job. By applying SRP to models, controllers, views, and services, you can keep your Rails application organized and maintainable. Remember, a well-organized kitchen makes for a happy chef!</p><p>Stay tuned for more tips on writing clean, efficient, and enjoyable Ruby on Rails code.</p><p>Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/06/srp_in_rails/single_responsibility.png&quot; class=&quot;&quot; title=&quot;single_responsibility&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;The-</summary>
      
    
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/categories/Ruby/"/>
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/tags/Ruby/"/>
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Rails" scheme="https://dohungthinhsts.github.io/tags/Rails/"/>
    
    <category term="SOLID" scheme="https://dohungthinhsts.github.io/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>SOLID Principles in Ruby on Rails - Part 2</title>
    <link href="https://dohungthinhsts.github.io/2024/01/05/solid_principles_in_rails_part2_fun/"/>
    <id>https://dohungthinhsts.github.io/2024/01/05/solid_principles_in_rails_part2_fun/</id>
    <published>2024-01-05T05:00:00.000Z</published>
    <updated>2024-07-04T13:17:54.038Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/05/solid_principles_in_rails_part2_fun/solid_principles.png" class="" title="solid_principles_part2"></center><br><h2 id="SOLID-Principles-in-Ruby-on-Rails-Part-2"><a href="#SOLID-Principles-in-Ruby-on-Rails-Part-2" class="headerlink" title="SOLID Principles in Ruby on Rails: Part 2."></a>SOLID Principles in Ruby on Rails: Part 2.</h2><p> Welcome back, Ruby enthusiasts! Ready to dive deeper into the magical world of SOLID principles? Grab your coffee (or tea, no judgment here), and let’s make these principles as fun as a weekend hackathon.</p><h3 id="Single-Responsibility-Principle-SRP"><a href="#Single-Responsibility-Principle-SRP" class="headerlink" title="Single Responsibility Principle (SRP)"></a>Single Responsibility Principle (SRP)</h3><h4 id="Example-Separating-User-Notifications"><a href="#Example-Separating-User-Notifications" class="headerlink" title="Example: Separating User Notifications"></a>Example: Separating User Notifications</h4><p>Ever tried to do too many things at once? Your User model feels the same way. Let’s give it a break and let it focus on what it does best: being a User.</p><p><strong>Before:</strong></p><pre><code class="ruby">class User &lt; ApplicationRecord  def send_welcome_email    # Code to send welcome email  end  def send_password_reset    # Code to send password reset email  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class User &lt; ApplicationRecordendclass UserNotifier  def initialize(user)    @user = user  end  def send_welcome_email    # Code to send welcome email  end  def send_password_reset    # Code to send password reset email  endend</code></pre><p>See? Now the User can chill while the UserNotifier handles the communication. It’s like hiring an assistant for your overworked self.</p><h3 id="Open-x2F-Closed-Principle-OCP"><a href="#Open-x2F-Closed-Principle-OCP" class="headerlink" title="Open&#x2F;Closed Principle (OCP)"></a>Open&#x2F;Closed Principle (OCP)</h3><h4 id="Example-Extending-Payment-Methods"><a href="#Example-Extending-Payment-Methods" class="headerlink" title="Example: Extending Payment Methods"></a>Example: Extending Payment Methods</h4><p>Imagine you’re a chef and every time someone orders a new dish, you have to rewrite the entire menu. Sounds exhausting, right? Let’s keep our code open for new dishes but closed for rewriting.</p><p><strong>Before:</strong></p><pre><code class="ruby">class Payment  def process(type)    if type == &#39;credit_card&#39;      # Process credit card payment    elsif type == &#39;paypal&#39;      # Process PayPal payment    end  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class Payment  def process(payment_method)    payment_method.process  endendclass CreditCardPayment  def process    # Process credit card payment  endendclass PayPalPayment  def process    # Process PayPal payment  endendclass BitcoinPayment  def process    # Process Bitcoin payment  endend</code></pre><p>Now you can add new payment methods without touching the Payment class. It’s like adding new recipes to your cookbook without rewriting the whole thing. Bon appétit!</p><h3 id="Liskov-Substitution-Principle-LSP"><a href="#Liskov-Substitution-Principle-LSP" class="headerlink" title="Liskov Substitution Principle (LSP)"></a>Liskov Substitution Principle (LSP)</h3><h4 id="Example-User-Roles"><a href="#Example-User-Roles" class="headerlink" title="Example: User Roles"></a>Example: User Roles</h4><p>Remember that time you tried substituting baking soda for baking powder? Let’s avoid that kind of disaster in our code.</p><p><strong>Before:</strong></p><pre><code class="ruby">class User  def permissions    raise NotImplementedError, &#39;This method should be overridden by subclasses&#39;  endendclass Admin &lt; User  def permissions    &#39;all&#39;  endendclass Guest &lt; User  def permissions    &#39;read&#39;  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class User  def permissions    raise NotImplementedError, &#39;You must implement the permissions method&#39;  endendclass Admin &lt; User  def permissions    &#39;all&#39;  endendclass Guest &lt; User  def permissions    &#39;read&#39;  endend</code></pre><p>Now Admin and Guest can be swapped without any explosions. It’s like using the right ingredients in your favorite recipe.</p><h3 id="Interface-Segregation-Principle-ISP"><a href="#Interface-Segregation-Principle-ISP" class="headerlink" title="Interface Segregation Principle (ISP)"></a>Interface Segregation Principle (ISP)</h3><h4 id="Example-Different-Types-of-Reports"><a href="#Example-Different-Types-of-Reports" class="headerlink" title="Example: Different Types of Reports"></a>Example: Different Types of Reports</h4><p>Ever been forced to buy a whole album when you only like one song? Let’s not do that to our clients. Give them only what they need.</p><p><strong>Before:</strong></p><pre><code class="ruby">class Report  def generate_pdf    # Generate PDF report  end  def generate_csv    # Generate CSV report  end  def generate_html    # Generate HTML report  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class Reportendclass PdfReport &lt; Report  def generate    # Generate PDF report  endendclass CsvReport &lt; Report  def generate    # Generate CSV report  endendclass HtmlReport &lt; Report  def generate    # Generate HTML report  endend</code></pre><p>Now, each report type is a solo act. It’s like creating a custom playlist instead of buying the whole album.</p><h3 id="Dependency-Inversion-Principle-DIP"><a href="#Dependency-Inversion-Principle-DIP" class="headerlink" title="Dependency Inversion Principle (DIP)"></a>Dependency Inversion Principle (DIP)</h3><h4 id="Example-Notifications-System"><a href="#Example-Notifications-System" class="headerlink" title="Example: Notifications System"></a>Example: Notifications System</h4><p>Think of this as choosing the right tool for the job. You wouldn’t use a hammer to fix your laptop, right?</p><p><strong>Before:</strong></p><pre><code class="ruby">class Notification  def send_email(message)    # Send email notification  end  def send_sms(message)    # Send SMS notification  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class Notification  def initialize(sender)    @sender = sender  end  def send(message)    @sender.send(message)  endendclass EmailSender  def send(message)    # Send email notification  endendclass SmsSender  def send(message)    # Send SMS notification  endendclass PushNotificationSender  def send(message)    # Send push notification  endend</code></pre><p>Now you can easily switch between email, SMS, and push notifications. It’s like having a multi-tool in your coding toolbox.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Implementing SOLID principles in your Rails applications doesn’t have to be a chore. By following these guidelines with a bit of creativity and humor, you can make your code more maintainable and enjoyable to work with.</p><p>Stay tuned for more tips on writing clean, efficient, and fun Ruby on Rails code.</p><p>Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/05/solid_principles_in_rails_part2_fun/solid_principles.png&quot; class=&quot;&quot; title=&quot;solid_principles_part2&quot;&gt;
&lt;/center&gt;
</summary>
      
    
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/categories/Ruby/"/>
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/tags/Ruby/"/>
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Rails" scheme="https://dohungthinhsts.github.io/tags/Rails/"/>
    
    <category term="SOLID" scheme="https://dohungthinhsts.github.io/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>Understanding SOLID Principles in Ruby on Rails</title>
    <link href="https://dohungthinhsts.github.io/2024/01/04/solid_principles_in_rails/"/>
    <id>https://dohungthinhsts.github.io/2024/01/04/solid_principles_in_rails/</id>
    <published>2024-01-04T05:00:00.000Z</published>
    <updated>2024-07-04T13:17:54.038Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/04/solid_principles_in_rails/solid_principles.png" class="" title="solid_principles"></center><br><h2 id="Understanding-SOLID-Principles-in-Ruby-on-Rails"><a href="#Understanding-SOLID-Principles-in-Ruby-on-Rails" class="headerlink" title="Understanding SOLID Principles in Ruby on Rails."></a>Understanding SOLID Principles in Ruby on Rails.</h2><p> SOLID principles are a set of design guidelines that help developers create more maintainable, understandable, and flexible software. These principles are especially valuable in Ruby on Rails projects, where code can quickly become complex. In this blog post, we’ll explore each of the SOLID principles and provide examples of how you can apply them in your Rails applications.</p><h3 id="S-Single-Responsibility-Principle-SRP"><a href="#S-Single-Responsibility-Principle-SRP" class="headerlink" title="S - Single Responsibility Principle (SRP)"></a>S - Single Responsibility Principle (SRP)</h3><p>The Single Responsibility Principle states that a class should have only one reason to change. This means that a class should only have one job or responsibility.</p><h4 id="Example-in-Rails"><a href="#Example-in-Rails" class="headerlink" title="Example in Rails:"></a>Example in Rails:</h4><p>Suppose you have a <code>User</code> model that handles user authentication and profile management. This violates SRP because the class has more than one responsibility. Let’s refactor it.</p><p><strong>Before:</strong></p><pre><code class="ruby">class User &lt; ApplicationRecord  def authenticate(password)    # Authentication logic  end  def update_profile(params)    # Profile update logic  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class User &lt; ApplicationRecordendclass UserAuthenticator  def initialize(user)    @user = user  end  def authenticate(password)    # Authentication logic  endendclass UserProfileUpdater  def initialize(user)    @user = user  end  def update_profile(params)    # Profile update logic  endend</code></pre><h3 id="O-Open-x2F-Closed-Principle-OCP"><a href="#O-Open-x2F-Closed-Principle-OCP" class="headerlink" title="O - Open&#x2F;Closed Principle (OCP)"></a>O - Open&#x2F;Closed Principle (OCP)</h3><p>The Open&#x2F;Closed Principle states that software entities should be open for extension but closed for modification. This means you should be able to add new functionality without changing existing code.</p><h4 id="Example-in-Rails-1"><a href="#Example-in-Rails-1" class="headerlink" title="Example in Rails:"></a>Example in Rails:</h4><p>Consider a <code>Payment</code> class that processes different types of payments.</p><p><strong>Before:</strong></p><pre><code class="ruby">class Payment  def process(type)    if type == &#39;credit_card&#39;      # Process credit card payment    elsif type == &#39;paypal&#39;      # Process PayPal payment    end  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class Payment  def process(payment_method)    payment_method.process  endendclass CreditCardPayment  def process    # Process credit card payment  endendclass PayPalPayment  def process    # Process PayPal payment  endend</code></pre><h3 id="L-Liskov-Substitution-Principle-LSP"><a href="#L-Liskov-Substitution-Principle-LSP" class="headerlink" title="L - Liskov Substitution Principle (LSP)"></a>L - Liskov Substitution Principle (LSP)</h3><p>The Liskov Substitution Principle states that objects of a superclass should be replaceable with objects of a subclass without affecting the functionality of the program.</p><h4 id="Example-in-Rails-2"><a href="#Example-in-Rails-2" class="headerlink" title="Example in Rails:"></a>Example in Rails:</h4><p>Imagine a <code>Shape</code> class hierarchy where <code>Square</code> and <code>Rectangle</code> are subclasses.</p><p><strong>Before:</strong></p><pre><code class="ruby">class Rectangle  attr_accessor :width, :height  def initialize(width, height)    @width = width    @height = height  end  def area    @width * @height  endendclass Square &lt; Rectangle  def initialize(side)    @width = side    @height = side  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class Shape  def area    raise NotImplementedError, &#39;You must implement the area method&#39;  endendclass Rectangle &lt; Shape  def initialize(width, height)    @width = width    @height = height  end  def area    @width * @height  endendclass Square &lt; Shape  def initialize(side)    @side = side  end  def area    @side * @side  endend</code></pre><h3 id="I-Interface-Segregation-Principle-ISP"><a href="#I-Interface-Segregation-Principle-ISP" class="headerlink" title="I - Interface Segregation Principle (ISP)"></a>I - Interface Segregation Principle (ISP)</h3><p>The Interface Segregation Principle states that no client should be forced to depend on methods it does not use. This means creating specific interfaces for different clients.</p><h4 id="Example-in-Rails-3"><a href="#Example-in-Rails-3" class="headerlink" title="Example in Rails:"></a>Example in Rails:</h4><p>Suppose you have a <code>Report</code> class that generates different types of reports.</p><p><strong>Before:</strong></p><pre><code class="ruby">class Report  def generate_pdf    # Generate PDF report  end  def generate_csv    # Generate CSV report  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class Reportendclass PdfReport &lt; Report  def generate    # Generate PDF report  endendclass CsvReport &lt; Report  def generate    # Generate CSV report  endend</code></pre><h3 id="D-Dependency-Inversion-Principle-DIP"><a href="#D-Dependency-Inversion-Principle-DIP" class="headerlink" title="D - Dependency Inversion Principle (DIP)"></a>D - Dependency Inversion Principle (DIP)</h3><p>The Dependency Inversion Principle states that high-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.</p><h4 id="Example-in-Rails-4"><a href="#Example-in-Rails-4" class="headerlink" title="Example in Rails:"></a>Example in Rails:</h4><p>Consider a <code>Notification</code> class that sends different types of notifications.</p><p><strong>Before:</strong></p><pre><code class="ruby">class Notification  def send_email(message)    # Send email notification  end  def send_sms(message)    # Send SMS notification  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class Notification  def initialize(sender)    @sender = sender  end  def send(message)    @sender.send(message)  endendclass EmailSender  def send(message)    # Send email notification  endendclass SmsSender  def send(message)    # Send SMS notification  endend</code></pre><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Applying SOLID principles in your Ruby on Rails projects can significantly improve the maintainability and flexibility of your code. By following these guidelines, you can create software that is easier to understand, extend, and modify, ultimately leading to better and more robust applications.</p><p>Lo Code Đi Kẻo Sếp nạt!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/04/solid_principles_in_rails/solid_principles.png&quot; class=&quot;&quot; title=&quot;solid_principles&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;U</summary>
      
    
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/categories/Ruby/"/>
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/tags/Ruby/"/>
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Rails" scheme="https://dohungthinhsts.github.io/tags/Rails/"/>
    
    <category term="SOLID" scheme="https://dohungthinhsts.github.io/tags/SOLID/"/>
    
  </entry>
  
</feed>
