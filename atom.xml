<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://dohungthinhsts.github.io/atom.xml" rel="self"/>
  
  <link href="https://dohungthinhsts.github.io/"/>
  <updated>2024-07-04T11:36:19.172Z</updated>
  <id>https://dohungthinhsts.github.io/</id>
  
  <author>
    <name>ThinhDo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The Open/Closed Principle in Rails - Extend Without Breaking a Sweat</title>
    <link href="https://dohungthinhsts.github.io/2024/01/07/ocp_in_rails_detailed/"/>
    <id>https://dohungthinhsts.github.io/2024/01/07/ocp_in_rails_detailed/</id>
    <published>2024-01-07T05:00:00.000Z</published>
    <updated>2024-07-04T11:36:19.172Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/07/ocp_in_rails_detailed/open_closed_principle.png" class="" title="open_closed_principle"></center><br><h2 id="The-Open-x2F-Closed-Principle-in-Rails-Extend-Without-Breaking-a-Sweat"><a href="#The-Open-x2F-Closed-Principle-in-Rails-Extend-Without-Breaking-a-Sweat" class="headerlink" title="The Open&#x2F;Closed Principle in Rails: Extend Without Breaking a Sweat."></a>The Open&#x2F;Closed Principle in Rails: Extend Without Breaking a Sweat.</h2><p> Hey Rails devs! Today we’re diving into the Open&#x2F;Closed Principle (OCP), which is all about making your code open for extension but closed for modification. Think of it as adding new features to your app without smashing the existing ones, like upgrading your kitchen appliances without remodeling the whole kitchen.</p><h3 id="What-is-the-Open-x2F-Closed-Principle"><a href="#What-is-the-Open-x2F-Closed-Principle" class="headerlink" title="What is the Open&#x2F;Closed Principle?"></a>What is the Open&#x2F;Closed Principle?</h3><p>The Open&#x2F;Closed Principle states that software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. This means you should be able to add new functionality without changing existing code.</p><h3 id="Why-is-OCP-Important"><a href="#Why-is-OCP-Important" class="headerlink" title="Why is OCP Important?"></a>Why is OCP Important?</h3><p>Following OCP helps make your code more flexible and easier to maintain. It’s like having a modular kitchen where you can add new appliances without tearing down the walls. Your code stays neat, organized, and ready for new features.</p><h3 id="OCP-in-Models"><a href="#OCP-in-Models" class="headerlink" title="OCP in Models"></a>OCP in Models</h3><p>Let’s start with models. Imagine you have a <code>Payment</code> model that processes different types of payments. Instead of cramming all the logic into one class, you can use OCP to make it more flexible.</p><h4 id="Example-Payment-Processing"><a href="#Example-Payment-Processing" class="headerlink" title="Example: Payment Processing"></a>Example: Payment Processing</h4><p><strong>Before:</strong></p><pre><code class="ruby">class Payment  def process(type)    if type == &#39;credit_card&#39;      # Process credit card payment    elsif type == &#39;paypal&#39;      # Process PayPal payment    end  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class Payment  def process(payment_method)    payment_method.process  endendclass CreditCardPayment  def process    # Process credit card payment  endendclass PayPalPayment  def process    # Process PayPal payment  endendclass BitcoinPayment  def process    # Process Bitcoin payment  endend</code></pre><p>With this setup, you can add new payment methods without touching the <code>Payment</code> class. It’s like upgrading your kitchen appliances without breaking your countertops.</p><h3 id="OCP-in-Controllers"><a href="#OCP-in-Controllers" class="headerlink" title="OCP in Controllers"></a>OCP in Controllers</h3><p>Controllers often become bloated with various responsibilities. OCP helps keep them clean and focused by allowing you to extend their functionality without modifying them.</p><h4 id="Example-Order-Processing"><a href="#Example-Order-Processing" class="headerlink" title="Example: Order Processing"></a>Example: Order Processing</h4><p><strong>Before:</strong></p><pre><code class="ruby">class OrdersController &lt; ApplicationController  def create    @order = Order.new(order_params)    if @order.save      if @order.payment_type == &#39;credit_card&#39;        # Process credit card payment      elsif @order.payment_type == &#39;paypal&#39;        # Process PayPal payment      end      render json: &#123; message: &#39;Order created successfully&#39; &#125;, status: :created    else      render json: &#123; errors: @order.errors &#125;, status: :unprocessable_entity    end  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class OrdersController &lt; ApplicationController  def create    @order = Order.new(order_params)    if @order.save      payment_processor = PaymentProcessor.new(@order)      payment_processor.process      render json: &#123; message: &#39;Order created successfully&#39; &#125;, status: :created    else      render json: &#123; errors: @order.errors &#125;, status: :unprocessable_entity    end  endend</code></pre><pre><code class="ruby">class PaymentProcessor  def initialize(order)    @order = order  end  def process    case @order.payment_type    when &#39;credit_card&#39;      CreditCardPayment.new.process    when &#39;paypal&#39;      PayPalPayment.new.process    end  endend</code></pre><h3 id="OCP-in-Views"><a href="#OCP-in-Views" class="headerlink" title="OCP in Views"></a>OCP in Views</h3><p>Views should also adhere to the Open&#x2F;Closed Principle to ensure they can be easily extended without modifying the existing code.</p><h4 id="Example-Displaying-Different-Types-of-Notifications"><a href="#Example-Displaying-Different-Types-of-Notifications" class="headerlink" title="Example: Displaying Different Types of Notifications"></a>Example: Displaying Different Types of Notifications</h4><p><strong>Before:</strong></p><pre><code class="erb">&lt;% if notification.type == &#39;success&#39; %&gt;  &lt;div class=&quot;alert alert-success&quot;&gt;&lt;%= notification.message %&gt;&lt;/div&gt;&lt;% elsif notification.type == &#39;error&#39; %&gt;  &lt;div class=&quot;alert alert-danger&quot;&gt;&lt;%= notification.message %&gt;&lt;/div&gt;&lt;% end %&gt;</code></pre><p><strong>After:</strong></p><pre><code class="erb">&lt;%= render &quot;notifications/#&#123;notification.type&#125;&quot;, notification: notification %&gt;</code></pre><pre><code class="erb">&lt;!-- _success.html.erb --&gt;&lt;div class=&quot;alert alert-success&quot;&gt;&lt;%= notification.message %&gt;&lt;/div&gt;&lt;!-- _error.html.erb --&gt;&lt;div class=&quot;alert alert-danger&quot;&gt;&lt;%= notification.message %&gt;&lt;/div&gt;</code></pre><p>With this approach, you can add new notification types without changing the main view file. It’s like adding new decorations to your room without repainting the walls.</p><h3 id="OCP-in-Services"><a href="#OCP-in-Services" class="headerlink" title="OCP in Services"></a>OCP in Services</h3><p>Services can benefit greatly from the Open&#x2F;Closed Principle by allowing new functionalities to be added easily.</p><h4 id="Example-Notification-Service"><a href="#Example-Notification-Service" class="headerlink" title="Example: Notification Service"></a>Example: Notification Service</h4><p><strong>Before:</strong></p><pre><code class="ruby">class NotificationService  def send(notification_type, message)    if notification_type == &#39;email&#39;      # Send email notification    elsif notification_type == &#39;sms&#39;      # Send SMS notification    end  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class NotificationService  def send(notification)    notification.send  endendclass EmailNotification  def send    # Send email notification  endendclass SmsNotification  def send    # Send SMS notification  endendclass PushNotification  def send    # Send push notification  endend</code></pre><p>Now you can add new notification types without modifying the <code>NotificationService</code> class. It’s like adding new tools to your toolbox without rearranging everything.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Open&#x2F;Closed Principle is about keeping your code open for new functionality while being closed to modifications. By applying OCP, you can add new features without worrying about breaking existing code. It’s like adding new tools to your toolbox without having to reorganize everything.</p><p>Stay tuned for more tips on writing clean, efficient, and fun Ruby on Rails code.</p><p>Happy coding!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/07/ocp_in_rails_detailed/open_closed_principle.png&quot; class=&quot;&quot; title=&quot;open_closed_principle&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2</summary>
      
    
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/categories/Ruby/"/>
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/tags/Ruby/"/>
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Rails" scheme="https://dohungthinhsts.github.io/tags/Rails/"/>
    
    <category term="SOLID" scheme="https://dohungthinhsts.github.io/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>The Single Responsibility Principle in Rails</title>
    <link href="https://dohungthinhsts.github.io/2024/01/06/srp_in_rails/"/>
    <id>https://dohungthinhsts.github.io/2024/01/06/srp_in_rails/</id>
    <published>2024-01-06T05:00:00.000Z</published>
    <updated>2024-07-04T11:06:31.540Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/06/srp_in_rails/single_responsibility.png" class="" title="single_responsibility"></center><br><h2 id="The-Single-Responsibility-Principle-in-Rails"><a href="#The-Single-Responsibility-Principle-in-Rails" class="headerlink" title="The Single Responsibility Principle in Rails."></a>The Single Responsibility Principle in Rails.</h2><p> Welcome, Rails developers! Today, we’re diving into the world of the Single Responsibility Principle (SRP), the first letter in the SOLID acronym. Get ready for an engaging journey filled with humor, insights, and practical examples for each layer of your Rails application.</p><h3 id="What-is-the-Single-Responsibility-Principle-SRP"><a href="#What-is-the-Single-Responsibility-Principle-SRP" class="headerlink" title="What is the Single Responsibility Principle (SRP)?"></a>What is the Single Responsibility Principle (SRP)?</h3><p>The Single Responsibility Principle states that a class should have one, and only one, reason to change. This means that a class should only have one job or responsibility. Think of it as giving your class a clear job title. No one likes a job description that says, “Do everything.”</p><h3 id="Why-is-SRP-Important"><a href="#Why-is-SRP-Important" class="headerlink" title="Why is SRP Important?"></a>Why is SRP Important?</h3><p>Following SRP helps make your codebase more modular, easier to maintain, and less prone to bugs. It’s like having a well-organized kitchen where each utensil has a specific purpose. You wouldn’t use a spatula to cut vegetables, would you?</p><h3 id="SRP-in-Models"><a href="#SRP-in-Models" class="headerlink" title="SRP in Models"></a>SRP in Models</h3><p>Let’s start with models, the backbone of your Rails application. A model should handle database interactions and nothing more. But sometimes, models get burdened with extra responsibilities like validation, callbacks, or even business logic.</p><h4 id="Example-User-Model-with-Too-Many-Responsibilities"><a href="#Example-User-Model-with-Too-Many-Responsibilities" class="headerlink" title="Example: User Model with Too Many Responsibilities"></a>Example: User Model with Too Many Responsibilities</h4><p><strong>Before:</strong></p><pre><code class="ruby">class User &lt; ApplicationRecord  def send_welcome_email    # Code to send welcome email  end  def calculate_age    # Code to calculate user&#39;s age  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class User &lt; ApplicationRecordendclass UserNotifier  def initialize(user)    @user = user  end  def send_welcome_email    # Code to send welcome email  endendclass UserAgeCalculator  def initialize(user)    @user = user  end  def calculate_age    # Code to calculate user&#39;s age  endend</code></pre><p>Now, our <code>User</code> model can focus on database interactions, while <code>UserNotifier</code> and <code>UserAgeCalculator</code> handle their respective tasks. It’s like having a chef, a waiter, and a dishwasher each doing their own job.</p><h3 id="SRP-in-Controllers"><a href="#SRP-in-Controllers" class="headerlink" title="SRP in Controllers"></a>SRP in Controllers</h3><p>Controllers should handle HTTP requests and responses. However, they often get bogged down with business logic or data manipulation.</p><h4 id="Example-UserController-with-Too-Many-Responsibilities"><a href="#Example-UserController-with-Too-Many-Responsibilities" class="headerlink" title="Example: UserController with Too Many Responsibilities"></a>Example: UserController with Too Many Responsibilities</h4><p><strong>Before:</strong></p><pre><code class="ruby">class UsersController &lt; ApplicationController  def create    @user = User.new(user_params)    if @user.save      send_welcome_email(@user)      render json: &#123; message: &#39;User created successfully&#39; &#125;, status: :created    else      render json: &#123; errors: @user.errors &#125;, status: :unprocessable_entity    end  end  private  def send_welcome_email(user)    # Code to send welcome email  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class UsersController &lt; ApplicationController  def create    @user = User.new(user_params)    if @user.save      UserNotifier.new(@user).send_welcome_email      render json: &#123; message: &#39;User created successfully&#39; &#125;, status: :created    else      render json: &#123; errors: @user.errors &#125;, status: :unprocessable_entity    end  endend</code></pre><p>By moving the email sending logic to <code>UserNotifier</code>, our controller is now leaner and cleaner. It’s like having a sous-chef to handle the prep work so the head chef can focus on cooking.</p><h3 id="SRP-in-Views"><a href="#SRP-in-Views" class="headerlink" title="SRP in Views"></a>SRP in Views</h3><p>Views should display data and nothing more. Sometimes, we sneak in logic that doesn’t belong there.</p><h4 id="Example-View-with-Business-Logic"><a href="#Example-View-with-Business-Logic" class="headerlink" title="Example: View with Business Logic"></a>Example: View with Business Logic</h4><p><strong>Before:</strong></p><pre><code class="erb">&lt;% @users.each do |user| %&gt;  &lt;p&gt;    Name: &lt;%= user.name %&gt;&lt;br&gt;    Age: &lt;%= user.age %&gt;    &lt;% if user.age &gt;= 18 %&gt;      &lt;span&gt;(Adult)&lt;/span&gt;    &lt;% else %&gt;      &lt;span&gt;(Minor)&lt;/span&gt;    &lt;% end %&gt;  &lt;/p&gt;&lt;% end %&gt;</code></pre><p><strong>After:</strong></p><pre><code class="erb">&lt;% @users.each do |user| %&gt;  &lt;p&gt;    Name: &lt;%= user.name %&gt;&lt;br&gt;    Age: &lt;%= user.age %&gt;    &lt;%= display_age_group(user) %&gt;  &lt;/p&gt;&lt;% end %&gt;</code></pre><pre><code class="ruby">module UsersHelper  def display_age_group(user)    user.age &gt;= 18 ? &#39;&lt;span&gt;(Adult)&lt;/span&gt;&#39;.html_safe : &#39;&lt;span&gt;(Minor)&lt;/span&gt;&#39;.html_safe  endend</code></pre><p>Moving the age group logic to a helper makes the view simpler and easier to maintain. It’s like putting the finishing touches on a dish without worrying about the recipe.</p><h3 id="SRP-in-Services"><a href="#SRP-in-Services" class="headerlink" title="SRP in Services"></a>SRP in Services</h3><p>Service objects are perfect for encapsulating complex business logic. They can be your secret weapon for keeping your models and controllers slim.</p><h4 id="Example-Payment-Processing-Service"><a href="#Example-Payment-Processing-Service" class="headerlink" title="Example: Payment Processing Service"></a>Example: Payment Processing Service</h4><p><strong>Before:</strong></p><pre><code class="ruby">class OrdersController &lt; ApplicationController  def create    @order = Order.new(order_params)    if @order.save      process_payment(@order)      render json: &#123; message: &#39;Order created successfully&#39; &#125;, status: :created    else      render json: &#123; errors: @order.errors &#125;, status: :unprocessable_entity    end  end  private  def process_payment(order)    # Code to process payment  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class OrdersController &lt; ApplicationController  def create    @order = Order.new(order_params)    if @order.save      PaymentProcessor.new(@order).process      render json: &#123; message: &#39;Order created successfully&#39; &#125;, status: :created    else      render json: &#123; errors: @order.errors &#125;, status: :unprocessable_entity    end  endend</code></pre><pre><code class="ruby">class PaymentProcessor  def initialize(order)    @order = order  end  def process    # Code to process payment  endend</code></pre><p>By moving the payment processing logic to a service object, our controller remains focused on handling HTTP requests. It’s like having a dedicated cashier while the sales staff handles customer service.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The Single Responsibility Principle is all about giving each class a clear and focused job. By applying SRP to models, controllers, views, and services, you can keep your Rails application organized and maintainable. Remember, a well-organized kitchen makes for a happy chef!</p><p>Stay tuned for more tips on writing clean, efficient, and enjoyable Ruby on Rails code.</p><p>Happy coding!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/06/srp_in_rails/single_responsibility.png&quot; class=&quot;&quot; title=&quot;single_responsibility&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;The-</summary>
      
    
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/categories/Ruby/"/>
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/tags/Ruby/"/>
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Rails" scheme="https://dohungthinhsts.github.io/tags/Rails/"/>
    
    <category term="SOLID" scheme="https://dohungthinhsts.github.io/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>SOLID Principles in Ruby on Rails - Part 2</title>
    <link href="https://dohungthinhsts.github.io/2024/01/05/solid_principles_in_rails_part2_fun/"/>
    <id>https://dohungthinhsts.github.io/2024/01/05/solid_principles_in_rails_part2_fun/</id>
    <published>2024-01-05T05:00:00.000Z</published>
    <updated>2024-07-04T10:56:46.566Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/05/solid_principles_in_rails_part2_fun/solid_principles.png" class="" title="solid_principles_part2"></center><br><h2 id="SOLID-Principles-in-Ruby-on-Rails-Part-2"><a href="#SOLID-Principles-in-Ruby-on-Rails-Part-2" class="headerlink" title="SOLID Principles in Ruby on Rails: Part 2."></a>SOLID Principles in Ruby on Rails: Part 2.</h2><p> Welcome back, Ruby enthusiasts! Ready to dive deeper into the magical world of SOLID principles? Grab your coffee (or tea, no judgment here), and let’s make these principles as fun as a weekend hackathon.</p><h3 id="Single-Responsibility-Principle-SRP"><a href="#Single-Responsibility-Principle-SRP" class="headerlink" title="Single Responsibility Principle (SRP)"></a>Single Responsibility Principle (SRP)</h3><h4 id="Example-Separating-User-Notifications"><a href="#Example-Separating-User-Notifications" class="headerlink" title="Example: Separating User Notifications"></a>Example: Separating User Notifications</h4><p>Ever tried to do too many things at once? Your User model feels the same way. Let’s give it a break and let it focus on what it does best: being a User.</p><p><strong>Before:</strong></p><pre><code class="ruby">class User &lt; ApplicationRecord  def send_welcome_email    # Code to send welcome email  end  def send_password_reset    # Code to send password reset email  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class User &lt; ApplicationRecordendclass UserNotifier  def initialize(user)    @user = user  end  def send_welcome_email    # Code to send welcome email  end  def send_password_reset    # Code to send password reset email  endend</code></pre><p>See? Now the User can chill while the UserNotifier handles the communication. It’s like hiring an assistant for your overworked self.</p><h3 id="Open-x2F-Closed-Principle-OCP"><a href="#Open-x2F-Closed-Principle-OCP" class="headerlink" title="Open&#x2F;Closed Principle (OCP)"></a>Open&#x2F;Closed Principle (OCP)</h3><h4 id="Example-Extending-Payment-Methods"><a href="#Example-Extending-Payment-Methods" class="headerlink" title="Example: Extending Payment Methods"></a>Example: Extending Payment Methods</h4><p>Imagine you’re a chef and every time someone orders a new dish, you have to rewrite the entire menu. Sounds exhausting, right? Let’s keep our code open for new dishes but closed for rewriting.</p><p><strong>Before:</strong></p><pre><code class="ruby">class Payment  def process(type)    if type == &#39;credit_card&#39;      # Process credit card payment    elsif type == &#39;paypal&#39;      # Process PayPal payment    end  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class Payment  def process(payment_method)    payment_method.process  endendclass CreditCardPayment  def process    # Process credit card payment  endendclass PayPalPayment  def process    # Process PayPal payment  endendclass BitcoinPayment  def process    # Process Bitcoin payment  endend</code></pre><p>Now you can add new payment methods without touching the Payment class. It’s like adding new recipes to your cookbook without rewriting the whole thing. Bon appétit!</p><h3 id="Liskov-Substitution-Principle-LSP"><a href="#Liskov-Substitution-Principle-LSP" class="headerlink" title="Liskov Substitution Principle (LSP)"></a>Liskov Substitution Principle (LSP)</h3><h4 id="Example-User-Roles"><a href="#Example-User-Roles" class="headerlink" title="Example: User Roles"></a>Example: User Roles</h4><p>Remember that time you tried substituting baking soda for baking powder? Let’s avoid that kind of disaster in our code.</p><p><strong>Before:</strong></p><pre><code class="ruby">class User  def permissions    raise NotImplementedError, &#39;This method should be overridden by subclasses&#39;  endendclass Admin &lt; User  def permissions    &#39;all&#39;  endendclass Guest &lt; User  def permissions    &#39;read&#39;  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class User  def permissions    raise NotImplementedError, &#39;You must implement the permissions method&#39;  endendclass Admin &lt; User  def permissions    &#39;all&#39;  endendclass Guest &lt; User  def permissions    &#39;read&#39;  endend</code></pre><p>Now Admin and Guest can be swapped without any explosions. It’s like using the right ingredients in your favorite recipe.</p><h3 id="Interface-Segregation-Principle-ISP"><a href="#Interface-Segregation-Principle-ISP" class="headerlink" title="Interface Segregation Principle (ISP)"></a>Interface Segregation Principle (ISP)</h3><h4 id="Example-Different-Types-of-Reports"><a href="#Example-Different-Types-of-Reports" class="headerlink" title="Example: Different Types of Reports"></a>Example: Different Types of Reports</h4><p>Ever been forced to buy a whole album when you only like one song? Let’s not do that to our clients. Give them only what they need.</p><p><strong>Before:</strong></p><pre><code class="ruby">class Report  def generate_pdf    # Generate PDF report  end  def generate_csv    # Generate CSV report  end  def generate_html    # Generate HTML report  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class Reportendclass PdfReport &lt; Report  def generate    # Generate PDF report  endendclass CsvReport &lt; Report  def generate    # Generate CSV report  endendclass HtmlReport &lt; Report  def generate    # Generate HTML report  endend</code></pre><p>Now, each report type is a solo act. It’s like creating a custom playlist instead of buying the whole album.</p><h3 id="Dependency-Inversion-Principle-DIP"><a href="#Dependency-Inversion-Principle-DIP" class="headerlink" title="Dependency Inversion Principle (DIP)"></a>Dependency Inversion Principle (DIP)</h3><h4 id="Example-Notifications-System"><a href="#Example-Notifications-System" class="headerlink" title="Example: Notifications System"></a>Example: Notifications System</h4><p>Think of this as choosing the right tool for the job. You wouldn’t use a hammer to fix your laptop, right?</p><p><strong>Before:</strong></p><pre><code class="ruby">class Notification  def send_email(message)    # Send email notification  end  def send_sms(message)    # Send SMS notification  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class Notification  def initialize(sender)    @sender = sender  end  def send(message)    @sender.send(message)  endendclass EmailSender  def send(message)    # Send email notification  endendclass SmsSender  def send(message)    # Send SMS notification  endendclass PushNotificationSender  def send(message)    # Send push notification  endend</code></pre><p>Now you can easily switch between email, SMS, and push notifications. It’s like having a multi-tool in your coding toolbox.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Implementing SOLID principles in your Rails applications doesn’t have to be a chore. By following these guidelines with a bit of creativity and humor, you can make your code more maintainable and enjoyable to work with.</p><p>Stay tuned for more tips on writing clean, efficient, and fun Ruby on Rails code.</p><p>Happy coding!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/05/solid_principles_in_rails_part2_fun/solid_principles.png&quot; class=&quot;&quot; title=&quot;solid_principles_part2&quot;&gt;
&lt;/center&gt;
</summary>
      
    
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/categories/Ruby/"/>
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/tags/Ruby/"/>
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Rails" scheme="https://dohungthinhsts.github.io/tags/Rails/"/>
    
    <category term="SOLID" scheme="https://dohungthinhsts.github.io/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>Understanding SOLID Principles in Ruby on Rails</title>
    <link href="https://dohungthinhsts.github.io/2024/01/04/solid_principles_in_rails/"/>
    <id>https://dohungthinhsts.github.io/2024/01/04/solid_principles_in_rails/</id>
    <published>2024-01-04T05:00:00.000Z</published>
    <updated>2024-07-04T10:45:14.749Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/04/solid_principles_in_rails/solid_principles.png" class="" title="solid_principles"></center><br><h2 id="Understanding-SOLID-Principles-in-Ruby-on-Rails"><a href="#Understanding-SOLID-Principles-in-Ruby-on-Rails" class="headerlink" title="Understanding SOLID Principles in Ruby on Rails."></a>Understanding SOLID Principles in Ruby on Rails.</h2><p> SOLID principles are a set of design guidelines that help developers create more maintainable, understandable, and flexible software. These principles are especially valuable in Ruby on Rails projects, where code can quickly become complex. In this blog post, we’ll explore each of the SOLID principles and provide examples of how you can apply them in your Rails applications.</p><h3 id="S-Single-Responsibility-Principle-SRP"><a href="#S-Single-Responsibility-Principle-SRP" class="headerlink" title="S - Single Responsibility Principle (SRP)"></a>S - Single Responsibility Principle (SRP)</h3><p>The Single Responsibility Principle states that a class should have only one reason to change. This means that a class should only have one job or responsibility.</p><h4 id="Example-in-Rails"><a href="#Example-in-Rails" class="headerlink" title="Example in Rails:"></a>Example in Rails:</h4><p>Suppose you have a <code>User</code> model that handles user authentication and profile management. This violates SRP because the class has more than one responsibility. Let’s refactor it.</p><p><strong>Before:</strong></p><pre><code class="ruby">class User &lt; ApplicationRecord  def authenticate(password)    # Authentication logic  end  def update_profile(params)    # Profile update logic  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class User &lt; ApplicationRecordendclass UserAuthenticator  def initialize(user)    @user = user  end  def authenticate(password)    # Authentication logic  endendclass UserProfileUpdater  def initialize(user)    @user = user  end  def update_profile(params)    # Profile update logic  endend</code></pre><h3 id="O-Open-x2F-Closed-Principle-OCP"><a href="#O-Open-x2F-Closed-Principle-OCP" class="headerlink" title="O - Open&#x2F;Closed Principle (OCP)"></a>O - Open&#x2F;Closed Principle (OCP)</h3><p>The Open&#x2F;Closed Principle states that software entities should be open for extension but closed for modification. This means you should be able to add new functionality without changing existing code.</p><h4 id="Example-in-Rails-1"><a href="#Example-in-Rails-1" class="headerlink" title="Example in Rails:"></a>Example in Rails:</h4><p>Consider a <code>Payment</code> class that processes different types of payments.</p><p><strong>Before:</strong></p><pre><code class="ruby">class Payment  def process(type)    if type == &#39;credit_card&#39;      # Process credit card payment    elsif type == &#39;paypal&#39;      # Process PayPal payment    end  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class Payment  def process(payment_method)    payment_method.process  endendclass CreditCardPayment  def process    # Process credit card payment  endendclass PayPalPayment  def process    # Process PayPal payment  endend</code></pre><h3 id="L-Liskov-Substitution-Principle-LSP"><a href="#L-Liskov-Substitution-Principle-LSP" class="headerlink" title="L - Liskov Substitution Principle (LSP)"></a>L - Liskov Substitution Principle (LSP)</h3><p>The Liskov Substitution Principle states that objects of a superclass should be replaceable with objects of a subclass without affecting the functionality of the program.</p><h4 id="Example-in-Rails-2"><a href="#Example-in-Rails-2" class="headerlink" title="Example in Rails:"></a>Example in Rails:</h4><p>Imagine a <code>Shape</code> class hierarchy where <code>Square</code> and <code>Rectangle</code> are subclasses.</p><p><strong>Before:</strong></p><pre><code class="ruby">class Rectangle  attr_accessor :width, :height  def initialize(width, height)    @width = width    @height = height  end  def area    @width * @height  endendclass Square &lt; Rectangle  def initialize(side)    @width = side    @height = side  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class Shape  def area    raise NotImplementedError, &#39;You must implement the area method&#39;  endendclass Rectangle &lt; Shape  def initialize(width, height)    @width = width    @height = height  end  def area    @width * @height  endendclass Square &lt; Shape  def initialize(side)    @side = side  end  def area    @side * @side  endend</code></pre><h3 id="I-Interface-Segregation-Principle-ISP"><a href="#I-Interface-Segregation-Principle-ISP" class="headerlink" title="I - Interface Segregation Principle (ISP)"></a>I - Interface Segregation Principle (ISP)</h3><p>The Interface Segregation Principle states that no client should be forced to depend on methods it does not use. This means creating specific interfaces for different clients.</p><h4 id="Example-in-Rails-3"><a href="#Example-in-Rails-3" class="headerlink" title="Example in Rails:"></a>Example in Rails:</h4><p>Suppose you have a <code>Report</code> class that generates different types of reports.</p><p><strong>Before:</strong></p><pre><code class="ruby">class Report  def generate_pdf    # Generate PDF report  end  def generate_csv    # Generate CSV report  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class Reportendclass PdfReport &lt; Report  def generate    # Generate PDF report  endendclass CsvReport &lt; Report  def generate    # Generate CSV report  endend</code></pre><h3 id="D-Dependency-Inversion-Principle-DIP"><a href="#D-Dependency-Inversion-Principle-DIP" class="headerlink" title="D - Dependency Inversion Principle (DIP)"></a>D - Dependency Inversion Principle (DIP)</h3><p>The Dependency Inversion Principle states that high-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.</p><h4 id="Example-in-Rails-4"><a href="#Example-in-Rails-4" class="headerlink" title="Example in Rails:"></a>Example in Rails:</h4><p>Consider a <code>Notification</code> class that sends different types of notifications.</p><p><strong>Before:</strong></p><pre><code class="ruby">class Notification  def send_email(message)    # Send email notification  end  def send_sms(message)    # Send SMS notification  endend</code></pre><p><strong>After:</strong></p><pre><code class="ruby">class Notification  def initialize(sender)    @sender = sender  end  def send(message)    @sender.send(message)  endendclass EmailSender  def send(message)    # Send email notification  endendclass SmsSender  def send(message)    # Send SMS notification  endend</code></pre><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Applying SOLID principles in your Ruby on Rails projects can significantly improve the maintainability and flexibility of your code. By following these guidelines, you can create software that is easier to understand, extend, and modify, ultimately leading to better and more robust applications.</p><p>Happy coding!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/04/solid_principles_in_rails/solid_principles.png&quot; class=&quot;&quot; title=&quot;solid_principles&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;U</summary>
      
    
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/categories/Ruby/"/>
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/tags/Ruby/"/>
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
    <category term="Rails" scheme="https://dohungthinhsts.github.io/tags/Rails/"/>
    
    <category term="SOLID" scheme="https://dohungthinhsts.github.io/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>Rediscovering Ruby - Embrace New Features for Optimal Performance</title>
    <link href="https://dohungthinhsts.github.io/2024/01/03/ruby-3-updated/"/>
    <id>https://dohungthinhsts.github.io/2024/01/03/ruby-3-updated/</id>
    <published>2024-01-03T05:00:00.000Z</published>
    <updated>2024-07-04T10:36:23.405Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/03/ruby-3-updated/ruby_avatar.png" class="" title="ruby_avatar"></center><br><h2 id="Rediscovering-Ruby-Embrace-New-Features-for-Optimal-Performance"><a href="#Rediscovering-Ruby-Embrace-New-Features-for-Optimal-Performance" class="headerlink" title="Rediscovering Ruby: Embrace New Features for Optimal Performance"></a>Rediscovering Ruby: Embrace New Features for Optimal Performance</h2><p>Ruby is constantly evolving, and staying updated with its latest features can make a significant difference in your coding efficiency. If you’re still using Ruby 1.9.2 techniques in the Ruby 3.3 era, it’s time to refresh your skills and embrace the new enhancements.</p><p>Many developers tend to stick to the familiar, old methods, missing out on the benefits of the latest updates. Embracing new features is crucial to maintaining Ruby’s relevance and efficiency in the modern programming landscape.</p><h2 id="RBS-Ruby-Signature"><a href="#RBS-Ruby-Signature" class="headerlink" title="RBS (Ruby Signature)"></a>RBS (Ruby Signature)</h2><p>Traditionally, ensuring type safety in Ruby required extensive testing and documentation, which could be time-consuming and error-prone.</p><p>RBS, introduced with Ruby 3.1, is a new language designed to describe the types and interfaces of Ruby code. It allows for static type checking and IDE autocompletion, enhancing code quality and developer productivity.</p><p>While alternatives like Sorbet exist, RBS is officially supported by Matz, making it the standard for type checking in Ruby.</p><pre><code class="ruby"># Point.rbsclass Point  attr_reader x: Integer  attr_reader y: Integer  def initialize: (x: Integer, y: Integer) -&gt; voidend# Point.rbclass Point  attr_reader :x, :y  def initialize(x, y)    @x = x    @y = y  endend</code></pre><p>Steep, a static type checker for Ruby, can be integrated into CI&#x2F;CD pipelines to ensure type safety and catch errors early.</p><p>Here’s how to configure Steep in a GitHub Actions CI&#x2F;CD pipeline:</p><pre><code class="yaml"># .github/workflows/ci.ymlname: CIon: [push, pull_request]jobs:  build:    runs-on: ubuntu-latest    steps:      - name: Checkout code        uses: actions/checkout@v2      - name: Setup Ruby        uses: actions/setup-ruby@v1        with:          ruby-version: &#39;3.3&#39;      - name: Install dependencies        run: bundle install      - name: Run Steep        run: bundle exec steep check</code></pre><p>Integrating Steep into your CI&#x2F;CD pipeline helps maintain code quality by enforcing type safety and preventing runtime errors. This promotes best practices and enhances the reliability of Ruby applications.</p><p>However, adopting RBS might require a significant investment in learning and setting up the necessary tools, and maintaining type annotations can add overhead.</p><h2 id="Pattern-Matching"><a href="#Pattern-Matching" class="headerlink" title="Pattern Matching"></a>Pattern Matching</h2><p>Pattern matching, a highly anticipated feature, was introduced in Ruby 2.7 and further enhanced in Ruby 3.0. Matz wanted to include pattern matching to make Ruby more expressive and align it with modern programming languages.</p><p>Before pattern matching, handling complex data structures required verbose code, making it harder to maintain.</p><p>Pattern matching allows for concise and expressive destructuring and matching of data, improving code readability and maintainability.</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h3><pre><code class="ruby">def company_location_contact_id(company_location_id)  query = &lt;&lt;~GRAPHQL    query($company_location_id: ID!) &#123;      companyLocation(id: $company_location_id) &#123;        ...      &#125;    &#125;  GRAPHQL  response = @client.query(    query:,    variables: &#123; company_location_id: &quot;gid://shopify/CompanyLocation/#&#123;company_location_id&#125;&quot; &#125;  ).body  case response.deep_symbolize_keys  in errors: [&#123; message: error_message &#125;]    Rollbar.error(&quot;#&#123;error_message&#125; for&quot;, company_location_id:)  in data: &#123; companyLocation: nil &#125;    Rollbar.error(&quot;Company location not found&quot;, company_location_id:)  in data: &#123; companyLocation: &#123; roleAssignments: &#123; edges: [&#123; node: &#123; companyContact: &#123; id: contact_id &#125; &#125; &#125;] &#125; &#125; &#125;    contact_id  endend</code></pre><p>Without pattern matching, the code becomes verbose and error-prone, involving nested conditionals or manual parsing of the response data.</p><h2 id="One-Line-Pattern-Matching"><a href="#One-Line-Pattern-Matching" class="headerlink" title="One-Line Pattern Matching"></a>One-Line Pattern Matching</h2><p>Destructuring hashes or arrays often required multiple lines of code. One-line pattern matching, introduced in Ruby 2.7, simplifies this by allowing destructuring in a single line.</p><pre><code class="ruby">data = &#123; user: &#123; name: &quot;Alice&quot;, details: &#123; age: 25, city: &quot;Paris&quot; &#125; &#125; &#125;data =&gt; &#123; user: &#123; name:, details: &#123; age:, city: &#125; &#125; &#125;puts &quot;Name: #&#123;name&#125;, Age: #&#123;age&#125;, City: #&#123;city&#125;&quot;</code></pre><p>While concise, the one-line syntax may be less readable for complex patterns, requiring familiarity with the new syntax.</p><h2 id="Rightward-Assignment"><a href="#Rightward-Assignment" class="headerlink" title="Rightward Assignment"></a>Rightward Assignment</h2><p>Rightward assignment, introduced in Ruby 3.0, simplifies syntax by allowing assignments in a more readable manner.</p><pre><code class="ruby">read_data() =&gt; user_data =&gt; &#123; user: &#123; name:, details: &#123; age:, city: &#125; &#125; &#125;save!(user_data)puts &quot;Name: #&#123;name&#125;, City: #&#123;city&#125;&quot;</code></pre><p>This syntax, though more natural in flow, might be unfamiliar and potentially confusing if overused in complex expressions.</p><h2 id="Refinements"><a href="#Refinements" class="headerlink" title="Refinements"></a>Refinements</h2><p>Global modifications to core classes could lead to conflicts. Refinements, introduced in Ruby 2.0, allow scoped modifications, reducing side effects.</p><pre><code class="ruby">module ArrayExtensions  refine Array do    def to_hash      Hash[*self.flatten]    end  endendclass Converter  using ArrayExtensions  def self.convert(array)    array.to_hash  endendputs Converter.convert([[:key1, &quot;value1&quot;], [:key2, &quot;value2&quot;]])</code></pre><p>Refinements are powerful but can lead to unexpected behavior if not active in the expected context.</p><h2 id="Enumerator-Lazy"><a href="#Enumerator-Lazy" class="headerlink" title="Enumerator::Lazy"></a>Enumerator::Lazy</h2><p>Handling large collections efficiently is crucial. Lazy enumerators, introduced in Ruby 2.0, enable efficient chaining without creating intermediate arrays.</p><pre><code class="ruby">lazy_numbers = (1..Float::INFINITY).lazyresult = lazy_numbers.select &#123; |n| n % 2 == 0 &#125;                     .map &#123; |n| n * n &#125;                     .take(10)                     .to_aputs result.inspect</code></pre><p>While improving performance, lazy enumerators can complicate debugging due to deferred operations.</p><h2 id="Enumerator-Chain"><a href="#Enumerator-Chain" class="headerlink" title="Enumerator::Chain"></a>Enumerator::Chain</h2><p>Chaining multiple enumerables was less expressive. Enumerator::Chain, introduced in Ruby 2.6, simplifies this, enhancing readability.</p><pre><code class="ruby">evens = (2..10).step(2)odds = (1..9).step(2)combined = evens.each.chain(odds.each)puts combined.to_a.inspect</code></pre><p>Though it simplifies chaining, it introduces another concept for developers to learn.</p><h2 id="Module-prepend"><a href="#Module-prepend" class="headerlink" title="Module#prepend"></a>Module#prepend</h2><p>Using include to mix in modules could make method overrides complex. Module#prepend, introduced in Ruby 2.0, provides a more predictable method override mechanism.</p><pre><code class="ruby">module Logging  def process    puts &quot;Logging before processing&quot;    super    puts &quot;Logging after processing&quot;  endendclass DataProcessor  def process    puts &quot;Processing data&quot;  endendclass CustomProcessor &lt; DataProcessor  prepend Loggingendprocessor = CustomProcessor.newprocessor.process</code></pre><p>Prepend can complicate the method lookup chain, requiring a clear understanding of include and prepend differences.</p><h2 id="End-less-Method-Definition"><a href="#End-less-Method-Definition" class="headerlink" title="End-less Method Definition"></a>End-less Method Definition</h2><p>Defining simple methods required multiple lines. Endless method definitions, introduced in Ruby 3.0, provide a concise syntax for single-expression methods.</p><pre><code class="ruby">class Calculator  def add(a, b) = a + b  def multiply(a, b) = a * b  def power(base, exponent) = base**exponentendcalc = Calculator.newputs calc.add(2, 3)       # Output: 5puts calc.multiply(4, 5)  # Output: 20puts calc.power(2, 3)     # Output: 8</code></pre><p>This new syntax, while reducing boilerplate, might be less familiar and potentially reduce readability if overused.</p><h2 id="it-Parameter"><a href="#it-Parameter" class="headerlink" title="it Parameter"></a><code>it</code> Parameter</h2><p>Using explicit block variables could be verbose for simple operations. The <code>it</code> parameter, introduced in Ruby 3.0, simplifies block syntax.</p><pre><code class="ruby">[&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;].map &#123; it.upcase.reverse &#125;</code></pre><p>This parameter can make code less readable for complex operations, introducing a new convention for developers to learn.</p><h2 id="String-casecmp"><a href="#String-casecmp" class="headerlink" title="String#casecmp?"></a>String#casecmp?</h2><p>Case-insensitive string comparison was verbose. String#casecmp?, introduced in Ruby 2.4, simplifies this operation.</p><pre><code class="ruby">strings = [&quot;Hello&quot;, &quot;world&quot;, &quot;HELLO&quot;]matches = strings.select &#123; |s| s.casecmp?(&quot;hello&quot;) &#125;puts matches.inspect # =&gt; [&quot;Hello&quot;, &quot;HELLO&quot;]</code></pre><h2 id="Object-yield-self-and-then"><a href="#Object-yield-self-and-then" class="headerlink" title="Object#yield_self and then"></a>Object#yield_self and then</h2><p>Chaining operations on an object could be verbose. Object#yield_self and its alias then improve readability and fluidity.</p><pre><code class="ruby">result = &quot;hello&quot;         .yield_self &#123; |str| str.upcase &#125;         .then &#123; |str| str + &quot; WORLD&quot; &#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/03/ruby-3-updated/ruby_avatar.png&quot; class=&quot;&quot; title=&quot;ruby_avatar&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;Rediscovering-Ruby-Emb</summary>
      
    
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/categories/Ruby/"/>
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/tags/Ruby/"/>
    
    <category term="Programming" scheme="https://dohungthinhsts.github.io/tags/Programming/"/>
    
    <category term="DevOps" scheme="https://dohungthinhsts.github.io/tags/DevOps/"/>
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
  </entry>
  
  <entry>
    <title>Enhancing Performance in Ruby On Rails - Method Comparisons</title>
    <link href="https://dohungthinhsts.github.io/2024/01/02/efficiency_in_ruby/"/>
    <id>https://dohungthinhsts.github.io/2024/01/02/efficiency_in_ruby/</id>
    <published>2024-01-02T05:00:00.000Z</published>
    <updated>2024-07-04T10:26:08.161Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/02/efficiency_in_ruby/ruby_avatar.png" class="" title="ruby_avatar"></center><br><h2 id="Introduction-The-Drive-for-Efficiency"><a href="#Introduction-The-Drive-for-Efficiency" class="headerlink" title="Introduction: The Drive for Efficiency"></a>Introduction: The Drive for Efficiency</h2><p>In the realm of software engineering, efficiency extends beyond speed. It’s about optimizing resources and enhancing user experiences. In Ruby, known for its elegance, the choice of methods significantly affects performance. This article explores various Ruby and Rails methods, comparing their memory usage and runtime efficiency.</p><h2 id="exists-vs-present-vs-any"><a href="#exists-vs-present-vs-any" class="headerlink" title="exists? vs present? vs any?"></a>exists? vs present? vs any?</h2><p>Using <code>present?</code> or <code>any?</code> on an ActiveRecord relation loads the records into memory to check for matches, which can be inefficient with large datasets.</p><pre><code class="ruby">User.where(email: &#39;example@gmail.com&#39;).present?User.where(email: &#39;example@gmail.com&#39;).any?</code></pre><h3 id="The-Advantage-of-exists"><a href="#The-Advantage-of-exists" class="headerlink" title="The Advantage of exists?"></a>The Advantage of <code>exists?</code></h3><p>The <code>exists?</code> method is designed to check for the presence of a record without loading the actual data, making it much faster.</p><pre><code class="ruby">User.where(email: &#39;example@gmail.com&#39;).exists?</code></pre><h2 id="update-all-vs-update"><a href="#update-all-vs-update" class="headerlink" title="update_all vs update"></a>update_all vs update</h2><h3 id="The-Drawback-of-update"><a href="#The-Drawback-of-update" class="headerlink" title="The Drawback of update"></a>The Drawback of <code>update</code></h3><p>Using <code>update</code> on individual records triggers multiple database queries.</p><pre><code class="ruby">users.each &#123; |user| user.update(active: true) &#125;</code></pre><h3 id="The-Efficiency-of-update-all"><a href="#The-Efficiency-of-update-all" class="headerlink" title="The Efficiency of update_all"></a>The Efficiency of <code>update_all</code></h3><p>The <code>update_all</code> method updates all matching records in a single query, significantly improving performance. It’s important to use <code>where</code> judiciously to ensure the column is indexed.</p><pre><code class="ruby">User.where(active: false).update_all(active: true)</code></pre><h2 id="includes-vs-joins-vs-preload"><a href="#includes-vs-joins-vs-preload" class="headerlink" title="includes vs joins vs preload"></a>includes vs joins vs preload</h2><h3 id="Eager-Loading-Associations"><a href="#Eager-Loading-Associations" class="headerlink" title="Eager Loading Associations"></a>Eager Loading Associations</h3><p>The N+1 Query Problem: Using <code>joins</code> can cause the N+1 query problem, where each associated record is queried separately.</p><pre><code class="ruby">User.joins(:posts) # InefficientUser.joins(:posts).each &#123; |user| user.posts.each &#123; |post| puts post.title &#125; &#125;</code></pre><h3 id="The-Efficiency-of-includes"><a href="#The-Efficiency-of-includes" class="headerlink" title="The Efficiency of includes"></a>The Efficiency of <code>includes</code></h3><p>The <code>includes</code> method performs eager loading, fetching all associated records with minimal queries.</p><pre><code class="ruby">User.includes(:posts).each &#123; |user| user.posts.each &#123; |post| puts post.title &#125; &#125;</code></pre><h2 id="count-vs-size-vs-length"><a href="#count-vs-size-vs-length" class="headerlink" title="count vs size vs length"></a>count vs size vs length</h2><h3 id="Counting-Records"><a href="#Counting-Records" class="headerlink" title="Counting Records"></a>Counting Records</h3><h3 id="The-Inefficiency-of-length"><a href="#The-Inefficiency-of-length" class="headerlink" title="The Inefficiency of length"></a>The Inefficiency of <code>length</code></h3><p>Using <code>length</code> loads all records into memory, which can be inefficient.</p><pre><code class="ruby">User.all.length # Inefficient</code></pre><h3 id="The-Efficiency-of-count"><a href="#The-Efficiency-of-count" class="headerlink" title="The Efficiency of count"></a>The Efficiency of <code>count</code></h3><p>The <code>count</code> method executes a <code>SELECT COUNT(*)</code> query, which is more efficient for large datasets.</p><pre><code class="ruby">User.count # Always makes one queryUser.all.count &#123; |u| u.active? &#125; # Efficient use case</code></pre><h3 id="The-Versatility-of-size"><a href="#The-Versatility-of-size" class="headerlink" title="The Versatility of size"></a>The Versatility of <code>size</code></h3><p>The <code>size</code> method adapts to the situation, determining whether to use an existing dataset or make a count query.</p><ul><li>Use <code>length</code> if the dataset is already loaded.</li><li>Use <code>count</code> if nothing is loaded.</li><li>Use <code>size</code> for automatic adaptation.</li></ul><h2 id="find-vs-find-each"><a href="#find-vs-find-each" class="headerlink" title="find vs find_each"></a>find vs find_each</h2><p>Using <code>find</code> to handle thousands of records is inefficient as it loads all records before processing.</p><pre><code class="ruby">User.find(1..10000).each do |user|  # some processingend</code></pre><h3 id="The-Efficiency-of-find-each"><a href="#The-Efficiency-of-find-each" class="headerlink" title="The Efficiency of find_each"></a>The Efficiency of <code>find_each</code></h3><p><code>find_each</code> processes records in batches, reducing memory usage.</p><pre><code class="ruby">User.find_each(batch_size: 1000) do |user|  # some processingend</code></pre><h2 id="select-vs-pluck"><a href="#select-vs-pluck" class="headerlink" title="select vs pluck"></a>select vs pluck</h2><h3 id="Using-select"><a href="#Using-select" class="headerlink" title="Using select"></a>Using <code>select</code></h3><p>This method selects specific columns and loads them as ActiveRecord objects.</p><pre><code class="ruby">User.select(:id, :name, :email).each &#123; |user| ... &#125;</code></pre><h3 id="Using-pluck"><a href="#Using-pluck" class="headerlink" title="Using pluck"></a>Using <code>pluck</code></h3><p>This method retrieves specified columns directly from the database, returning an array of values.</p><pre><code class="ruby">User.pluck(:id, :name, :email)</code></pre><h2 id="where-vs-find-by"><a href="#where-vs-find-by" class="headerlink" title="where vs find_by"></a>where vs find_by</h2><h3 id="Using-where"><a href="#Using-where" class="headerlink" title="Using where"></a>Using <code>where</code></h3><p><code>where</code> is suitable for retrieving multiple records.</p><pre><code class="ruby">User.where(name: &#39;John&#39;).first</code></pre><h3 id="Using-find-by"><a href="#Using-find-by" class="headerlink" title="Using find_by"></a>Using <code>find_by</code></h3><p><code>find_by</code> is optimized to return the first matching record, halting the query as soon as a match is found.</p><pre><code class="ruby">User.find_by(name: &#39;John&#39;)</code></pre><h2 id="delete-all-vs-destroy-all"><a href="#delete-all-vs-destroy-all" class="headerlink" title="delete_all vs destroy_all"></a>delete_all vs destroy_all</h2><h3 id="delete-all"><a href="#delete-all" class="headerlink" title="delete_all"></a><code>delete_all</code></h3><p><code>delete_all</code> performs fast deletions directly in the database without loading records into Rails models.</p><pre><code class="ruby">User.where(active: false).delete_all</code></pre><h3 id="destroy-all"><a href="#destroy-all" class="headerlink" title="destroy_all"></a><code>destroy_all</code></h3><p><code>destroy_all</code> deletes records while running callbacks, ensuring data integrity at the cost of performance.</p><pre><code class="ruby">User.where(active: false).destroy_all</code></pre><p>I hope you find this article helpful.</p><p>Happy coding!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/02/efficiency_in_ruby/ruby_avatar.png&quot; class=&quot;&quot; title=&quot;ruby_avatar&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;Introduction-The-D</summary>
      
    
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/categories/Ruby/"/>
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/tags/Ruby/"/>
    
    <category term="Programming" scheme="https://dohungthinhsts.github.io/tags/Programming/"/>
    
    <category term="DevOps" scheme="https://dohungthinhsts.github.io/tags/DevOps/"/>
    
    <category term="Software Development" scheme="https://dohungthinhsts.github.io/tags/Software-Development/"/>
    
  </entry>
  
  <entry>
    <title>Understanding Docker-Compose Configuration</title>
    <link href="https://dohungthinhsts.github.io/2024/01/01/docker-compose/"/>
    <id>https://dohungthinhsts.github.io/2024/01/01/docker-compose/</id>
    <published>2024-01-01T05:00:00.000Z</published>
    <updated>2024-07-04T10:25:58.451Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2024/01/01/docker-compose/docker_compose_avatar.png" class="" title="docker_compose_avatar"></center><br><h2 id="What-is-Docker-Compose"><a href="#What-is-Docker-Compose" class="headerlink" title="What is Docker-Compose?"></a>What is Docker-Compose?</h2><p>Docker-Compose is a tool that simplifies the orchestration of multi-container Docker applications. It allows you to define your application stack in a <code>docker-compose.yml</code> file, specifying the services, networks, and volumes needed. With a single command, you can start, stop, and manage your entire application.</p><h2 id="Key-Benefits-of-Docker-Compose"><a href="#Key-Benefits-of-Docker-Compose" class="headerlink" title="Key Benefits of Docker-Compose"></a>Key Benefits of Docker-Compose</h2><ul><li><strong>Simplifies multi-container setups</strong>: Manage complex applications with multiple services effortlessly.</li><li><strong>Reproducible environments</strong>: Ensure consistent setups across different environments (development, testing, production).</li><li><strong>Easy orchestration</strong>: Streamline operations with commands to start, stop, and rebuild services.</li></ul><h2 id="Basic-Structure-of-a-docker-compose-yml-File"><a href="#Basic-Structure-of-a-docker-compose-yml-File" class="headerlink" title="Basic Structure of a docker-compose.yml File"></a>Basic Structure of a docker-compose.yml File</h2><p>A <code>docker-compose.yml</code> file consists of several key sections: <code>version</code>, <code>services</code>, <code>networks</code>, and <code>volumes</code>. Here’s a breakdown of each component:</p><h3 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h3><p>The <code>version</code> key specifies the Compose file format. It ensures compatibility with different Docker-Compose versions.</p><pre><code class="yaml">version: &#39;3.8&#39;</code></pre><h3 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h3><p>The <code>services</code> section defines the individual containers that make up your application. Each service is a container, and you can specify its image, build context, ports, environment variables, and dependencies.</p><p><strong>Example</strong>:</p><pre><code class="yaml">services:  web:    image: nginx:latest    ports:      - &quot;80:80&quot;  database:    image: postgres:latest    environment:      POSTGRES_USER: example      POSTGRES_PASSWORD: example</code></pre><h2 id="Networks"><a href="#Networks" class="headerlink" title="Networks"></a>Networks</h2><p>The <code>networks</code> section defines the custom networks for your containers. By default, docker-Compose creates a network for your services, but you can also specify custom networks for advanced configurations.</p><p><strong>Example</strong>:</p><pre><code class="yaml">networks:  frontend:  backend:</code></pre><h2 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes"></a>Volumes</h2><p>The <code>volumes</code> section defines named volumes that persist data across container restarts. Volumes are essential for storing database data, user uploads, and other persistent information.</p><p><strong>Example</strong>:</p><pre><code class="yaml">volumes:  db-data:</code></pre><h3 id="Advanced-Docker-Compose-Configuration"><a href="#Advanced-Docker-Compose-Configuration" class="headerlink" title="Advanced Docker-Compose Configuration"></a>Advanced Docker-Compose Configuration</h3><p>Beyond the basics, Docker-Compose supports advanced configurations to fine-tune your applications.</p><h2 id="Service-Dependencies"><a href="#Service-Dependencies" class="headerlink" title="Service Dependencies"></a>Service Dependencies</h2><p>Use the <code>depends_on</code> key to specify service dependencies, ensuring that services start in a particular order.</p><p><strong>Example</strong>:</p><pre><code class="yaml">services:  web:    depends_on:      - database</code></pre><h2 id="Health-Checks"><a href="#Health-Checks" class="headerlink" title="Health Checks"></a>Health Checks</h2><p>Define health checks to monitor the status of your services, ensuring they are running correctly.</p><p><strong>Example</strong>:</p><pre><code class="yaml">services:  web:    healthcheck:      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]      interval: 30s      timeout: 10s      retries: 3</code></pre><h2 id="Secrets-and-Configs"><a href="#Secrets-and-Configs" class="headerlink" title="Secrets and Configs"></a>Secrets and Configs</h2><p>Manage sensitive data and configuration files securely with the secrets and configs keys.</p><p><strong>Example</strong>:</p><pre><code class="yaml">services:  web:    secrets:      - db_passwordsecrets:  db_password:    file: ./db_password.txt</code></pre><h3 id="Common-Commands"><a href="#Common-Commands" class="headerlink" title="Common Commands"></a>Common Commands</h3><h2 id="Starting-Services"><a href="#Starting-Services" class="headerlink" title="Starting Services"></a>Starting Services</h2><p>To start your defined services, use the up command:</p><pre><code class="sh">docker-compose up -d</code></pre><h2 id="Stopping-Services"><a href="#Stopping-Services" class="headerlink" title="Stopping Services"></a>Stopping Services</h2><p>To stop your services, use the down command:</p><pre><code class="sh">docker-compose down</code></pre><h2 id="Viewing-Logs"><a href="#Viewing-Logs" class="headerlink" title="Viewing Logs"></a>Viewing Logs</h2><p>To view logs from your services, use the logs command:</p><pre><code class="sh">docker-compose logs -f</code></pre><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>Docker-Compose is an invaluable tool for managing multi-container Docker applications. By understanding its configuration and leveraging its features, you can streamline your development workflow and ensure consistent environments across different stages of your project. Start by defining your services, networks, and volumes, and explore advanced configurations to optimize your application’s performance and security.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2024/01/01/docker-compose/docker_compose_avatar.png&quot; class=&quot;&quot; title=&quot;docker_compose_avatar&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;Wh</summary>
      
    
    
    
    <category term="Docker" scheme="https://dohungthinhsts.github.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://dohungthinhsts.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Create Rails Project By Docker</title>
    <link href="https://dohungthinhsts.github.io/2023/05/10/create-rails-by-docker/"/>
    <id>https://dohungthinhsts.github.io/2023/05/10/create-rails-by-docker/</id>
    <published>2023-05-10T02:53:12.000Z</published>
    <updated>2024-07-04T09:38:46.499Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2023/05/10/create-rails-by-docker/docker_rails.png" class="" title="docker_rails"></center><br><h2 id="Problems"><a href="#Problems" class="headerlink" title="Problems?"></a>Problems?</h2><p>What is your typical approach for creating a new Rails project?</p><p>When I first started learning Rails, I would install a new version of Ruby, followed by Rails, and then create a new project. However, this approach became tedious due to the need to manage Ruby dependencies for each project, dealing with version mismatches, and encountering various other issues.</p><p>As such, I sought out a way to streamline the process of creating new Rails projects. Docker has proven to be a reliable solution for this, enabling me to work efficiently and avoid many of the aforementioned challenges.</p><h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><p>Before beginning, ensure that you have Docker installed on your computer. Next, follow these steps to create a new folder for your project:</p><pre><code class="bash">  $ mkdir my-new-rails-app  $ cd my-new-rails-app</code></pre><p>Once inside the new folder, create a <code>Dockerfile</code> with a minimal setup to support the desired Ruby version. You can find the image name corresponding to your Ruby version on Docker Hub. For example, if you’re using Ruby version 3.2.2, your Dockerfile should look like this:</p><pre><code class="dockerfile">FROM ruby:3.2.2WORKDIR /usr/src/app</code></pre><p>The <code>WORKDIR</code> directive specifies the folder within the container that will host your code and will serve as the default location when accessing the container shell.</p><p>Next, create a <code>docker-compose.yml</code> file with the following content:</p><pre><code class="docker-compose.yml">services:  web:    build: .    ports:      - &quot;3001:3000&quot;    volumes:      - .:/usr/src/app</code></pre><p>The <code>3001</code> port is used to access the server from the browser, while <code>3000</code> is the port inside the container.<br>The volume is essential because it allows the template files generated by the Rails application in the container to persist in the host filesystem.<br>Other information can be ignored at this stage</p><p>Now we can go ahead and access the terminal of the container while exposing the service ports so we can access the Rails application later on via localhost:3001:</p><pre><code class="bash">docker-compose run --service-ports web bash</code></pre><p>After running the above commands, you can install the Rails application inside the container using:</p><pre><code class="bash">gem install railsrails new .</code></pre><p>Once you run these commands, take a look inside the <code>my-new-rails-app</code> folder to see the entire Rails source.</p><p>Now you can have your Rails source without installing anything on your host machine.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Once you have the Rails source project, you can edit the Dockerfile and add more services like a database, etc. to complete the Rails environment setup.</p><p>This approach allows for easy creation of new Rails projects without worrying about rvm, rbenv or dependency overlap. I hope you found this article informative. Goodbye!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2023/05/10/create-rails-by-docker/docker_rails.png&quot; class=&quot;&quot; title=&quot;docker_rails&quot;&gt;
&lt;/center&gt;

&lt;br&gt;


&lt;h2 id=&quot;Problems&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Docker" scheme="https://dohungthinhsts.github.io/categories/Docker/"/>
    
    
    <category term="rails" scheme="https://dohungthinhsts.github.io/tags/rails/"/>
    
    <category term="Docker" scheme="https://dohungthinhsts.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>What is docker</title>
    <link href="https://dohungthinhsts.github.io/2023/05/02/basic-docker/"/>
    <id>https://dohungthinhsts.github.io/2023/05/02/basic-docker/</id>
    <published>2023-05-02T05:00:00.000Z</published>
    <updated>2024-07-04T09:33:50.628Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2023/05/02/basic-docker/docker_avatar.png" class="" title="docker_avatar"></center><br><h2 id="What-is-Docker"><a href="#What-is-Docker" class="headerlink" title="What is Docker?"></a>What is Docker?</h2><p>Docker is a platform that allows developers to build, ship, and run applications in containers. Containers are isolated environments that include all the necessary dependencies and libraries needed to run the application. This helps ensure that the application runs consistently across different machines and environments, regardless of the underlying operating system or hardware.</p><h2 id="How-Does-Docker-Work"><a href="#How-Does-Docker-Work" class="headerlink" title="How Does Docker Work?"></a>How Does Docker Work?</h2><p>Docker works by using containerization technology. Containers are standalone packages that contain everything needed to run an application, including the code, runtime, system tools, libraries, and settings. Each container is isolated from the host system and other containers, making it easier to manage and deploy applications.</p><p>Docker uses a client-server architecture. The Docker client communicates with the Docker daemon to build, run, and manage containers. Docker images are used as templates to create containers, with each image containing a specific version of an application and all its dependencies.</p><p>Here’s a step-by-step breakdown of how Docker works:</p><ul><li><b>Create a Dockerfile</b>: A Dockerfile is a script that defines the application’s environment, including its dependencies and how it should be configured. The Dockerfile is used to build a Docker image.</li></ul><center><img src="/2023/05/02/basic-docker/Dockerfile.png" class="" title="Dockerfile"></center><ul><li><b>Build the Docker Image</b>: Using the Dockerfile, the Docker image is built. This image contains everything needed to run the application, including the code, dependencies, and configuration.</li></ul><center><img src="/2023/05/02/basic-docker/docker_images.png" class="" title="docker_images"></center><ul><li><b>Run the Docker Image</b>: The Docker image is run in a container. This container is isolated from the host system and other containers, ensuring that the application runs consistently across different environments.</li></ul><pre><code class="bash"> docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></pre><ul><li><b>Deploy the Docker Container</b>: Once the Docker container is running, it can be deployed to different machines and environments, making it easy to scale the application and ensure it runs consistently across all instances.</li></ul><h2 id="Benefits-of-Docker"><a href="#Benefits-of-Docker" class="headerlink" title="Benefits of Docker"></a>Benefits of Docker</h2><p>There are many benefits to using Docker for application development and deployment, including:</p><ul><li><p><b>Portability</b>: Docker containers are portable and can be run on any machine or environment that supports Docker, making it easier to deploy applications across different environments.</p></li><li><p><b>Isolation</b>: Containers provide a high level of isolation, helping to prevent conflicts between applications and dependencies.</p></li><li><p><b>Efficiency</b>: Docker containers are lightweight and use fewer resources than traditional virtual machines, making them more efficient and faster to deploy.</p></li><li><p><b>Scalability</b>: Docker makes it easy to scale applications by quickly deploying additional containers to handle increased demand.</p></li></ul><h2 id="Illustrations"><a href="#Illustrations" class="headerlink" title="Illustrations"></a>Illustrations</h2><p>Here are some illustrations to help visualize how Docker works:</p><center><img src="/2023/05/02/basic-docker/how_docker_work.png" class="" title="how_docker_work"></center><h2 id="Docker-Architecture"><a href="#Docker-Architecture" class="headerlink" title="Docker Architecture"></a>Docker Architecture</h2><p>This illustration shows the client-server architecture of Docker. The Docker client communicates with the Docker daemon to build, run, and manage containers. Docker images are used as templates to create containers, with each image containing a specific version of an application and all its dependencies.</p><center><img src="/2023/05/02/basic-docker/client_server_docker_architecture.png" class="" title="client_server_docker_architecture"></center><h2 id="Docker-Containerization"><a href="#Docker-Containerization" class="headerlink" title="Docker Containerization"></a>Docker Containerization</h2><p>This illustration shows how Docker uses containerization to create isolated environments for applications to run. Each container includes all the necessary dependencies and libraries needed to run the application, ensuring that it runs consistently across different machines and environments.</p><center><img src="/2023/05/02/basic-docker/docker_container.png" class="" title="docker_container"></center><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Docker is a powerful tool for application development and deployment. Its standardized approach to containerization, high level of isolation, portability, efficiency, and scalability make it an essential tool for modern software development. Whether you’re a developer looking to build and deploy applications or a system administrator looking to manage and scale applications, Docker can help simplify and streamline the process.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2023/05/02/basic-docker/docker_avatar.png&quot; class=&quot;&quot; title=&quot;docker_avatar&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

&lt;h2 id=&quot;What-is-Docker&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="Docker" scheme="https://dohungthinhsts.github.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://dohungthinhsts.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Yaml for Web Developers</title>
    <link href="https://dohungthinhsts.github.io/2020/07/19/yaml/"/>
    <id>https://dohungthinhsts.github.io/2020/07/19/yaml/</id>
    <published>2020-07-19T05:00:00.000Z</published>
    <updated>2023-05-01T06:23:06.242Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2020/07/19/yaml/xml-vs-json-vs-yaml.png" class="" title="yaml"></center><p>As a Ruby On Rails developer, I bet you’ve seen a lot of .yml files in your project like database.yml(database configuration), en.yml(translate configuration), etc. But let’s face it, do you really know about .yml file???</p><p>All the things I know when I start a new rails project are .yml files serve for configuration but not know why using this extension and the benefit of it.</p><h1 id="What-is-YAML"><a href="#What-is-YAML" class="headerlink" title="What is YAML?"></a>What is YAML?</h1><p>Follow wikipedia, we have a definition:</p><blockquote><p>“YAML (a recursive acronym for “YAML Ain’t Markup Language”) is a human-readable data-serialization language” YAML (from version 1.2) is a superset of JSON and is commonly used for configuration files and in applications where data is being stored or transmitted.</p></blockquote><p>It means a lot, right? We use it for configuration and somehow YAML is so much more than JSON, especially about human-readable respective.</p><h1 id="YAML-vs-JSON"><a href="#YAML-vs-JSON" class="headerlink" title="YAML vs JSON"></a>YAML vs JSON</h1><p>Before dive into the different, we need to know the term superset first:</p><blockquote><p>“Superset is A programming language that contains all the features of a given language and has been expanded or enhanced to include other features as well.” - Font</p></blockquote><p>If you are an FE developer, you can see the relationship between YAML and JSON is similar to TypeScript and Javascript in JS world.<br>Let’s see this example:</p><pre><code class="json">&#123;  &quot;json&quot;: [    &quot;rigid&quot;,    &quot;better for data interchange&quot;  ],  &quot;yaml&quot;: [    &quot;slim and flexible&quot;,    &quot;better for configuration&quot;  ],  &quot;object&quot;: &#123;    &quot;array&quot;: [      &#123;        &quot;null_value&quot;: null      &#125;,      &#123;        &quot;boolean&quot;: true      &#125;,      &#123;        &quot;integer&quot;: 1      &#125;    ]  &#125;,  &quot;paragraph&quot;: &quot;Blank lines denote\nparagraph breaks\n&quot;,  &quot;content&quot;: &quot;Or we\ncan auto\nconvert line breaks\nto save space&quot;&#125;</code></pre><p>Here is an example JSON file, seems easy to read, but you can see some limitations:</p><ul><li>Can’t create variables.</li><li>Can’t use external variables.</li><li>Overrides values.</li></ul><p>And now, convert it to YAML syntax</p><pre><code class="json">json:  - rigid  - better for data interchangeyaml:  - slim and flexible  - better for configurationobject:  array:    - null_value:    - boolean: true    - integer: 1paragraph: &gt;   Blank lines denote   paragraph breakscontent: |-   Or we   can auto   convert line breaks   to save space</code></pre><p>Hmmm, the light is flickering :smiley:</p><h1 id="Concepts-Types-Syntax"><a href="#Concepts-Types-Syntax" class="headerlink" title="Concepts, Types, Syntax"></a>Concepts, Types, Syntax</h1><p>Let’s take a look in some concepts of YAML</p><p><b>INDENTATION</b><br><br><br>In Yaml, indentation does matter. It uses whitespace indentation to nest information. By whitespace, keep in mind tab is not allowed.</p><p><b>KEY&#x2F;VALUE</b><br><br><br>Like in JSON&#x2F;JS, YAML also uses the key&#x2F;value syntax and you can use in various ways:</p><pre><code class="php">key: valuekey_one: value onekey one: value # This works but it&#39;s weird&#39;my key&#39;: somekey</code></pre><p><b>COMMENTS</b><br><br><br>To write a comment in YAML, you just have to use # followed by your message content.</p><pre><code class="php"># I&#39;m a commentperson: # I&#39;m also a comment  age: 20</code></pre><p><b>LIST</b><br><br><br>There’re 2 ways to write lists:</p><ul><li>The old way(JSON way): array of strings.</li></ul><pre><code class="php">people: [&#39;Anne&#39;, &#39;John&#39;, &#39;Max&#39;]</code></pre><ul><li>The new way(Hyphen syntax from YAML).</li></ul><pre><code class="php">  people:    - Anne    - John    - Max</code></pre><p><b>STRINGS</b><br><br>We have several ways to write strings in yaml:</p><pre><code class="php">company: Google # Single words, no quotesfull_name: John Foo Bar Doe # Full sentence, no quotesname: &#39;John&#39; # Using single quotessurname: &quot;Christian Meyer&quot; # Using double quotes</code></pre><p>While in JSON we would have only one way to use double quotes:</p><pre><code class="json">&#123;  &quot;company&quot;: &quot;Google&quot;,  &quot;full_name&quot;: &quot;John Foo Bar Doe&quot;,  &quot;name&quot;: &quot;John&quot;,  &quot;surname&quot;: &quot;Christian Meyer&quot;&#125;</code></pre><p><b>NUMBERS</b><br><br><br>We have two types of number in YAML: Integer and Float</p><pre><code class="php">year: 2019 # IntegernodeVersion: 10.8 # Float</code></pre><p><b>NODE ANCHORS</b><br><br><br>I have no doubt if you are yawning with some information above, but please wake up because Node Anchors is an interesting feature.<br><br><br>An anchor is a mechanism to create a group of data (an object) that can be injected or extended from other objects.<br>If you’re a ruby on rails developer, I’m surely that you read that kind of feature in database.yml</p><pre><code class="php">  default: &amp;default    adapter: sqlite3    pool: &lt;%= ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) &#123; 5 &#125; %&gt;    timeout: 5000  development:    &lt;&lt;: *default    database: db/development.sqlite3  test:    &lt;&lt;: *default    database: db/test.sqlite3  production:    &lt;&lt;: *default    database: db/production.sqlite3</code></pre><p>But wait, take a deep eye, you may ask what the hell with:</p><pre><code class="php">  default: &amp;default    .    .    .  development:    &lt;&lt;: *default</code></pre><p>Yeah, that it is, here is an anchor. If you don’t use anchor, you have to repeat the same group configuration, equivalent:</p><pre><code class="php">  development:    adapter: sqlite3    pool: &lt;%= ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) &#123; 5 &#125; %&gt;    timeout: 5000    database: db/development.sqlite3  test:    adapter: sqlite3    pool: &lt;%= ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) &#123; 5 &#125; %&gt;    timeout: 5000    database: db/test.sqlite3  production:    adapter: sqlite3    pool: &lt;%= ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) &#123; 5 &#125; %&gt;    timeout: 5000    database: db/production.sqlite3</code></pre><p>So much copy&#x2F;paste here, instead of it, we create an anchor “<em>default</em>“, and inject it to another place in the YAML file.</p><pre><code class="php">  default: &amp;default    adapter: sqlite3    pool: &lt;%= ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) &#123; 5 &#125; %&gt;    timeout: 5000  development:    &lt;&lt;: *default    database: db/development.sqlite3</code></pre><p><b>JSON SYNTAX</b><br><br><br>Because YAML is a superset of JSON, it means we can write YAML by JSON way::</p><pre><code class="json">&#123;  &quot;details&quot;: &#123;    &quot;company&quot;: &#123;      &quot;name&quot;: &quot;Google&quot;,      &quot;year&quot;: 2019,      &quot;active&quot;: true    &#125;,    &quot;employees&quot;: [      &quot;Anne&quot;,      &quot;John&quot;,      &quot;Max&quot;    ]  &#125;&#125;</code></pre><p><b>SHELL&#x2F;BASH ENVIRONMENT</b><br><br><br>It’s very common .yml files are used as config files for many things, but especially for CI&#x2F;CD environment.<br>In CI&#x2F;CD environment, we usually use docker for setup&#x2F;installed environment, let’s check out a docker-compose.yml file:</p><pre><code class="php">version: &quot;3&quot;variables:  REDIS_IMAGE: redisservices:  node-app:    build: .    ports:      - &#39;4001:8081&#39;  redis-server:    image: $REDIS_IMAGE</code></pre><p>Note that the syntax to use variables by $ isn’t from YAML but shell&#x2F;bash.<br>What GitLab CI does is getting everything you’d defined in variables and creates shell variables.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Every day we see a lot of “<em>yml</em>“ files but not so sure about the benefit and how it works, I hope you found some useful information in this article.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://yaml.org/">Yaml official website</a><br><a href="https://www.json2yaml.com/">Convert Json To Yaml</a><br><a href="https://en.wikipedia.org/wiki/YAML">Yaml Wikipedia</a><br><a href="https://dev.to/raulfdm/yaml-for-web-developers-559n">Yaml blog</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2020/07/19/yaml/xml-vs-json-vs-yaml.png&quot; class=&quot;&quot; title=&quot;yaml&quot;&gt;
&lt;/center&gt;

&lt;p&gt;As a Ruby On Rails developer, I bet you’ve</summary>
      
    
    
    
    <category term="Yaml" scheme="https://dohungthinhsts.github.io/categories/Yaml/"/>
    
    
  </entry>
  
  <entry>
    <title>Ruby 2.7#tally</title>
    <link href="https://dohungthinhsts.github.io/2020/05/05/tally/"/>
    <id>https://dohungthinhsts.github.io/2020/05/05/tally/</id>
    <published>2020-05-05T06:12:25.000Z</published>
    <updated>2023-05-01T06:08:29.653Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/2020/05/05/tally/enumrable.png" class="" title="tally"></center><h1> Problems? </h1><p>If you’re ruby on rails developer, you might face resolving something like generating a hash from a list with different key and the values are the number that it appears in the list.There are likely several more variants of this, but those are a few of the more common ones you might see around.</p><p>For example:</p><pre><code class="ruby">list.group_by &#123; |v| v.something &#125;.transform_values(&amp;:size)list.group_by &#123; |v| v.something &#125;.map &#123; |k, vs| [k, vs.size] &#125;.to_hlist.group_by &#123; |v| v.something &#125;.to_h &#123; |k, vs| [k, vs.size] &#125;list.each_with_object(Hash.new(0)) &#123; |v, h| h[v.something] += 1 &#125;</code></pre><p>Any chances to make it short and more readable for developer?</p><p>Yes, we have it already since Ruby 2.7.</p><h1> Welcome to Enumerable#tally </h1><p>“<em>tally</em>“ counts things:</p><pre><code class="ruby">[1, 1, 2].tally# =&gt; &#123; 1 =&gt; 2, 2 =&gt; 1 &#125;[1, 1, 2].map(&amp;:even?).tally# =&gt; &#123; false =&gt; 2, true =&gt; 1 &#125;</code></pre><p>“<em>tally</em>“ works by counting the occurrences of each element in an Enumrable type. If we apply that to a list of string type, it might be clearer</p><pre><code class="ruby">%w(foo foo bar foo baz foo).tally=&gt; &#123;&quot;foo&quot; =&gt; 4, &quot;bar&quot; =&gt; 1, &quot;baz&quot; =&gt; 1&#125;</code></pre><p><em>tally_by</em> has not been accepted into core, but you can map the list first:</p><pre><code class="ruby">%w(foo foo bar foo baz foo).map &#123; |s| s[0] &#125;.tally=&gt; &#123;“f” =&gt; 4, “b” =&gt; 2&#125;</code></pre><h1> Wrapping Up </h1><p>Ruby 2.7 brings us so many interesting things. So keep track of it.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
&lt;img src=&quot;/2020/05/05/tally/enumrable.png&quot; class=&quot;&quot; title=&quot;tally&quot;&gt;
&lt;/center&gt;

&lt;h1&gt; Problems? &lt;/h1&gt;

&lt;p&gt;If you’re ruby on rails deve</summary>
      
    
    
    
    <category term="Ruby" scheme="https://dohungthinhsts.github.io/categories/Ruby/"/>
    
    
  </entry>
  
  <entry>
    <title>Ethereum Series(DAPP)</title>
    <link href="https://dohungthinhsts.github.io/2017/11/02/dapp/"/>
    <id>https://dohungthinhsts.github.io/2017/11/02/dapp/</id>
    <published>2017-11-02T06:12:25.000Z</published>
    <updated>2023-05-01T05:59:13.799Z</updated>
    
    <content type="html"><![CDATA[<p>Hầu hết các ứng dụng trên Internet hiện nay là Centralized. Có nghĩa rằng, các ứng dụng chạy ở dưới người dùng sẽ là client kết nối với một trung tâm server, nơi chịu trách nhiệm, cam kết về service đối với người dùng. Nếu bạn để ý sẽ thấy rằng các websites, hay games đều thuộc sở hữu của một công  ty hoặc một cá nhân cụ thể. Các nhà phát triển phần mềm đã xây dựng các ứng dụng Centralized trong một khoảng thời gian dài. Tuy nhiên, có một vài đặc điểm của ứng dụng mà các hệ thống Centralized không thể đáp ứng được, hoặc nếu có đáp ứng được thì vẫn dẫn đến một vài vấn đề nghiêm trọng. Các vấn đề đó bao gồm: tính minh bạch, tính chịu lỗi, không ngăn chặn được quá trình kiểm duyệt của đơn vị chức năng… Để giải quyết những vấn đề này, một công nghệ mới dành cho việc xây dựng ứng dụng Internet được gọi là decentralized applications (Dapps) ra đời.<br>Trong bài viết này, chúng ta sẽ tìm hiểu về Decentralized Apps.</p><p>Các topics trong bài viết này bao gồm:</p><ul><li>DApps là gì?</li><li>Sự khác nhau giữa decentralized, centralized, và distributed applications?</li><li>Ưu, nhược điểm của centralized và decentralized applications.</li><li>Giới thiệu về một số DApps nổi tiếng hiện nay.</li></ul><p><strong>1. Dapp là gì?</strong></p><p>Một Dapp về cơ bản là một ứng dụng Internet nơi mà backend được chạy trên một mạng lưới peer-to-peer và source code của nó phải là open source. Với cơ chế như vậy, không có một node nào trên mạng lưới có khả năng điều khiển hoàn toàn Dapp.</p><p>Phụ thuộc vào các chức năng của Dapp mà nó sẽ có các kiểu data structures khác nhau nhằm mục đích lưu trữ dữ liệu. Ví dụ, bitcoin DApp sử dụng blockchain data structure.</p><p>Peer ở đây có thể là bất kỳ máy tính nào có kết nối đến Internet, điều này gây khó khăn lớn để có thể phát hiện hay ngăn chặn một peer nào đó cố gắng để tạo ra sự sai lệch thông tin và broadcast cho tất cả các peers còn lại. Với thách thức trên, đã có một vài các protocol(consensus protocol) với ý nghĩa sẽ xem xét tính đúng đắn của dữ liệu được publish ra từ một node là đúng hay sai. Đây là vấn đề riêng của hệ thống Decentralized vì các hệ thống như Centralized được quản lí bởi một server có khả năng phán xét tính đúng đắn của thông tin được publish từ một client.<br>Consensus protocol được thiết kế dành riêng cho một loại data structure mà DApp sử dụng. Ví dụ, bitcoin sử dụng proof-of-work protocol để có thể đảm bảo tính thống nhất trong Dapp.</p><p>Mọi DApp đều cần một client để user sử dụng. Trước tiên trong quá trình sử dụng, chúng ta cần một node ở trên mạng và node này sẽ trở thành node server kết nối với client. Những node của DApp bây giờ sẽ cung cấp các API và thúc đẩy các nhà developers phát triển đa dạng các client sử dụng API này.  Một vài developer sẽ công khai cung cấp client, các client này nên là open source và nên được download để sử dụng, nếu ngược lại, toàn bộ ý tưởng của decentralization sẽ bị sai lệch.</p><center><img src="/2017/11/02/dapp/centralized_decentralized_distributed.jpeg" class="" title="centralized_decentralized_distribution"></center><center>So sánh trực quan các hệ thống hiện tại.</center><p><strong>2. Ưu điểm của ứng dụng decentralized</strong></p><ul><li>DApp rất mạnh về khả năng chịu lỗi, vì không hề có một điểm chịu lỗi duy nhất nào. Bất cứ node nào trên mạng lưới bị lỗi sẽ ko gây ảnh hưởng đến toàn bộ hệ thống.</li><li>DApp ngăn chặn sự kiểm duyệt bất hợp lệ(censorship) vì không có một trung tâm nào đứng ra chịu trách nhiệm Dapp.  Vì thế chính phủ sẽ không có khả năng gây áp lực để kiểm duyệt thông tin. Chính phủ cũng không thể ngăn chặn domain hay IP của ứng dụng vì DApp hoàn toàn không truy cập thông qua một domain hay một IP nào cụ thể. Tất nhiên là bạn có thể nghĩ rằng chính phủ có khả năng theo vết(track) của một node nào đó và chặn IP của chính node này, tuy nhiên, với một mạng peer-to-peer đủ lớn, thực sự rất khó khăn để có thể tắt ứng dụng Dapp, đặc biết là khi mạng lưới này trải rộng trên nhiều quốc gia.</li><li>Đáng tin cậy. User sẽ hoàn toàn tin cậy vào Dapp vì nó không bị điều khiển bởi một trung tâm hay đơn vị nào cả.</li></ul><p><strong>3. Nhược điểm của ứng dụng decentralized</strong></p><p>Dĩ nhiên là mọi hệ thống đều có ưu điểm và nhược điểm, dưới đây là một số nhược điểm:</p><ul><li>Việc fix bug hay update DApp là điều khó khăn, vì mọi node trên mạng đều phải được update.</li><li>Vì một số DApp yêu cầu xác nhận danh tính(authorize) và vì DApp không hề có một trung tâm chịu trách nhiệm quản lí để xác mình danh tính người dùng, điều này trở thành vấn đề lớn trong quá trình phát triển Dapp.</li><li>DApp rất khó xây dựng, vì nó sử dụng nhiều protocol phức tạp để đạt được tính thống nhất(consensus) như đã nói qua ở trên. Không giống như các ứng dụng centralized bắt đầu với ý tưởng(idea), rồi thêm các features rồi sau đó thì scale ứng dụng, DApp phải scale hệ thống ngay khi họ vừa bắt đầu.</li><li>Một ứng dụng thường sẽ có những phụ thuộc nhất định vào thirt-party API để lấy hoặc lưu trữ thông tin. Tuy nhiên, DApp không nên phụ thuộc vào centralized application APIs, nó nên phụ thuộc vào các DApp khác. Mặc dù vậy, các DApp trên thế giới hiện nay chưa thực sự phổ biến, cộng với việc DApp trong thực tế vẫn khá khó khăn để tương tác với các Dapp khác.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hầu hết các ứng dụng trên Internet hiện nay là Centralized. Có nghĩa rằng, các ứng dụng chạy ở dưới người dùng sẽ là client kết nối với m</summary>
      
    
    
    
    <category term="BlockChain" scheme="https://dohungthinhsts.github.io/categories/BlockChain/"/>
    
    
  </entry>
  
  <entry>
    <title>Ethereum Series(Introduction)</title>
    <link href="https://dohungthinhsts.github.io/2017/11/02/ethereum/"/>
    <id>https://dohungthinhsts.github.io/2017/11/02/ethereum/</id>
    <published>2017-11-02T06:11:25.000Z</published>
    <updated>2023-05-01T05:59:54.390Z</updated>
    
    <content type="html"><![CDATA[<p>Xin chào các bạn, đây là bài blog đầu tiên của mình trong series Ethereum, các kiến thức mà mình nêu ra trong series này sẽ tập trung vào cuốn sách Building BlockChain Projects của tác giả Narayan Prusty. Cuốn sách này đang được bán trên Amazon với giá $7.99.</p><center><img src="/2017/11/02/ethereum/building_blockchain_project.png" class="" title="building_blockchain_project"></center><center>Building BlockChain Projects</center><p>Giới thiệu sơ qua về cuốn Building BlockChain Projects:<br>Cuốn sách trình bày về các khái niệm cơ bản của Ethereum(include BlockChain) theo lối dẫn dắt dễ hiểu và tự nhiên, nội dung bao gồm các khái niệm về DAPP, How Ethereum Works, Writing Smart Contract, Getting Started With Web3js, Building Wallet Service, so on…</p><p>Thông qua các kiến thức của cuốn sách này và mức độ tìm hiểu của bản thân, mong rằng mình có thể giúp các bạn có thể tiếp cận với Ethereum 1 cách dễ dàng hơn, thích thú hơn.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Xin chào các bạn, đây là bài blog đầu tiên của mình trong series Ethereum, các kiến thức mà mình nêu ra trong series này sẽ tập trung vào</summary>
      
    
    
    
    <category term="BlockChain" scheme="https://dohungthinhsts.github.io/categories/BlockChain/"/>
    
    
  </entry>
  
</feed>
