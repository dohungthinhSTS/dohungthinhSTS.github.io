<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>Enhancing Performance in Ruby On Rails - Method Comparisons</title><meta name="description" content="The only limit is the one you set for yourself."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="





Introduction: The Drive for EfficiencyIn the realm of software engineering, efficiency extends beyond speed. It’s about optimizing resources and enhancing user experiences. In Ruby, known for its elegance, the choice of methods significantly affects performance. This article explores various Ruby and Rails methods, comparing their memory usage and ru.."><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">dohungthinhtin's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Enhancing Performance in Ruby On Rails - Method Comparisons</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction-The-Drive-for-Efficiency"><span class="toc-text">Introduction: The Drive for Efficiency</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exists-vs-present-vs-any"><span class="toc-text">exists? vs present? vs any?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Advantage-of-exists"><span class="toc-text">The Advantage of exists?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#update-all-vs-update"><span class="toc-text">update_all vs update</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Drawback-of-update"><span class="toc-text">The Drawback of update</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Efficiency-of-update-all"><span class="toc-text">The Efficiency of update_all</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#includes-vs-joins-vs-preload"><span class="toc-text">includes vs joins vs preload</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Eager-Loading-Associations"><span class="toc-text">Eager Loading Associations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Efficiency-of-includes"><span class="toc-text">The Efficiency of includes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#count-vs-size-vs-length"><span class="toc-text">count vs size vs length</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Counting-Records"><span class="toc-text">Counting Records</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Inefficiency-of-length"><span class="toc-text">The Inefficiency of length</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Efficiency-of-count"><span class="toc-text">The Efficiency of count</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Versatility-of-size"><span class="toc-text">The Versatility of size</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#find-vs-find-each"><span class="toc-text">find vs find_each</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Efficiency-of-find-each"><span class="toc-text">The Efficiency of find_each</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select-vs-pluck"><span class="toc-text">select vs pluck</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-select"><span class="toc-text">Using select</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-pluck"><span class="toc-text">Using pluck</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#where-vs-find-by"><span class="toc-text">where vs find_by</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-where"><span class="toc-text">Using where</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-find-by"><span class="toc-text">Using find_by</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delete-all-vs-destroy-all"><span class="toc-text">delete_all vs destroy_all</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#delete-all"><span class="toc-text">delete_all</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#destroy-all"><span class="toc-text">destroy_all</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Ruby"><i class="tag post-item-tag">Ruby</i></a><a href="/tags/Programming"><i class="tag post-item-tag">Programming</i></a><a href="/tags/DevOps"><i class="tag post-item-tag">DevOps</i></a><a href="/tags/Software-Development"><i class="tag post-item-tag">Software-Development</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Enhancing Performance in Ruby On Rails - Method Comparisons</h1><time class="has-text-grey" datetime="2024-01-02T05:00:00.000Z">2024-01-02</time><article class="mt-2 post-content"><center>
<img src="/2024/01/02/efficiency_in_ruby/ruby_avatar.png" class="" title="ruby_avatar">
</center>

<br>

<h2 id="Introduction-The-Drive-for-Efficiency"><a href="#Introduction-The-Drive-for-Efficiency" class="headerlink" title="Introduction: The Drive for Efficiency"></a>Introduction: The Drive for Efficiency</h2><p>In the realm of software engineering, efficiency extends beyond speed. It’s about optimizing resources and enhancing user experiences. In Ruby, known for its elegance, the choice of methods significantly affects performance. This article explores various Ruby and Rails methods, comparing their memory usage and runtime efficiency.</p>
<h2 id="exists-vs-present-vs-any"><a href="#exists-vs-present-vs-any" class="headerlink" title="exists? vs present? vs any?"></a>exists? vs present? vs any?</h2><p>Using <code>present?</code> or <code>any?</code> on an ActiveRecord relation loads the records into memory to check for matches, which can be inefficient with large datasets.</p>
<pre><code class="ruby">User.where(email: &#39;example@gmail.com&#39;).present?
User.where(email: &#39;example@gmail.com&#39;).any?
</code></pre>
<h3 id="The-Advantage-of-exists"><a href="#The-Advantage-of-exists" class="headerlink" title="The Advantage of exists?"></a>The Advantage of <code>exists?</code></h3><p>The <code>exists?</code> method is designed to check for the presence of a record without loading the actual data, making it much faster.</p>
<pre><code class="ruby">User.where(email: &#39;example@gmail.com&#39;).exists?
</code></pre>
<h2 id="update-all-vs-update"><a href="#update-all-vs-update" class="headerlink" title="update_all vs update"></a>update_all vs update</h2><h3 id="The-Drawback-of-update"><a href="#The-Drawback-of-update" class="headerlink" title="The Drawback of update"></a>The Drawback of <code>update</code></h3><p>Using <code>update</code> on individual records triggers multiple database queries.</p>
<pre><code class="ruby">users.each &#123; |user| user.update(active: true) &#125;
</code></pre>
<h3 id="The-Efficiency-of-update-all"><a href="#The-Efficiency-of-update-all" class="headerlink" title="The Efficiency of update_all"></a>The Efficiency of <code>update_all</code></h3><p>The <code>update_all</code> method updates all matching records in a single query, significantly improving performance. It’s important to use <code>where</code> judiciously to ensure the column is indexed.</p>
<pre><code class="ruby">User.where(active: false).update_all(active: true)
</code></pre>
<h2 id="includes-vs-joins-vs-preload"><a href="#includes-vs-joins-vs-preload" class="headerlink" title="includes vs joins vs preload"></a>includes vs joins vs preload</h2><h3 id="Eager-Loading-Associations"><a href="#Eager-Loading-Associations" class="headerlink" title="Eager Loading Associations"></a>Eager Loading Associations</h3><p>The N+1 Query Problem: Using <code>joins</code> can cause the N+1 query problem, where each associated record is queried separately.</p>
<pre><code class="ruby">User.joins(:posts) # Inefficient
User.joins(:posts).each &#123; |user| user.posts.each &#123; |post| puts post.title &#125; &#125;
</code></pre>
<h3 id="The-Efficiency-of-includes"><a href="#The-Efficiency-of-includes" class="headerlink" title="The Efficiency of includes"></a>The Efficiency of <code>includes</code></h3><p>The <code>includes</code> method performs eager loading, fetching all associated records with minimal queries.</p>
<pre><code class="ruby">User.includes(:posts).each &#123; |user| user.posts.each &#123; |post| puts post.title &#125; &#125;
</code></pre>
<h2 id="count-vs-size-vs-length"><a href="#count-vs-size-vs-length" class="headerlink" title="count vs size vs length"></a>count vs size vs length</h2><h3 id="Counting-Records"><a href="#Counting-Records" class="headerlink" title="Counting Records"></a>Counting Records</h3><h3 id="The-Inefficiency-of-length"><a href="#The-Inefficiency-of-length" class="headerlink" title="The Inefficiency of length"></a>The Inefficiency of <code>length</code></h3><p>Using <code>length</code> loads all records into memory, which can be inefficient.</p>
<pre><code class="ruby">User.all.length # Inefficient
</code></pre>
<h3 id="The-Efficiency-of-count"><a href="#The-Efficiency-of-count" class="headerlink" title="The Efficiency of count"></a>The Efficiency of <code>count</code></h3><p>The <code>count</code> method executes a <code>SELECT COUNT(*)</code> query, which is more efficient for large datasets.</p>
<pre><code class="ruby">User.count # Always makes one query
User.all.count &#123; |u| u.active? &#125; # Efficient use case
</code></pre>
<h3 id="The-Versatility-of-size"><a href="#The-Versatility-of-size" class="headerlink" title="The Versatility of size"></a>The Versatility of <code>size</code></h3><p>The <code>size</code> method adapts to the situation, determining whether to use an existing dataset or make a count query.</p>
<ul>
<li>Use <code>length</code> if the dataset is already loaded.</li>
<li>Use <code>count</code> if nothing is loaded.</li>
<li>Use <code>size</code> for automatic adaptation.</li>
</ul>
<h2 id="find-vs-find-each"><a href="#find-vs-find-each" class="headerlink" title="find vs find_each"></a>find vs find_each</h2><p>Using <code>find</code> to handle thousands of records is inefficient as it loads all records before processing.</p>
<pre><code class="ruby">User.find(1..10000).each do |user|
  # some processing
end
</code></pre>
<h3 id="The-Efficiency-of-find-each"><a href="#The-Efficiency-of-find-each" class="headerlink" title="The Efficiency of find_each"></a>The Efficiency of <code>find_each</code></h3><p><code>find_each</code> processes records in batches, reducing memory usage.</p>
<pre><code class="ruby">User.find_each(batch_size: 1000) do |user|
  # some processing
end
</code></pre>
<h2 id="select-vs-pluck"><a href="#select-vs-pluck" class="headerlink" title="select vs pluck"></a>select vs pluck</h2><h3 id="Using-select"><a href="#Using-select" class="headerlink" title="Using select"></a>Using <code>select</code></h3><p>This method selects specific columns and loads them as ActiveRecord objects.</p>
<pre><code class="ruby">User.select(:id, :name, :email).each &#123; |user| ... &#125;
</code></pre>
<h3 id="Using-pluck"><a href="#Using-pluck" class="headerlink" title="Using pluck"></a>Using <code>pluck</code></h3><p>This method retrieves specified columns directly from the database, returning an array of values.</p>
<pre><code class="ruby">User.pluck(:id, :name, :email)
</code></pre>
<h2 id="where-vs-find-by"><a href="#where-vs-find-by" class="headerlink" title="where vs find_by"></a>where vs find_by</h2><h3 id="Using-where"><a href="#Using-where" class="headerlink" title="Using where"></a>Using <code>where</code></h3><p><code>where</code> is suitable for retrieving multiple records.</p>
<pre><code class="ruby">User.where(name: &#39;John&#39;).first
</code></pre>
<h3 id="Using-find-by"><a href="#Using-find-by" class="headerlink" title="Using find_by"></a>Using <code>find_by</code></h3><p><code>find_by</code> is optimized to return the first matching record, halting the query as soon as a match is found.</p>
<pre><code class="ruby">User.find_by(name: &#39;John&#39;)
</code></pre>
<h2 id="delete-all-vs-destroy-all"><a href="#delete-all-vs-destroy-all" class="headerlink" title="delete_all vs destroy_all"></a>delete_all vs destroy_all</h2><h3 id="delete-all"><a href="#delete-all" class="headerlink" title="delete_all"></a><code>delete_all</code></h3><p><code>delete_all</code> performs fast deletions directly in the database without loading records into Rails models.</p>
<pre><code class="ruby">User.where(active: false).delete_all
</code></pre>
<h3 id="destroy-all"><a href="#destroy-all" class="headerlink" title="destroy_all"></a><code>destroy_all</code></h3><p><code>destroy_all</code> deletes records while running callbacks, ensuring data integrity at the cost of performance.</p>
<pre><code class="ruby">User.where(active: false).destroy_all
</code></pre>
<p>I hope you find this article helpful.</p>
<p>Thôi Lo Code Đi Kẻo Sếp nạt!</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2024/01/03/ruby-3-updated/" title="Rediscovering Ruby - Embrace New Features for Optimal Performance"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Rediscovering Ruby - Embrace New Features for Optimal Performance</span></a><a class="button is-default" href="/2024/01/01/docker-compose/" title="Understanding Docker-Compose Configuration"><span class="has-text-weight-semibold">Next: Understanding Docker-Compose Configuration</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/dohungthinhSTS"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com/thinhdohung/"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><a title="linkedin" target="_blank" rel="noopener nofollow" href="//www.linkedin.com/in/thinh-hung-a74943132/"><i class="iconfont icon-linkedin"></i></a><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com/thinh.dohung/"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> dohungthinhtin 2024</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>